[
  {
    "objectID": 1,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What Quasar is and how it can considerably reduce your development time and costs.",
    "anchor": "Introduction",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 2,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Also because: * It's based on Vue.js * You get a state-of-the-art UI (that follows Material Guidelines) for your websites and apps out of the box * Best support for desktop and mobile browsers (including iOS Safari!) out of the box * Best-in-class support for each build mode (SPA, SSR, PWA, Mobile app, Desktop app & Browser Extension) and the best developer experience through a tight integration with our own CLI * It's easily customizable (CSS) and extendable (JS) * It's the most performance-focused framework * It's tree-shakable automatically * Incredible community on our Forum and Discord chat * Has a regular release cycle inclusive of new features * Gets quick fixes and listens to the community's requests * Handles the whole development experience (including even creating your app's icons and splash screens) Quasar is the number one solution based on Vue whether you're only building a desktop website, a desktop app, a mobile app, or even all of them. Worried about bloat? You shouldn't be. If you only want to build a website, Quasar will only build the code required for a website, with nothing else. Same goes for the other build modes.",
    "anchor": "Introduction",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 3,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": "What is Quasar?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar's motto is: write code once and simultaneously deploy it as a website, a Mobile App and/or an Electron App. Yes, one codebase for all of them, helping you develop an app in record time by using a state-of-the-art CLI and backed by best-practice, blazing fast Quasar web components. When using Quasar, you won't need additional heavy libraries like Hammer.js, Moment.js or Bootstrap. It's got those needs covered internally, and all with a small footprint!",
    "anchor": "What-is-Quasar%3F",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 4,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": "What else you got?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What we want to achieve with Quasar is to raise the bar for web development as a whole. Make it go forward, evolve. Change minds. Point out when there’s a better alternative.  Below is a non-exhaustive list of Quasar's great aspects and features.",
    "anchor": "What-else-you-got%3F",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 5,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": "What else you got?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "All Platforms in One Go",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar takes care of all these web development best practices and more - with no configuration needed.",
    "anchor": "All-Platforms-in-One-Go",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 6,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": "What else you got?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "App extensions support",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "State-preserving hot module reload (HMR) when making changes to an app's source code, no matter if it’s a website, PWA, a Mobile App (directly on a phone or on an emulator), or an Electron app. Developers simply change their code, save the changes and then watch it get updated on the fly, without the need of any page refresh. State-preserving compilation error overlay Lint-on-save with ESLint – if developers like linting their code ES6 code transpiling Sourcemaps Changing build options doesn’t require a manual reload of the dev server And many more leading-edge developer tools and techniques",
    "anchor": "App-extensions-support",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 7,
    "hierarchy_lvl0": "Why Quasar?",
    "hierarchy_lvl1": "Why Quasar?",
    "hierarchy_lvl2": "What else you got?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Get up to speed fast",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Except for Vue, which only takes half a day to pick up and will change your life forever, there is no requirement for you to know the other technologies. They are all integrated and configured in Quasar for you.",
    "anchor": "Get-up-to-speed-fast",
    "url": "/introduction-to-quasar"
  },
  {
    "objectID": 8,
    "hierarchy_lvl0": "Sponsors and Backers",
    "hierarchy_lvl1": "Sponsors and Backers",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of sponsors and backers who are donating to Quasar Framework development.",
    "anchor": "Introduction",
    "url": "/sponsors-and-backers"
  },
  {
    "objectID": 9,
    "hierarchy_lvl0": "Sponsors and Backers",
    "hierarchy_lvl1": "Sponsors and Backers",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Like most open source products, Quasar can't do it alone. We rely on sponsors, backers and supporters to keep things going. When Quasar starts to bring you some financial stability, please be considerate of the tens of thousands of hours that went into its creation and send some money back to the team that made it possible. And finally, if your company relies on Quasar, the best way to guarantee that Quasar continues to be there for you is to invest in its maintenance! Please read our manifesto on Why donations are important.",
    "anchor": "Introduction",
    "url": "/sponsors-and-backers"
  },
  {
    "objectID": 10,
    "hierarchy_lvl0": "Sponsors and Backers",
    "hierarchy_lvl1": "Sponsors and Backers",
    "hierarchy_lvl2": "Donating",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All donations are used for Quasar Development purposes exclusively.  For a full list of our wonderful people who make Quasar happen, visit the Backers page.",
    "anchor": "Donating",
    "url": "/sponsors-and-backers"
  },
  {
    "objectID": 11,
    "hierarchy_lvl0": "Sponsors and Backers",
    "hierarchy_lvl1": "Sponsors and Backers",
    "hierarchy_lvl2": "Platinum, Gold and Silver Sponsors",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can find the artwork for Quasar (logos and graphics) on Github.",
    "anchor": "Platinum%2C-Gold-and-Silver-Sponsors",
    "url": "/sponsors-and-backers"
  },
  {
    "objectID": 12,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar Team's manifesto on why it is essential to donate towards the development of the framework.",
    "anchor": "Introduction",
    "url": "/why-donate"
  },
  {
    "objectID": 13,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Like most open source products, Quasar can't do it alone. We rely on sponsors, backers and supporters to keep things going. When Quasar starts to bring you some financial stability, please be considerate of the tens of thousands of hours that went into its creation and send some money back to the team that made it possible. And finally, if your company relies on Quasar, the best way to guarantee that Quasar continues to be there for you is to invest in its maintenance!",
    "anchor": "Introduction",
    "url": "/why-donate"
  },
  {
    "objectID": 14,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": "Our Manifesto",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The dream of open source is a noble cause, where communities grow and code is nurtured. In line with the philosophy of Free Open Source, Quasar has committed itself to the tenets of Good Labs' . Quasar is and always will be free and open source, a self-managed place where everyone who abides by the community rules is invited and encouraged to participate.",
    "anchor": "Our-Manifesto",
    "url": "/why-donate"
  },
  {
    "objectID": 15,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": "Our Manifesto",
    "hierarchy_lvl3": "Participation is a Form of Collaborative Appreciation",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Many open source projects, like the Quasar Framework and Vue.js, have been developed by people who work on behalf of their community on their own time, with no demand for financial compensation. This \"code ownership\" is actually a very important issue because the owners decide how things are to be further developed. So who are these people? They are people, like you, in need of a certain feature and have found an open source solution, like Quasar. They are people who use the software and decided to contribute by helping to improve it. Possibly they are passionate about coding and want a project to occupy their talents. There are many reasons to get involved in a community around an open source project. But the majority have one thing in common: They find free time in their busy schedules of jobs, families and commitments in order to participate because it makes them feel good to be part of something bigger than any one individual. To give you a bit of perspective, the lead developer and core-maintainer of Quasar, Razvan Stoenescu, has spent over 2000 hours during the development phases between 1.0.0-alpha.1 and 1.0.0-rc.1, during which time he logged more than 2000 commits and half of a million lines of code added. The rest of the team and all of the staff working the chat support lines and fixing code are still (as of June 2019) unpaid volunteers working uncountable hours. They are slowly becoming more and more responsible for units of the project and are an invaluable resource for the community that we must safeguard.",
    "anchor": "Participation-is-a-Form-of-Collaborative-Appreciation",
    "url": "/why-donate"
  },
  {
    "objectID": 16,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": "Our Manifesto",
    "hierarchy_lvl3": "Finanicial Sponsorship to Guarantee Maintenance",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "That point in time for Quasar is right now and your support will make the difference. If your business relies on open source you can hedge the risk of it disappearing by financially supporting it so that you can rest assured that the software will continue to be available for you. As opposed to long-term licensing contracts for proprietary software, this model works because you encourage innovation, help to develop the next generation of developers and are implicitly empowered to participate in the discussion about features you need and issues you have found. If open source becomes financially viable for those developing the projects, more people will get involved. If these developers are able to earn enough to support themselves, they are more likely to stay involved. Financial sustenance of open-source literally means that those who develop the project have an additional reason to stick around. Many promising open source projects become \"abandonware\" because the original developers ran out of steam. The maintenance phase is actually where many open-source projects go to die. Money is a great type of community feedback that says \"Stick with it and continue to maintain this project! We need you!!!\"",
    "anchor": "Finanicial-Sponsorship-to-Guarantee-Maintenance",
    "url": "/why-donate"
  },
  {
    "objectID": 17,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": "Our Manifesto",
    "hierarchy_lvl3": "What You Get Out of It",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "So maybe you are a business who uses open source software to give themselves a competitive advantage, improve profits, or simply solve a problem other software doesn’t cover. Perhaps you’re an individual who uses an open source solution to the expensive corporate software you just can’t afford. Like this. Or you recognize that the millions of lines of code are lines you don't have to write and are simply appreciative of the effort. Whatever you use open source software for, think of those people who have spent long hours developing it and keeping it running for you. Even a small donation could mean a huge difference to them, not least because it means someone out there appreciates them enough to let them know.",
    "anchor": "What-You-Get-Out-of-It",
    "url": "/why-donate"
  },
  {
    "objectID": 18,
    "hierarchy_lvl0": "Why Donate?",
    "hierarchy_lvl1": "Why Donations Are Important",
    "hierarchy_lvl2": "Donating",
    "hierarchy_lvl3": "What You Get Out of It",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Donating through the Github Sponsorship is recommended because Github will also match your donation (making it worth double your amount). All donations are used for Quasar Development purposes exclusively.  For a full list of our wonderful people who make Quasar happen, visit the Backers page.",
    "anchor": "Donating",
    "url": "/why-donate"
  },
  {
    "objectID": 19,
    "hierarchy_lvl0": "Video Tutorials",
    "hierarchy_lvl1": "Video Tutorials",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of video tutorials on Quasar created by the community.",
    "anchor": "Introduction",
    "url": "/video-tutorials"
  },
  {
    "objectID": 20,
    "hierarchy_lvl0": "Video Tutorials",
    "hierarchy_lvl1": "Video Tutorials",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The video tutorials below have been created by the community.  If you want to have your own video tutorial listed here, please email razvan.stoenescu [at] gmail [dot] com with the details. Thank you.",
    "anchor": "Introduction",
    "url": "/video-tutorials"
  },
  {
    "objectID": 21,
    "hierarchy_lvl0": "Video Tutorials",
    "hierarchy_lvl1": "Video Tutorials",
    "hierarchy_lvl2": "Quasar v2 video tutorials",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Why not submit yours as first one? ## Quasar v1 (legacy) video tutorials",
    "anchor": "Quasar-v2-video-tutorials",
    "url": "/video-tutorials"
  },
  {
    "objectID": 22,
    "hierarchy_lvl0": "Video Tutorials",
    "hierarchy_lvl1": "Video Tutorials",
    "hierarchy_lvl2": "Vue 2 (legacy) video tutorials",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar is based on Vue, so knowledge about it is important too.",
    "anchor": "Vue-2-(legacy)-video-tutorials",
    "url": "/video-tutorials"
  },
  {
    "objectID": 23,
    "hierarchy_lvl0": "Meet the Team",
    "hierarchy_lvl1": "Meet the Team",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of people behind Quasar Framework.",
    "anchor": "Introduction",
    "url": "/meet-the-team"
  },
  {
    "objectID": 24,
    "hierarchy_lvl0": "Meet the Team",
    "hierarchy_lvl1": "Meet the Team",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "With hundreds of contributors to Quasar, the list of people you can meet below is by no means exhaustive. Just remember to thank everyone using Quasar and supporting us, because together we all help you push your products light-years ahead of your competition. A great way to do that is to donate.",
    "anchor": "Introduction",
    "url": "/meet-the-team"
  },
  {
    "objectID": 25,
    "hierarchy_lvl0": "Pick Quasar Flavour",
    "hierarchy_lvl1": "Getting Started - Pick a Quasar Flavour",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get started with Quasar by picking one of its flavours: Quasar CLI, Vue CLI or UMD",
    "anchor": "Introduction",
    "url": "/start/pick-quasar-flavour"
  },
  {
    "objectID": 26,
    "hierarchy_lvl0": "Pick Quasar Flavour",
    "hierarchy_lvl1": "Getting Started - Pick a Quasar Flavour",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are three ways of using Quasar. Pick the one that suits you best: UMD/Standalone (embed into an existing project through CDN, progressive integration) Quasar CLI (the premium developer experience and highly recommended) Vue CLI plugin Here's a quick comparison:  (*)Important! Although you may get a similar multi-platform support via the Vue CLI and some Vue community built plugins, these 3rd party supported build paths aren't tightly integrated with Quasar's components. Thus, as you run into problems with these 3rd party plugins, you will have to depend on the support of each individual plugin developer. With Quasar, you have a one-stop-shop should anything go wrong. Also, the Quasar CLI ensures applications are built to the best possible standards in both performance, project size and best practices. You will find no such guarantees anywhere else!  So, let's get you going with Quasar's CLI! You'll be up and running with a new project in a matter of minutes.",
    "anchor": "Introduction",
    "url": "/start/pick-quasar-flavour"
  },
  {
    "objectID": 27,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "Quasar CLI",
    "hierarchy_lvl2": "Quasar CLI",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Quasar CLI, the premium developer experience for free.",
    "anchor": "Introduction",
    "url": "/start/quasar-cli"
  },
  {
    "objectID": 28,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "Quasar CLI",
    "hierarchy_lvl2": "Quasar CLI",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "...within the same project folder, ensuring you are following the best Quasar practices while everything will simply work out of the box.",
    "anchor": "Introduction",
    "url": "/start/quasar-cli"
  },
  {
    "objectID": 29,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "Quasar CLI",
    "hierarchy_lvl2": "What's Included",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "While developing with Dev Server ($ quasar dev): * Babel, so you can write ES6 code * Webpack + vue-loader for Vue SFC (single file components) * State preserving hot-reload * State preserving compilation error overlay * Lint-on-save with ESLint * Source maps * Develop right on a device emulator (or a real phone connected to your machine) if you target a Mobile App * Develop right on an Electron window with Developer Tools included if you target an Electron App * ...many more Developing for production ($ quasar build): * Javascript minified with UglifyJS * HTML minified with html-minifier * CSS across all components extracted (and auto-prefixed) into a single file and minified with cssnano * All static assets are compiled with version hashes for efficient long-term caching, and a production index.html is auto-generated with proper URLs to these generated assets. * ...many more Take note of the /quasar.conf.js file in the root of your project folder. This file helps you quickly configure the way your website/App works. We'll go over it in the Configuration section.",
    "anchor": "What's-Included",
    "url": "/start/quasar-cli"
  },
  {
    "objectID": 30,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Quasar UMD - CDN install",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Unified Module Definition form of Quasar.",
    "anchor": "Introduction",
    "url": "/start/umd"
  },
  {
    "objectID": 31,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Quasar UMD - CDN install",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "* Please notice the <!DOCTYPE html> at the beginning of the document. Do not forget to add it, or else some browsers (notably Safari) will use some compatibility mode that breaks flex. * If you are using an RTL Quasar language pack (eg. Hebrew) then toggle the \"RTL CSS support\" above too! * Do NOT use self-closing tags, like <q-icon ... />. Instead, go with <q-icon ...></q-icon>.   All components, directives and Quasar plugins are ready to be used out of the box. There is no need for additional code to install them. Just make sure that you will NOT be using self-closing tags.",
    "anchor": "Introduction",
    "url": "/start/umd"
  },
  {
    "objectID": 32,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "JsFiddle / Codepen",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "These links (obviously) use the Quasar UMD version.",
    "anchor": "JsFiddle-%2F-Codepen",
    "url": "/start/umd"
  },
  {
    "objectID": 33,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Quasar Global Object",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Some usage examples:",
    "anchor": "Quasar-Global-Object",
    "url": "/start/umd"
  },
  {
    "objectID": 34,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Quasar Config Object",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar-Config-Object",
    "url": "/start/umd"
  },
  {
    "objectID": 35,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll notice that all the Quasar Components, Quasar Directives and Quasar Plugins have an installation section at the top of their pages.  By using the UMD version, you'll have all of the components, directives and Quasar plugins already installed for you. You just need to start using them. Do not use self-closing tags with the UMD version: You will notice that you won't be able to use the self-closing tag form of any of the components. You must close all components tags.",
    "anchor": "Usage",
    "url": "/start/umd"
  },
  {
    "objectID": 36,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Quasar Components",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar-Components",
    "url": "/start/umd"
  },
  {
    "objectID": 37,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Quasar Directives",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar-Directives",
    "url": "/start/umd"
  },
  {
    "objectID": 38,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Quasar Plugins",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar-Plugins",
    "url": "/start/umd"
  },
  {
    "objectID": 39,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Quasar Utils",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar-Utils",
    "url": "/start/umd"
  },
  {
    "objectID": 40,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Changing Quasar Icon Set",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of available Quasar Icon Sets can be found on GitHub.",
    "anchor": "Changing-Quasar-Icon-Set",
    "url": "/start/umd"
  },
  {
    "objectID": 41,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "UMD / Standalone",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Changing Quasar Language Pack",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of available languages can be found on GitHub. If your desired language pack is not available yet, you can help by providing a PR. We welcome any languages!",
    "anchor": "Changing-Quasar-Language-Pack",
    "url": "/start/umd"
  },
  {
    "objectID": 42,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "Vue CLI Plugin",
    "hierarchy_lvl2": "Vue CLI Quasar Plugin",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to embed Quasar into a Vue CLI app.",
    "anchor": "Introduction",
    "url": "/start/vue-cli-plugin"
  },
  {
    "objectID": 43,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "Vue CLI Plugin",
    "hierarchy_lvl2": "Vue CLI Quasar Plugin",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "So, before you begin on this path of development with Quasar, we'd like you to understand the following. To guarantee you the best developer experience with Quasar, we highly recommend using Quasar's CLI and building your project with it, because you won't miss any feature that Vue CLI has. You'll get the full range of features offered by Quasar, like full cross-platform build support (but this is just the tip of the iceberg) and you can still do practically everything you'd like to do with Vue too, i.e. use Vue plugins via Quasar's Boot Files.  To work with Quasar via its Vue CLI plugin, you will need to make sure you have @vue/cli installed globally. To make sure you have the right version, use this command: Should you have Vue CLI 2.x.x. installed, you'll need to uninstall it with: Install Vue CLI (v4.5.11+) as follows: If you don't yet have a project created with @vue/cli, then do so with the command below. Make sure that you checkmark on Babel from the Vue CLI feature list prompt that will appear on screen.",
    "anchor": "Introduction",
    "url": "/start/vue-cli-plugin"
  },
  {
    "objectID": 44,
    "hierarchy_lvl0": "Getting Started",
    "hierarchy_lvl1": "Vue CLI Plugin",
    "hierarchy_lvl2": "Add Vue CLI Quasar Plugin",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Cross-platform support with Vue CLI is handled by community plugins. These are not tightly integrated with Quasar as with Quasar CLI and may have issues.  The CLI will ask you if you want the plugin to replace some existing files. It is recommended that you do this, if you wish to have an example, so you can quickly develop your app. Your Vue config (in package.json or vue.config.js file, depending on what you chose when you created your vue app) will also contain a quasar object with some basic Quasar configuration.",
    "anchor": "Add-Vue-CLI-Quasar-Plugin",
    "url": "/start/vue-cli-plugin"
  },
  {
    "objectID": 45,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quick tutorial about Vue principles and how to use it with Quasar.",
    "anchor": "Introduction",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 46,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "After reading the Vue documentation, let's clear up some of the most frequently asked questions, like \"How can I use Quasar components, Vue properties, methods and events\".",
    "anchor": "Introduction",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 47,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Vue Single File Components (SFC)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll be building your Quasar app using *.vue files which contain multiple sections: template (HTML), script (Javascript) and style (CSS/SASS/SCSS/Stylus/Less) all in the same file.",
    "anchor": "Vue-Single-File-Components-(SFC)",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 48,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Vue Single File Components (SFC)",
    "hierarchy_lvl3": "CSS preprocessors",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can specify you want your chosen preprocessor to handle the CSS code that you're writing:",
    "anchor": "CSS-preprocessors",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 49,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Using Quasar Directives",
    "hierarchy_lvl3": "CSS preprocessors",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar comes with a few custom Vue Directives. These directives can be applied on almost any DOM element or Component. Example of a Quasar directive: Notice how Ripple is used in the HTML template as v-ripple. Vue directives are prefixed with v-.",
    "anchor": "Using-Quasar-Directives",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 50,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Using Quasar Components",
    "hierarchy_lvl3": "CSS preprocessors",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Let's take the following example with a QBtn and QIcon and then we'll see how to embed these components in our app: Notice how QBtn is used in the Vue HTML template as <q-btn>. If we'd import QElementResizeObserver, then we'd use it in template as <q-element-resize-observer>.",
    "anchor": "Using-Quasar-Components",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 51,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Using Quasar Plugins",
    "hierarchy_lvl3": "CSS preprocessors",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Before using them in your app, you need to add a reference to them in /quasar.conf.js (as shown below).  Let's take Notify as an example and see how we can then use it. In a Vue file, you'd write something like this (Composition API): Notice that in the template area we're using $q.<plugin-name>. An equivalent script section in Options API: Now let's see an example of Notify being used outside of a Vue file:",
    "anchor": "Using-Quasar-Plugins",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 52,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Using Quasar Plugins",
    "hierarchy_lvl3": "Self-Closing Tags",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do NOT use self-closing tag form when you are using Quasar UMD version. Your browser is interpreting the HTML before Vue parses your DOM elements, so your HTML syntax must be correct. Unknown tags (like Vue components) cannot be self-closing because your browser will interpret those as if you are opening a tag but never closing it.  Some Quasar components do not need you to include HTML content inside of them. In this case, you can use them as self-closing tags. One example with QIcon below: Self-closing means the above template is the equivalent to: Both forms are valid and can be used, except for UMD where you must explicitly close the tags. It works the same with regular DOM elements: Some eslint-plugin-vue linting rules actually enforce using the self-closing syntax.",
    "anchor": "Self-Closing-Tags",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 53,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Properties",
    "hierarchy_lvl3": "Self-Closing Tags",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-Vue-Properties",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 54,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Properties",
    "hierarchy_lvl3": "Boolean Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In Quasar, all Boolean properties have false as the default value. As a result, you don't have to explictly assign them the false value.  If you are trying to control that property and change it dynamically at runtime, then bind it to a variable in your scope: If, on the other hand, you know this Boolean value is not going to change, you can use the shorthand version of the variable like a component attribute and just specify it. In other words, if you don't bind the variable to a variable in the component's scope as it will always be true:",
    "anchor": "Boolean-Property",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 55,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Properties",
    "hierarchy_lvl3": "String Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "String-Property",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 56,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Properties",
    "hierarchy_lvl3": "Number Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Number-Property",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 57,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Properties",
    "hierarchy_lvl3": "Object Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Object-Property",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 58,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Properties",
    "hierarchy_lvl3": "Array Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Array-Property",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 59,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Methods",
    "hierarchy_lvl3": "Array Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for you to access these methods, you will need to set a Vue reference on the component first. Here's an example with Composition API: And here is the same example, but with Options API:",
    "anchor": "Handling-Vue-Methods",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 60,
    "hierarchy_lvl0": "How to use Vue",
    "hierarchy_lvl1": "How To Use Vue",
    "hierarchy_lvl2": "Handling Vue Events",
    "hierarchy_lvl3": "Array Property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example of \"Vue Events\": In order for you to catch these events, when they are triggered, you will need to add listeners for them on the component itself in the HTML template. Here's an example:",
    "anchor": "Handling-Vue-Events",
    "url": "/start/how-to-use-vue"
  },
  {
    "objectID": 61,
    "hierarchy_lvl0": "Playground",
    "hierarchy_lvl1": "Quasar Playground",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Play with Quasar on a jsFiddle, Codepen or Codesandbox templates.",
    "anchor": "Introduction",
    "url": "/start/playground"
  },
  {
    "objectID": 62,
    "hierarchy_lvl0": "Playground",
    "hierarchy_lvl1": "Quasar Playground",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Make sure to read about it before diving in. When you use jsFiddle/Codepen you can skip the Installation section.",
    "anchor": "Introduction",
    "url": "/start/playground"
  },
  {
    "objectID": 63,
    "hierarchy_lvl0": "Playground",
    "hierarchy_lvl1": "Quasar Playground",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Codesandbox Template",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For more intricate Quasar code examples, like when using boot files, Vuex, etc, fork our Codesandbox:",
    "anchor": "Codesandbox-Template",
    "url": "/start/playground"
  },
  {
    "objectID": 64,
    "hierarchy_lvl0": "Release notes",
    "hierarchy_lvl1": "Release Notes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The changelog for Quasar core packages.",
    "anchor": "Introduction",
    "url": "/start/release-notes"
  },
  {
    "objectID": 65,
    "hierarchy_lvl0": "Release notes",
    "hierarchy_lvl1": "Release Notes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For all other packages, visit the Quasar Organization GitHub page and look for the repository that you are interested in then click on its \"Releases\".",
    "anchor": "Introduction",
    "url": "/start/release-notes"
  },
  {
    "objectID": 66,
    "hierarchy_lvl0": "Roadmap",
    "hierarchy_lvl1": "Quasar Roadmap",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What's next for Quasar Framework.",
    "anchor": "Introduction",
    "url": "/start/roadmap"
  },
  {
    "objectID": 67,
    "hierarchy_lvl0": "Roadmap",
    "hierarchy_lvl1": "Quasar Roadmap",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You, the community, are Quasar. We listen to your opinions and your needs. Which is why we encourage you to directly contact us on Discord or submit Feature Requests. We carefully ponder on all the ideas and we decide along with the community what are the next steps to be taken. Apart from the constant new components/directives/Quasar plugins that we have on our todo list, the next really big things on our plate currently are: Quasar v2 - Beta released! Working towards releasing the last piece of the puzzle: Quasar App CLI support for SSR - https://github.com/quasarframework/quasar/issues/7836 Highly improve Typescript support (dedicated team members working on it) Upgrade Quasar App CLI to Webpack 5 (in investigation) - https://github.com/quasarframework/quasar/issues/8102",
    "anchor": "Introduction",
    "url": "/start/roadmap"
  },
  {
    "objectID": 68,
    "hierarchy_lvl0": "Roadmap",
    "hierarchy_lvl1": "Quasar Roadmap",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Important!",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want to speed up the development of Quasar please consider donating to the project. With proper funding, it allows more of the team to work on the project in a much more dedicated manner. Donations - https://donate.quasar.dev If you're in a company and using Quasar for commercial projects, explain to your management the importance of monthly donations (eg. $200+) for open source projects: you're the one using it every day and this makes you the best suited person to convince them. Be creative! :) Quasar is saving your company tens of thousands of development hours (quite literally), which in turn is a pretty high money savings. Consider giving back a part of those savings to refuel the project itself ;)",
    "anchor": "Important!",
    "url": "/start/roadmap"
  },
  {
    "objectID": 69,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to upgrade Quasar from older versions to the latest one.",
    "anchor": "Introduction",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 70,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Composition and Options API You will notice that all of our documentation examples are using Vue 3's Composition API. This does NOT mean that you can't use the legacy Options API. On the contrary, maintaining Options API will actually help you on your upgrade path and make it a lot easier for you. After upgrading is done we do recommend switching to the Composition API, but by no means you are required to do so.",
    "anchor": "Introduction",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 71,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Older v2 to latest v2",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note for code editor terminals If you're using a code editor terminal instead of an external one and you run quasar upgrade and get the error Command not found or @quasar/cli version appears to be undefined, you will need to go to the settings of your code editor terminal and untick the option (or its equivalent) Add 'node_modules/.bin' from the project root to %PATH%, then restart your code editor.",
    "anchor": "Older-v2-to-latest-v2",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 72,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Older v2 to latest v2",
    "hierarchy_lvl3": "With Vue CLI",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Optionally, you may also want to make sure that you have the latest vue-cli-plugin-quasar@next package. It's highly recommended to keep @quasar/extras package up to date too:",
    "anchor": "With-Vue-CLI",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 73,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "With Vue CLI",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This guide refers to Quasar CLI & UMD projects, but information from here can be used for Vue CLI too. For developers already using Vue CLI on your projects you can check out how to install the vue-cli-plugin-quasar package that works with Quasar v2. You will also need to make a few changes to your main.js (and also upgrade your Vue CLI project to support Vue 3) too (best way currently is to generate a new Vue CLI project for Vue 3 and then following the install steps for the vue-cli-plugin-quasar and check out the changes incurred to that /src folder, then apply the same principle to your current Vue CLI project).",
    "anchor": "Migrate-to-v2-from-v1",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 74,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Intro",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We've put in a lot of work, so the transition from Quasar v1 to v2 is as painless as possible. Don't be afraid by the length of this page, as it doesn't reflect the effort that you need to put into upgrading your app to Quasar v2 (we just tried to make it as complete as possible). The API of Quasar components, directives and plugins has minor changes, but we kept the breaking changes to a bare minimum. We've also added some new cool features to some components. Quasar UI v2 is based on Vue 3, as opposed to the previous version which was based on Vue 2. This means that your app code (Vue components, directives, etc) should be Vue 3 compliant too, not just the Quasar UI source-code. If you are using additional libraries in your app, please make sure that you are using their Vue 3 versions. Quasar UI v2 is not just a port to Vue 3 and Composition API. There are lots of significant performance enhancements in Quasar's algorithms too! You'll love it!  IMPORTANT! * No IE11 support - Vue 3 does not support IE11 either. If IE11 support is mandatory for your project(s), then continue using Quasar UI v1. * Quasar Stylus variables are no longer available (only Sass/SCSS). This does NOT mean that you can't use Stylus anymore though. * SSR build mode is NOT yet supported. If your project relies on SSR, you might want to hold off on upgrading for now. * Not all of our official App Extensions are yet compatible with Quasar UI v2. We are working towards releasing new compatible versions for them.  Before you start with this journey of upgrading your project from v1 to v2, you should know a few additional things: 1) Read the documentation before asking questions on Discord server or forums. 2) Prepare a CodePen so staff can help you, if you think you've found an issue. 3) Dig into the Quasar source code (it'll help you understand the framework as well as teach you best practices for programming with Vue). 4) Don't use framework components as mixins unless absolutely necessary (wrap them if you need to). 5) Don't target inner component stuff with CSS selectors unless absolutely necessary. 6) We recommend yarn whenever possible because of its speed and efficient use. However, when using globals, we still recommend using npm, especially if you use nvm (Node Version Manager). 7) Use git for repository management and make regular commits, it is like taking notes on the process and lets you revert to a previous state in case you get stuck. 8) Use Quasar boot files for any pre-mounting app routines. 9) Finally, become a backer/sponsor and get access to the special Discord support chat room for priority support. This also helps the project survive. If you get stuck, check out the forums or visit our Discord server for help which comes not just from staff, but from the community as well.  Info It should be noted that we have tried our hardest to make sure everything in the Upgrade documentation is correct. However, because this has been a manual process, there are likely errors. If you find any, don't be afraid to make a PR and propose a change to make corrections.",
    "anchor": "Intro",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 75,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Initial Steps",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are two paths you can follow. They are described below. Choose the path that fits your needs best. We do, however, recommend the first option.",
    "anchor": "Initial-Steps",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 76,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Initial Steps",
    "hierarchy_lvl4": "Option 1: Convert a project",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Important! This guide assumes that you are currently using a @quasar/app v2 project.  Before starting, it is highly suggested to make a copy of your current working project or create a new branch with git. 1) Stylus related: Are you using Stylus and Quasar Stylus variables? Then before anything, convert all those files to Sass/SCSS (including src/css/app.styl -> src/css/app.sass or app.scss). If you still want to use Stylus in your project (without Quasar Stylus variables), then you'll also need to install the stylus related packages (which are no longer supplied by \"@quasar/app\" out of the box): bash # only if you still want to use Stylus (but without Quasar Stylus variables) $ yarn add --dev stylus stylus-loader 2) Remove folders .quasar, node_modules and package-lock.json or yarn.lock file. This generally isn't needed, but in some cases it will avoid trouble with yarn/npm upgrading the packages for the purpose of this guide. 3) Install: quasar v2 and @quasar/app v3 beta packages from the npm tag named \"next\": bash $ yarn add quasar@next $ yarn add --dev @quasar/app@next 4) If you are using ESLint, then edit /.eslintrc.js: ```js // old way extends: { 'plugin:vue/essential' // or equivalent } // NEW way extends: { 'plugin:vue/vue3-essential' // or equivalent } ``` Also upgrade ESLint deps. Example:",
    "anchor": "Option-1%3A-Convert-a-project",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 77,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "App.vue",
    "hierarchy_lvl4": "Option 1: Convert a project",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll need to edit src/App.vue and remove the wrapper <div id=\"q-app\">. You don't (and should NOT) need it anymore.",
    "anchor": "App.vue",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 78,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Vue 3",
    "hierarchy_lvl4": "Option 1: Convert a project",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For Quasar CLI projects, you don't need to manually install/upgrade the vue package as \"@quasar/app\" v3 is already supplying the correct version of Vue for you.  Since you will also switch to Vue 3, it's best that you also take a look at its migration guide after finishing reading this migration guide. If you're using .vue files, you'll most likely have a fairly easy transition because 1) vue-loader (supplied by @quasar/app) is the one parsing the SFC syntax and instructing Vue 3 on what to do and 2) you can still use the Options API (although we recommend that you convert to the newer and better Composition API). We suggest that you first convert your project to Quasar v2 while maintaining Options API (because your components are already in Options API form and you probably want to ensure everything is working first). After this transition, you can convert all your Vue components to Composition API, but in no way is this a requirement. Along with Vue3, there is a new major version of Vue Router v4, which has its own breaking changes you should be aware of. There's also the new Vuex v4 too.",
    "anchor": "Vue-3",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 79,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Vue 3",
    "hierarchy_lvl4": "Vue 3 breaking changes examples",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "One of the most important breaking changes when dealing with Vue 3 is how v-model works. It is now an alias to the model-value + @update:modelValue combo, instead of value + @input. This has impact on all Quasar components using v-model. If you're writing your components in .vue files, then you don't need to worry about it as vue-loader correctly translates it for you. Also, if you emit custom events from your Vue components, you will need to explicitly specify them like below:",
    "anchor": "Vue-3-breaking-changes-examples",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 80,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Vue.js Devtools",
    "hierarchy_lvl4": "Vue 3 breaking changes examples",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For Quasar CLI projects, you don't need to manually install/upgrade the vue-router package as \"@quasar/app\" v3 is already supplying the correct version of Vue Router for you.  This is a Vue 3 ecosystem upstream breaking change. Update src/router files to match Vue Router v4's API. Vue Router v4 comes with its own breaking changes. Especially note below how we are dealing with the 404 error. If you use TypeScript, you must replace the RouteConfig interface occurrences with RouteRecordRaw.",
    "anchor": "Vue.js-Devtools",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 81,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Vuex v4",
    "hierarchy_lvl4": "Vue 3 breaking changes examples",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For Quasar CLI projects, you don't need to manually install/upgrade the vuex package as \"@quasar/app\" v3 is already supplying the correct version of Vuex for you.  This is a Vue 3 ecosystem upstream breaking change. You'll need to update src/store files to match Vuex v4's API. Notice the \"createStore\" import from vuex and its usage in an example below. For informative purposes: Vuex migration to 4.0 from 3.x",
    "anchor": "Vuex-v4",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 82,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Vue-i18n v9",
    "hierarchy_lvl4": "Vue 3 breaking changes examples",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This is a Vue 3 ecosystem upstream breaking change. Update src/boot/i18n.js file to match Vue-i18n v9's API. Vue-i18n comes with its own breaking changes. Since this package isn't provided by @quasar/app, you must update the dependency in your project via yarn add vue-i18n@rc If you use TypeScript, remove the existing augmentation of 'vue/types/vue' as it has been integrated into the upstream package. If you use TypeScript and ESLint, due to an upstream types generation problem, useI18n composable will generate a \"@typescript-eslint/unbound-method\" linting warning when used to destructure t, te and similar methods. Until the problem is solved upstream, we recommended to stick to the legacy API when possible or disable that rule every time you use useI18n.",
    "anchor": "Vue-i18n-v9",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 83,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "@vue/composition-api",
    "hierarchy_lvl4": "Vue 3 breaking changes examples",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you've been using Composition API package for Vue 2, you'll need to change all imports to point towards the Vue package. If you were using the deprecated context.root object, you must refactor your code to avoid using it, as it's not available anymore. Delete src/boot/composition-api boot file and the corresponding entry from quasar.conf.js. Then uninstall the @vue/composition-api package: If you use TypeScript, prepare to reload VSCode many times, as all upgrades will cause typings cache problems.",
    "anchor": "%40vue%2Fcomposition-api",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 84,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "Vue 3 breaking changes examples",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The v-model is now an alias to the model-value + @update:modelValue combo, instead of value + @input. This has impact on all Quasar components using v-model. If you're writing your components in .vue files then you don't need to worry about it as vue-loader correctly translates it for you. Suggestion: you may want to do a search and replace for :value and @input. Please be careful on replacing the :value as some components (QLinearProgress, QCircularProgress) are not tied to v-model and still use value as a property.",
    "anchor": "Quasar-components",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 85,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "Vue 3 and scoped slots",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All slots are now acting in the same manner as the scoped slots in Vue 2. If you're using Options API, then you can do a search and replace for this.$scopedSlots (and replace it with this.$slots).",
    "anchor": "Vue-3-and-scoped-slots",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 86,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QDrawer/QDialog/QMenu/QTooltip",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Use \"class\" and \"style\" attributes instead of \"content-class\" / \"content-style\" props for the above mentioned Quasar components.",
    "anchor": "QDrawer%2FQDialog%2FQMenu%2FQTooltip",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 87,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QBreadcrumbsEl",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Removed \"append\" prop because Vue Router v4 has also dropped it. Added \"tag\" and \"ripple\" properties.",
    "anchor": "QBreadcrumbsEl",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 88,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QChatMessage",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now by default, the \"label\", \"name\", \"text\" and \"stamp\" are protected from XSS attacks. This means that all of the *-sanitize props have been dropped, as this behavior has now become the standard in Quasar. Should you wish to display HTML as content for these props, you now need to explicitly specify them through new Boolean props (*-html).",
    "anchor": "QChatMessage",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 89,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QDate",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When @update:modelValue event (equivalent of the old @input) is triggered, the contents of the first parameter no longer contain the (deprecated) changed prop.",
    "anchor": "QDate",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 90,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QExpansionItem",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Removed the \"append\" property because Vue Router v4 has also dropped it.",
    "anchor": "QExpansionItem",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 91,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "(New) Connecting to QForm",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Should you wish to create your own Vue components that need to connect to a parent QForm (for validation purposes), we've made it easier for you:",
    "anchor": "(New)-Connecting-to-QForm",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 92,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QImg",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This component has been redesigned from the ground up. It now makes use of a more modern API. The immediate effects are that it uses less RAM memory and runtime is much faster. Added properties: \"loading\", \"crossorigin\", \"fit\", \"no-spinner\", \"no-native-menu\", \"no-transition\". Removed properties: \"transition\", \"basic\" (now equivalent to \"no-spinner\" + \"no-transition\") Changed property \"no-default-spinner\" to \"no-spinner\". For the detailed changes, please view the API Card on QImg page.",
    "anchor": "QImg",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 93,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QPopupEdit",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Some performance improvements have been made on this component and as a result you will need to now use the default slot. The NEW way is below. Notice v-slot=\"scope\" is applied directly on <q-popup-edit> and using scope.value instead of myModel for the inner <q-input> component: For more detailed information on the usage, please read QPopupEdit's page.",
    "anchor": "QPopupEdit",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 94,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QLayout",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The @scroll event parameter now has a slightly different content:",
    "anchor": "QLayout",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 95,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QRouteTab",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Added \"ripple\" property.",
    "anchor": "QRouteTab",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 96,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QScrollArea",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QScrollArea has been redesigned so that it now supports both vertical and horizontal scrolling simultaneously. Added props: \"vertical-bar-style\" and \"horizontal-bar-style\" (that come on top of \"bar-style\" which is applied to both vertical and horizontal scrolling bars) Added props: \"vertical-thumb-style\" and \"horizontal-thumb-style\" (that come on top of \"thumb-style\" which is applied to both vertical and horizontal scrolling bar thumbs) Removed prop: \"horizontal\" (now obsolete as QScrollArea support both vertical and horizontal scrolling simultaneously) The \"getScrollPosition\" method now returns an Object of the form { top, left } (example: { top: 5, left: 0 }) The \"setScrollPosition\" and \"setScrollPercentage\" methods now require a new first param (named \"axis\" with values either \"horizontal\" or \"vertical\"): (axis, offset[, duration])",
    "anchor": "QScrollArea",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 97,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QScrollObserver",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Replaced property \"horizontal\" with \"axis\" (String: \"vertical\", \"horizontal\", \"both\"; default value: \"vertical\"). The @scroll event parameter now has a slightly different content:",
    "anchor": "QScrollObserver",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 98,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QSelect",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The \"itemEvents\" prop has been dropped from the \"option\" slot. That information is now contained within the \"itemProps\". This change is a logical result Vue 3's flattening of the rendering function's second parameter (\"on\", \"props\" etc. merged together into a single Object). New method: \"blur()\"",
    "anchor": "QSelect",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 99,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QTable",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Renamed the \"data\" property to \"rows\" (to solve TS conflict issue with \"data\" incorrectly inferred as the \"data()\" method of a Vue component)",
    "anchor": "QTable",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 100,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QTable/QTree",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Due to the new v-model feature of Vue 3, which replaces the \".sync\" modifier, the following properties need to be used differently:",
    "anchor": "QTable%2FQTree",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 101,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QTooltip/QMenu",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Added \"transition-duration\" property.",
    "anchor": "QTooltip%2FQMenu",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 102,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar components",
    "hierarchy_lvl4": "QUploader",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QUploaderBase component has been removed in favor of the \"useUploader\" and \"useUploaderXhr\" composables.",
    "anchor": "QUploader",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 103,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar directives",
    "hierarchy_lvl4": "QUploader",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The only breaking change in this section is that we've removed the GoBack directive. Use the router reference instead to push/replace/go(-1).",
    "anchor": "Quasar-directives",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 104,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar plugins",
    "hierarchy_lvl4": "QUploader",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Added \"boxClass\" property By default, the message is protected from XSS attacks. Should you wish to display HTML content with the \"message\" prop, you should also specify \"html: true\". This behavior is completely opposite to that of Quasar v1, where you had the prop \"sanitize\" (not available anymore; enabled now by default) to NOT display HTML.",
    "anchor": "Quasar-plugins",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 105,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar plugins",
    "hierarchy_lvl4": "Dialog plugin",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are using the Dialog plugin with a custom component, then you must now supply the component properties under \"componentProps\": The parent and root props have been removed. Due to the Vue 3 architecture, we can no longer use a \"parent\" component for the provide/inject functionality. But you'll still be able to use Vue Router/Vuex/etc. inside of your custom component. If invoking the Dialog plugin with a custom component then you need to add emits: [ 'ok', 'cancel' ] to your component as Vue 3 now requires an explicit list of events that the component might emit. You can also transform the component to Composition API. For detailed information please see Invoking custom component. js // the invoked component code export default { // ... emits: [ 'ok', 'cancel' ], // ... }",
    "anchor": "Dialog-plugin",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 106,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar plugins",
    "hierarchy_lvl4": "Meta plugin",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The new way (Composition API or Options API): For detailed information please see Meta Plugin.",
    "anchor": "Meta-plugin",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 107,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar utils",
    "hierarchy_lvl4": "Meta plugin",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar-utils",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 108,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar utils",
    "hierarchy_lvl4": "scroll utils",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "scroll-utils",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 109,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar utils",
    "hierarchy_lvl4": "color utils",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Removed \"getBrand\" and \"setBrand\" from color utils. They are replaced by \"getCssVar\" and \"setCssVar\":",
    "anchor": "color-utils",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 110,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar language packs",
    "hierarchy_lvl4": "color utils",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Full list of changes: | Old name | New name | | --- | --- | | en-us | en-US | | en-gb | en-GB | | az-latn | az-Latn | | fa-ir | fa-IR | | ko-kr | ko-KR | | kur-CKB | kur-CKB | | nb-no | nb-NO | | pt-br | pt-BR | | zh-hans | zh-CN | | zh-hant | zh-TW | If you have configured a default Quasar language pack in your quasar.conf.js, then you need to edit it: You'll also need to edit all your dynamic imports from quasar/lang/ to match the new syntax.",
    "anchor": "Quasar-language-packs",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 111,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar CSS",
    "hierarchy_lvl4": "color utils",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The color CSS variable names (all the brand related ones) have changed:",
    "anchor": "Quasar-CSS",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 112,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar UMD",
    "hierarchy_lvl4": "color utils",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For an in-depth look at the necessary UMD scripts and tags, please use our generator tool.",
    "anchor": "Quasar-UMD",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 113,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar App CLI",
    "hierarchy_lvl4": "color utils",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This section refers to \"@quasar/app\" v3 package which supports Vue 3 and Quasar UI v2. Dropped support for src/css/quasar.variables.styl. Also, if you still want to use Stylus as preprocessor (but without the Quasar Stylus variables) then you need to manually yarn/npm install stylus and stylus-loader as dev dependencies into your project (\"@quasar/app\" does not supply them anymore). New quasar.conf.js > build > vueLoaderOptions prop Remove quasar.conf.js > framework > importStrategy. Auto import works so great that is now used by default and as the only option. The url-loader configuration has been enhanced so it now also supports \"ico\" files out of the box Removed support for quasar.conf.js > framework > importStrategy: 'all' since the auto import feature has become so good anyways (so it's now enabled by default).. If you have boot files, where you access and change the $q Object through Vue.prototype.$q, then you need to adapt this: Nothing changed in regards to how App Extensions work. Please note that not all of our App Extensions are yet compatible with Quasar UI v2. We are working towards releasing new compatible versions of them.",
    "anchor": "Quasar-App-CLI",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 114,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar App CLI",
    "hierarchy_lvl4": "TypeScript",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Update src/shims-vue.d.ts as such: If you use ESLint, update the property into quasar.conf.js: This is due to upstream breaking changes of fork-ts-checker-webpack-plugin.",
    "anchor": "TypeScript",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 115,
    "hierarchy_lvl0": "Upgrade guide",
    "hierarchy_lvl1": "Upgrade Guide",
    "hierarchy_lvl2": "Migrate to v2 from v1",
    "hierarchy_lvl3": "Quasar App CLI Electron mode",
    "hierarchy_lvl4": "TypeScript",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you have a project using the Quasar Electron mode, then it's essential to read its own Electron mode upgrade guide.  Out of the box support for TS now available.",
    "anchor": "Quasar-App-CLI-Electron-mode",
    "url": "/start/upgrade-guide"
  },
  {
    "objectID": 116,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure VSCode for best usage with Quasar.",
    "anchor": "Introduction",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 117,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Without some customizations the default formatting in VS Code will generate a seemingly endless number of errors when quasar dev or quasar build commands are run because they include a call to es-lint with the ruleset specified when you create a project. The configuration in this guide is for the standard ruleset.",
    "anchor": "Introduction",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 118,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Install VS Code Extensions for Standard",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "ESLint Vetur",
    "anchor": "Install-VS-Code-Extensions-for-Standard",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 119,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Update VS Code settings file for Standard",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To edit the settings, use the command Open Settings JSON in the Command Palette in the View menu (ctrl+shift+p).",
    "anchor": "Update-VS-Code-settings-file-for-Standard",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 120,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Test Standard on a new Quasar project",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can now edit files without violating the standard es-lint rules!",
    "anchor": "Test-Standard-on-a-new-Quasar-project",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 121,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": "Prettier ES-Lint rules",
    "hierarchy_lvl3": "Test Standard on a new Quasar project",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "ESLint Prettier Vetur",
    "anchor": "Prettier-ES-Lint-rules",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 122,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": "Prettier ES-Lint rules",
    "hierarchy_lvl3": "Update VS Code settings file for Prettier",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To edit the settings use the command Open Settings JSON in the Command Palette in the View menu (ctrl+shift+p).",
    "anchor": "Update-VS-Code-settings-file-for-Prettier",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 123,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": "Prettier ES-Lint rules",
    "hierarchy_lvl3": "Test Prettier on a new Quasar project",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can now edit files without violating the standard es-lint rules!",
    "anchor": "Test-Prettier-on-a-new-Quasar-project",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 124,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": "Recommended additional VS Code extensions and settings updates",
    "hierarchy_lvl3": "Test Prettier on a new Quasar project",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Auto Rename Tag Auto Close Tag Bracket Pair Colorizer ESLint Format in context menus GitLens Import Cost Sass Sass Lint npm npm Intellisense Prettier Sorting HTML and Jade attributes TODO Highlight Vetur Vue Peek VS Code Icons To edit the settings use the command Open Settings JSON in the Command Palette in the View menu (ctrl+shift+p).",
    "anchor": "Recommended-additional-VS-Code-extensions-and-settings-updates",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 125,
    "hierarchy_lvl0": "VS Code Configuration",
    "hierarchy_lvl1": "Configure VS Code",
    "hierarchy_lvl2": "Debugging a Quasar project in VS Code",
    "hierarchy_lvl3": "Test Prettier on a new Quasar project",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "First, head to Debugger for Chrome and read it thoroughly. Then, since Quasar is based on Vue, you will also want to refer to Vue Cookbook for VSCode debugging for setting up debugging Vue apps. The best approach is to open that in a browser beside this page so you can review these instructions as you are reading those instructions. And apply the changes to your project as you go. The first step of the Vue cookbook says it is to enable source maps. Quasar automatically enables source maps for development mode. Here is a good article that describes the different values for the webpack devtool setting (the one that turns on or off source maps.) Quasar uses cheap-module-eval-source-map by default. While cheap-module-eval-source-map may build faster, it makes debugging harder and it makes debugging in VSCode near impossible. The recommended value of devtool in this case is source-map. This makes debugging in VSCode work properly due to your full vue source files being available in the built in chrome debugger thus it will be easier to find your original source and easier to correctly locate the line that you want to set the break point to. If you want to enable this, you would add this line to your quasar.config.js file: Then you need to tell VSCode to add a configuration to the debugger. The easiest way to do that is to click on the bug icon on the action bar (for ltr languages, that is the bar on the far left). Once you click on that bug icon, the file tree area will switch to the debug and run area. Click on the gear icon in the title bar of that window and it will bring up a file called launch.json. This is where you put the different configurations of launching the application to be debugged. Here are the settings for launching a Quasar app in Chrome. For the Firefox version, look at the Vue cookbook mentioned above. Now save the file, then select that configuration in the drop down on the title bar of the debug and run pane. Before you can launch the debugger, the app must be running. From the command line, launch dev mode of your app with quasar dev. Then click the green \"go\" button in the debug and run pane to launch the debugging session and attach to your running app. You can now set break points and control step over/in/out etc, all from VSCode. You can also launch the built in Chrome debugger and it will stay in sync. This might be useful if you also have the Vue devtools installed (highly recommended).  If you just want to use the Chrome or Firefox debuggers but you find it hard to locate the right source file in the browser source tab then you can use the debugger statement in your code to force the debugger to stop on that line and bring up the proper source code.",
    "anchor": "Debugging-a-Quasar-project-in-VS-Code",
    "url": "/start/vs-code-configuration"
  },
  {
    "objectID": 126,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to contribute to Quasar Framework.",
    "anchor": "Introduction",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 127,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "But, before we begin, a first important note. Everyone interacting in Quasar is expected to follow the Quasar code of conduct. Now that we've got that covered, let's go! After reading this guide, you will know: How to use GitHub to report issues. How to clone master and run the test suite. How to help resolve existing issues. How to contribute to the Quasar documentation. How to create a Quasar App Extension. How to contribute to the Quasar code. Quasar is not \"someone else's framework\". Many people have contributed to Quasar ranging from a single character to massive architectural changes or significant documentation - all with the goal of making Quasar better for everyone. Even if you don't feel up to writing code or documentation yet, there are a variety of other ways that you can contribute, from reporting issues to testing patches.",
    "anchor": "Introduction",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 128,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Help with Support",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "One of the easiest ways to contribute is to answer questions in the different Q&A systems we have. Be a supportive and positive member of the Quasar community by answering questions you know answers to, or even by adding your best guess. Being a part of such discussions can also be a good learning experience. It's a win-win! Here are our discussion/Q&A venues: Forum: The best place to ask questions and get answers about Quasar and its ecosystem. Chat: A place for Quasar devs to meet and chat in real time.",
    "anchor": "Help-with-Support",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 129,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Share (and Build) Your Experience",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know: Develop learning materials. It’s often said that the best way to learn is to teach. If there’s something interesting you’re doing with Quasar, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media. Share your tech stack. Show others which technologies are well tested and can be integrated with Quasar. Promote your project and fill out your favorite Quasar-based stack. Make sure to mention @Quasarframework and all other relevant technologies. Watch a repo you care about. This will send you notifications whenever there’s activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It’s a fantastic way to build expertise so that you’re eventually able to help address issues and pull requests.",
    "anchor": "Share-(and-Build)-Your-Experience",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 130,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Reporting an Issue",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "GitHub: If you have a bug to report or feature to request, that’s what the GitHub issues are for. Make sure that you specify that your bug is related to Quasar v2.  Reporting a vulnerability Please do not report security vulnerabilities with public GitHub issue reports. Follow the Report a vulnerability steps for security issues.  If you've found a problem in Quasar which is not a security risk, do a search on GitHub under Issues to check if it is already answered or even fixed in the development branch (vue3-work). The issue list of the main repo is exclusively for bug reports and feature requests. Non-conforming issues will be closed immediately.For simple beginner questions, you can get quick answers from the Quasar Discord chat.For more complicated questions, you can use the official forum. Make sure to provide enough information when asking your questions - this makes it easier for others to help you! Check if the issue is reproducible with the latest stable version of Quasar. If you are using a pre-release, please indicate the specific version you are using. It is required that you clearly describe the steps necessary to reproduce the issue you are running into. Although we would love to help our users as much as possible, diagnosing issues without clear reproduction steps is extremely time-consuming and simply not sustainable. Use only the minimum amount of code necessary to reproduce the unexpected behavior. A good bug report should isolate specific methods that exhibit unexpected behavior and precisely define how expectations were violated. What did you expect the method or methods to do, and how did the observed behavior differ? The more precisely you isolate the issue, the faster we can investigate. Issues with no clear reproduction steps will not be triaged. If an issue labeled \"need repro\" receives no further input from the issue author for more than 5 days, it will be closed. If your issue is resolved but still open, don’t hesitate to close it. In case you found a solution by yourself, it could be helpful to explain how you fixed it. Most importantly, we beg your patience: the team must balance your request against many other responsibilities — fixing other bugs, answering other questions, new features, new documentation, etc. The issue list is not paid support and we cannot make guarantees about how fast your issue can be resolved, although we do our very best.",
    "anchor": "Reporting-an-Issue",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 131,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Helping to Resolve Existing Issues",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "As a next step beyond reporting issues, you can help the Quasar Team resolve existing ones by providing feedback about them. If you are new to Quasar development, that might be a great way to walk your first steps, you'll get familiar with the code base and the processes. If you check the issues list in GitHub Issues, you'll find lots of issues already requiring attention. What can you do for these? Quite a bit, actually:",
    "anchor": "Helping-to-Resolve-Existing-Issues",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 132,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Helping to Resolve Existing Issues",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Verifying Bug Reports",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For starters, it helps just to verify bug reports. Can you reproduce the reported issue on your own computer? If so, you can add a comment to the issue saying that you're seeing the same thing. If an issue is very vague, can you help narrow it down to something more specific? Maybe you can provide additional information to help reproduce a bug, or help by eliminating needless steps that aren't required to demonstrate the problem. Anything you can do to make bug reports more succinct or easier to reproduce helps folks trying to write code to fix those bugs - whether you end up writing the code yourself or not.",
    "anchor": "Verifying-Bug-Reports",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 133,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Helping to Resolve Existing Issues",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Testing Patches",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also help out by examining pull requests that have been submitted to Quasar via GitHub. In order to apply someone's changes, you need to first create a dedicated branch: bash $ git checkout -b testing_branch Then, you can use their remote branch to update your codebase. For example, let's say the GitHub user JohnSmith has forked and pushed to a topic branch \"orange\" located at https://github.com/JohnSmith/quasar. bash $ git remote add JohnSmith https://github.com/JohnSmith/quasar.git $ git pull JohnSmith orange After applying their branch, test it out! Here are some things to think about: Does the change actually work? Does it have the proper documentation coverage? Should documentation elsewhere be updated? Do you like the implementation? Can you think of a nicer or faster way to implement a part of their change? Once you're happy that the pull request contains a good change, comment on the GitHub issue indicating your approval. Your comment should indicate that you like the change and what you like about it. Something like:  Example pull request comment I like the way you've restructured the code in card.vue - much nicer. Documentation is updated too.  If your comment simply reads \"+1\", then odds are that other reviewers aren't going to take it too seriously. Show that you took the time to review the pull request.",
    "anchor": "Testing-Patches",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 134,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Testing Patches",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can help improve the Quasar documentation by making it more coherent, consistent, or readable, adding missing information, correcting factual errors, fixing typos, or bringing them up to date with the latest edge Quasar.  Typos or small changes can be fixed directly from the documentation Use a pencil icon in the top right corner of every documentation page. Edit the source file, preview the changes, add a description of your change and hit Propose a file change and on the next screen Create pull request.  For larger edits change the Quasar source files (located here on GitHub).",
    "anchor": "Contributing-to-the-Quasar-Documentation",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 135,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Testing Patches",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Over time we consolidated a set of rules which we follow and following them will speed up the merge process: - Capitalize titles, see How to Use Capitalize My Title. - Use the present tense. - Be concise, avoid text / code duplication. - Link to the external sources which are used as master information sources and are usually updated more frequently, like Mozilla MDN, Vue.js API rather than compiled tutorials which tend to be outdated soon. - Do the proofreading before opening a PR - Do not repeat texts from other sources, but keep only things which are relevant and shows in a context Quasar specific features - Use official names. For example use Firebase instead of firebase - Exclude from PR all drafts and unfinished pages",
    "anchor": "Documentation-Best-Practices",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 136,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Fork",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Navigate to the Quasar GitHub repository and press \"Fork\" in the upper right-hand corner.  Select vue3-work branch Make sure you have vue3-work branch selected and this is where all the work is done.",
    "anchor": "Fork",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 137,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Clone the forked repository",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Clone-the-forked-repository",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 138,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Install dependencies",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Install the required dependencies. bash $ cd quasar/docs $ yarn # or npm install",
    "anchor": "Install-dependencies",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 139,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Running documentation against your local repository",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The documentation runs against your local cloned repository.",
    "anchor": "Running-documentation-against-your-local-repository",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 140,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Edit and test your changes locally",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you're happy with the change on your computer, you need to commit the changes to Git: This should fire up your editor to write a commit message. When you have finished, save and close to continue.",
    "anchor": "Edit-and-test-your-changes-locally",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 141,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Update your local repository",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It's pretty likely that other changes to master have happened while you were working. Go get them. Add a remote Quasar repository as an upstream Check out your fork's local vue3-work branch. Merge the changes from upstream/vue3-work into your local vue3-work branch. This brings your fork's vue3-work branch into sync with the upstream repository, without losing your local changes. No conflicts? Tests still pass? Change still seems reasonable to you? Then move on and open a pull request to apply your changes to the dev branch in main Quasar repository.",
    "anchor": "Update-your-local-repository",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 142,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar Documentation",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Issue a pull request",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Navigate to your repository you just pushed to (e.g. https://github.com/your-user-name/quasar) and click on \"New Pull Request\" seen in the left top panel. Ensure the change sets you introduced are included. Fill in some details about your potential patch including a meaningful title. When finished, press Click on \"Create pull request\". The Quasar core team will be notified about your submission.",
    "anchor": "Issue-a-pull-request",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 143,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Write your Story",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Issue a pull request",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We're always looking for great write-ups on how you are using Quasar or the great experiences you've had with Quasar. If you write an article, we will publish it on our Medium publication channel and we'll also make sure your article gets the attention it deserves with our social media presence. If you are interested, please contact blog(at)quasar.dev. We'd love to hear from you!",
    "anchor": "Write-your-Story",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 144,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Create new Quasar App Extension",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Issue a pull request",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "An easy way to start to contribute to Quasar is to generalize the code you have created on your project and publish it as a Quasar App Extension. Follow this guide on how to create a new extension. When done, submit a PR on Quasar Awesome, share your achievement via Quasar Forum.",
    "anchor": "Create-new-Quasar-App-Extension",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 145,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar UI Source Code",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Issue a pull request",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "As with any project, there are rules to contributing. Ours are written here, please read them carefully. After that, read the Quasar code of conduct and you’ll be ready to contribute to Quasar’s core repositories. An article Look at the source code will help you to get familiar with a Quasar code base.",
    "anchor": "Contributing-to-the-Quasar-UI-Source-Code",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 146,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar UI Source Code",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Pull Request Guidelines",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The master branch is basically just a snapshot of the latest stable release. All development should be done in dedicated branches. Do not submit PRs against the master branch. Checkout a topic branch from the relevant branch, e.g. vue3-work, and merge back against that branch. DO NOT check in dist in the commits. It's OK to have multiple small commits as you work on the PR - we will let GitHub automatically squash it before merging. If adding new feature: Provide convincing reason to add this feature. Ideally you should open a suggestion issue first and have it greenlighted before working on it. If fixing a bug: If you are resolving a special issue, add (fix: #xxxx[,#xxx]) (#xxxx is the issue id) in your PR title for a better release log, e.g. fix: update entities encoding/decoding (fix #3899).Provide detailed description of the bug in the PR. Live demo preferred.",
    "anchor": "Pull-Request-Guidelines",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 147,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar UI Source Code",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Development Setup",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You will need Node.js version 8.9+ along Yarn or NPM. Read package.json and take notice of the scripts you can use. After cloning the repo run:",
    "anchor": "Development-Setup",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 148,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar UI Source Code",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Commonly used NPM scripts",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Commonly-used-NPM-scripts",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 149,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar UI Source Code",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Project Structure (/ui)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "build contains build-related configuration files. In most cases you don't need to touch them. src contains the source code, obviously. The codebase is written in ES2015.components JS, Sass and JSON (API) files for Quasar Vue componentscomposables Quasar's composables for Vue 3 Composition APIdirectives Vue directives supplied by Quasarplugins Quasar pluginscss Sass definitions and core code for Quasar themesutils utilities used by the framework and exported to the public API lang Quasar language packs icon-set Quasar icon sets dist contains built files for distribution (only after a build). Note this directory is only updated when a release happens; they do not reflect the latest changes in development branches. dev app with Quasar sources linked directly used for testing purposes. Each feature/component has its own *.vue file. Adding a new file automatically creates a route for it and adds it to the \"homepage\" list (based on the file name).",
    "anchor": "Project-Structure-(%2Fui)",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 150,
    "hierarchy_lvl0": "Contribution Guide",
    "hierarchy_lvl1": "Contribution Guide",
    "hierarchy_lvl2": "Contributing to the Quasar UI Source Code",
    "hierarchy_lvl3": "Documentation Best Practices",
    "hierarchy_lvl4": "Dev Server for Quasar (/ui)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Thank you to all the people who already contributed to Quasar!",
    "anchor": "Dev-Server-for-Quasar-(%2Fui)",
    "url": "/contribution-guide/contribution-guide"
  },
  {
    "objectID": 151,
    "hierarchy_lvl0": "Running Projects",
    "hierarchy_lvl1": "Active Project, Goals and Maintainers",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar's active projects, goals and maintainers.",
    "anchor": "Introduction",
    "url": "/contribution-guide/running-projects"
  },
  {
    "objectID": 152,
    "hierarchy_lvl0": "Running Projects",
    "hierarchy_lvl1": "Active Project, Goals and Maintainers",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/contribution-guide/running-projects"
  },
  {
    "objectID": 153,
    "hierarchy_lvl0": "Running Projects",
    "hierarchy_lvl1": "Active Project, Goals and Maintainers",
    "hierarchy_lvl2": "List of Projects Where New Maintainer is Needed",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are interested, read The Role of the Project Maintainer and let Razvan know via Discord chat. We can promise you that your Javascript and Vue.js skills will reach the stars!",
    "anchor": "List-of-Projects-Where-New-Maintainer-is-Needed",
    "url": "/contribution-guide/running-projects"
  },
  {
    "objectID": 154,
    "hierarchy_lvl0": "Start a New Project",
    "hierarchy_lvl1": "How-to Start a New Project",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to start a new project for Quasar.",
    "anchor": "Introduction",
    "url": "/contribution-guide/new-project"
  },
  {
    "objectID": 155,
    "hierarchy_lvl0": "Start a New Project",
    "hierarchy_lvl1": "How-to Start a New Project",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Email to Razvan (razvan.stoenescu [at] gmail [dot] com) the following:a. The need you are fulfilling with the new Quasar Projectb. Name of the owner/maintainer the project?c. Vision and a technical high-level overviewd. When do you plan the first public release?e. Milestones with estimated datesf. How much time you need from the Quasar teamg. Document the changes which are needed in the Quasar core / extensionsh. Sustainability plan - any project creates more work and pressure on the existing Quasar team - what is your long-term maintenance plan Set up a meeting with Razvan to discuss it and invite all engaged in the project",
    "anchor": "Introduction",
    "url": "/contribution-guide/new-project"
  },
  {
    "objectID": 156,
    "hierarchy_lvl0": "Project Maintainer Role",
    "hierarchy_lvl1": "The Role of the Project Maintainer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The role of a Quasar project manager",
    "anchor": "Introduction",
    "url": "/contribution-guide/project-maintainer"
  },
  {
    "objectID": 157,
    "hierarchy_lvl0": "Project Maintainer Role",
    "hierarchy_lvl1": "The Role of the Project Maintainer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You have a vision on something great that you want to build and own You have enough time to put into it to succeed (although, yes, “You may have a job and the job is your priority, not this Quasar Project” --- this is perfectly fine) You are not already involved in other projects that take a lot of your time and focus You love open source You want to help others You can accept constructive criticism",
    "anchor": "Introduction",
    "url": "/contribution-guide/project-maintainer"
  },
  {
    "objectID": 158,
    "hierarchy_lvl0": "Project Maintainer Role",
    "hierarchy_lvl1": "The Role of the Project Maintainer",
    "hierarchy_lvl2": "Your Responsibilities",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You are loosely aware of the entire Quasar ecosystem / inner-workings and in a detail of your Quasar feature / component / app extension / area. You are recognized in the community (forum / chat) as the authority and lead over your Quasar feature / component / app extension / area and you actively supports it You document, communicate and keep updated the vision of the Quasar feature / component / app extension / area that you are responsible for You deliver the vision by implementing, fixing bugs, reviewing and merging PRs directly and via contributors You focus on high usability for the end users - demos, documentation, community requests via forum and Discord You provide inputs for Marketing and Media departments for articles on your Quasar Project you don’t have to be the one writing the articles, although preferred, but at least find someone willing You provide a code review for other Quasar maintainers and request a code review of your contributions You keep track of the ongoing work and reported issues to make sure that it gets reviewed and merged in a timely manner. You acknowledge every important contributor and give credit for their work (also in written form on the repo README, on every presentation material, on documentation). You have also the final responsibility If no reviewer can be found for an important contribution, you review.If no developer can be found to fix an important bug, you develop.If something goes wrong, it’s eventually your fault. You keep the Quasar team updated at least on bi-weekly basis You have regular calls with RazvanYou post a short project status into Discord #projects-status channel You are brave to step down when you do not have time - it is perfectly fine to announce it. More info - Best Practices for Maintainers",
    "anchor": "Your-Responsibilities",
    "url": "/contribution-guide/project-maintainer"
  },
  {
    "objectID": 159,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar commit conventions",
    "anchor": "Introduction",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 160,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "warning This rule applies to ALL Quasar repositories.  Well-cared log is a beautiful and useful thing. git blame, revert, rebase, log, shortlog and other subcommands come to life. Reviewing others’ commits and pull requests becomes something worth doing, and suddenly can be done independently. Understanding why something happened months or years ago becomes not only possible but efficient.",
    "anchor": "Introduction",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 161,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "The Rules of a Great Git Commit Message",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Separate subject from body with a blank line Limit the subject line to 70 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 80 characters Use the body to explain what and why vs. how",
    "anchor": "The-Rules-of-a-Great-Git-Commit-Message",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 162,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "Format of a Commit Message",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Format-of-a-Commit-Message",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 163,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "Format of a Commit Message",
    "hierarchy_lvl3": "Example of a Commit Message",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Example-of-a-Commit-Message",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 164,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "Message Subject (First Line)",
    "hierarchy_lvl3": "Example of a Commit Message",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The first line cannot be longer than 70 characters, the second line is always blank. The type and scope should always be lowercase as shown below. Allowed <type> values: feat new feature for the user, not a new feature for build script fix bug fix for the user, not a fix to a build script docs documentation only changes style changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor refactoring production code, a code change that neither fixes a bug nor adds a feature chore other changes that don't modify src or test files; no production code change perf change that improves performance revert reverts a previous commit test adding missing tests, refactoring tests; no production code change build changes that affect the build system or external dependencies (example scopes: gulp, npm) ci changes to our Continuous Integrations configuration files and scripts (example scopes: Travis, Circle CI) Example <scope> values: ui, cli, api, touchswipe, qtime, etc.  The <scope> can contain more values separated by comma. Example: fix(ui,cli): Cordova mode added. The <scope> can be empty (e.g. if the change is a global), in which case the parentheses are omitted.",
    "anchor": "Message-Subject-(First-Line)",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 165,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "Message Body",
    "hierarchy_lvl3": "Example of a Commit Message",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "uses the imperative, present tense: “change” not “changed” nor “changes” includes motivation for the change and contrasts with previous behavior",
    "anchor": "Message-Body",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 166,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "Message Footer",
    "hierarchy_lvl3": "Example of a Commit Message",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All breaking changes have to be mentioned as a breaking change block in the footer, which should start with the word BREAKING CHANGE: with a space or two newlines. The rest of the commit message is then the description of the change, justification and migration notes.",
    "anchor": "Message-Footer",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 167,
    "hierarchy_lvl0": "Commit Conventions",
    "hierarchy_lvl1": "Commit Conventions",
    "hierarchy_lvl2": "Message Footer",
    "hierarchy_lvl3": "Referencing Issues",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Closed issues should be listed on a separate line in the footer prefixed with \"Closes\" keyword like this: Closes #234 or in the case of multiple issues: Closes #123, #245, #992",
    "anchor": "Referencing-Issues",
    "url": "/contribution-guide/commit-conventions"
  },
  {
    "objectID": 168,
    "hierarchy_lvl0": "The $q object",
    "hierarchy_lvl1": "The $q object",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The $q object in Quasar. Why and how to use it.",
    "anchor": "Introduction",
    "url": "/options/the-q-object"
  },
  {
    "objectID": 169,
    "hierarchy_lvl0": "The $q object",
    "hierarchy_lvl1": "The $q object",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/options/the-q-object"
  },
  {
    "objectID": 170,
    "hierarchy_lvl0": "The $q object",
    "hierarchy_lvl1": "The $q object",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following sections will teach you how to use it in .vue files (with both Composition API and Options API) and outside of them.",
    "anchor": "Usage",
    "url": "/options/the-q-object"
  },
  {
    "objectID": 171,
    "hierarchy_lvl0": "The $q object",
    "hierarchy_lvl1": "The $q object",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Composition API",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following is a .vue file:",
    "anchor": "Composition-API",
    "url": "/options/the-q-object"
  },
  {
    "objectID": 172,
    "hierarchy_lvl0": "The $q object",
    "hierarchy_lvl1": "The $q object",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Options API",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following is a .vue file:",
    "anchor": "Options-API",
    "url": "/options/the-q-object"
  },
  {
    "objectID": 173,
    "hierarchy_lvl0": "The $q object",
    "hierarchy_lvl1": "The $q object",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Outside of a vue file",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Outside-of-a-vue-file",
    "url": "/options/the-q-object"
  },
  {
    "objectID": 174,
    "hierarchy_lvl0": "App Icons",
    "hierarchy_lvl1": "App Icons",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Managing all the App icons and splash screens in a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/app-icons"
  },
  {
    "objectID": 175,
    "hierarchy_lvl0": "App Icons",
    "hierarchy_lvl1": "App Icons",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.",
    "anchor": "Introduction",
    "url": "/options/app-icons"
  },
  {
    "objectID": 176,
    "hierarchy_lvl0": "SEO",
    "hierarchy_lvl1": "SEO with Quasar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Managing the search engine optimizations in a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/seo"
  },
  {
    "objectID": 177,
    "hierarchy_lvl0": "SEO",
    "hierarchy_lvl1": "SEO with Quasar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar Meta Plugin can dynamically change page title, manage <meta> tags, manage <html> and <body> DOM element attributes, add/remove/change <style> and <script> tags in the head of your document (useful for CDN stylesheets or for json-ld markup, for example), or manage <noscript> tags. Take full advantage of this feature by using it with Quasar CLI, especially for the SSR (Server-Side Rendering) builds. It doesn't quite make sense to use it for SPA (Single Page Applications) since the meta information in this case will be added at run-time and not supplied directly by the webserver (as on SSR builds).  This Quasar plugin has the most tight integration with Quasar and so it has the best performance against any other similar solution.",
    "anchor": "Introduction",
    "url": "/options/seo"
  },
  {
    "objectID": 178,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure the Quasar language packs in a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 179,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "As mentioned above, some Quasar components have their own labels. When it comes to internationalization, one option is to configure labels through the label properties on each instance of Quasar components (like QTable). This is how you can customize the text to match the selected language. This however, takes time and adds unnecessary complexity to your website/app. Instead, you can use the Quasar Language Packs which have a number of standard label definitions translated for you, like \"Cancel\", \"Clear\", \"Select\", \"Update\", etc. No need to translate these again! And it comes out of the box.  For a complete list of available Quasar Languages, check Quasar Languages on GitHub. If your desired language is not on that list, then feel free to submit a PR to add it. It takes from 5 to 10 minutes at most. We kindly welcome any language!",
    "anchor": "Introduction",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 180,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Configuring the default Language Pack",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Unless configured otherwise (see below), Quasar uses the en-US Language Pack by default.",
    "anchor": "Configuring-the-default-Language-Pack",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 181,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Configuring the default Language Pack",
    "hierarchy_lvl3": "Hardcoded",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Hardcoded",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 182,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Configuring the default Language Pack",
    "hierarchy_lvl3": "Hardcoded",
    "hierarchy_lvl4": "Vue CLI",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Vue-CLI",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 183,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Configuring the default Language Pack",
    "hierarchy_lvl3": "Hardcoded",
    "hierarchy_lvl4": "Quasar UMD",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Check what tags you need to include in your HTML files on UMD / Standalone page.",
    "anchor": "Quasar-UMD",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 184,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Configuring the default Language Pack",
    "hierarchy_lvl3": "Dynamical (non-SSR)",
    "hierarchy_lvl4": "Quasar UMD",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Then register this boot file into /quasar.conf.js:  Always constrain a dynamic import Notice the use of the Webpack magic comment - webpackInclude. Otherwise all the available language packs will be bundled, resulting in an increase in the compilation time and the bundle size. See Caveat for dynamic imports",
    "anchor": "Dynamical-(non-SSR)",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 185,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Configuring the default Language Pack",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Quasar UMD",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Dynamical-(SSR)",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 186,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Change Quasar Language Pack at Runtime",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Quasar UMD",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Change-Quasar-Language-Pack-at-Runtime",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 187,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Using Quasar Language Pack in App Space",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Quasar UMD",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Check a Quasar Language Pack on GitHub to see the structure of $q.lang.",
    "anchor": "Using-Quasar-Language-Pack-in-App-Space",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 188,
    "hierarchy_lvl0": "Quasar Language Packs",
    "hierarchy_lvl1": "Quasar Language Packs",
    "hierarchy_lvl2": "Detecting Locale",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Quasar UMD",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Detecting-Locale",
    "url": "/options/quasar-language-packs"
  },
  {
    "objectID": 189,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use vue-i18n in a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 190,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you missed enabling i18n during quasar create wizard, here is how you can set it up manually. Install the vue-i18n dependency into your app. Create a file src/boot/i18n.js with following content: Create a folder (/src/i18n/) in your app which will hold the definitions for each language that you'll support. Example: src/i18n. Notice the \"import messages from 'src/i18n'\" from step 2. This is step where you write the content that gets imported. Now reference this file in quasar.config.js in the boot section: Now you are ready to use it in your pages.",
    "anchor": "Introduction",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 191,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": "Setting up Translation Blocks in your SFCs",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Setting-up-Translation-Blocks-in-your-SFCs",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 192,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": "How to use",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are 3 main cases: mykey1 in HTML body mykey2 in attribute mykey3 programmatically",
    "anchor": "How-to-use",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 193,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": "Add new language",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Let's say you want to add new German language. Create the new file src/i18n/de/index.js and copy there the content of the file src/i18n/en-US/index.js then make changes to the language strings. Now change src/i18n/index.js and add the new de language there.",
    "anchor": "Add-new-language",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 194,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": "Create language switcher",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Create-language-switcher",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 195,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": "UPPERCASE",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QBtn component will use the CSS text-transform: uppercase rule to automatically turn its label into all-caps. According to the MDN webdocs, \"The language is defined by the lang HTML attribute or the xml:lang XML attribute.\" Unfortunately, this has spotty implementation across browsers, and the 2017 ISO standard for the uppercase German eszett ß has not really entered the canon. At the moment you have two options: use the prop no-caps in your label and write the string as it should appear use the prop no-caps in your label and rewrite the string with toLocaleUpperCase by using the locale as detected by $q.lang.getLocale()",
    "anchor": "UPPERCASE",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 196,
    "hierarchy_lvl0": "App Internationalization",
    "hierarchy_lvl1": "App Internationalization (i18n)",
    "hierarchy_lvl2": "Detecting Locale",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you use Quasar's set method ($q.lang.set()), this will not be reflected by Quasar's getLocale above. The reason for this is that getLocale() will always return the users locale (based on browser settings). The set() method refers to Quasars internal locale setting which is used to determine which language file to use. If you would like to see which language has been set using set() you can use $q.lang.isoName.",
    "anchor": "Detecting-Locale",
    "url": "/options/app-internationalization"
  },
  {
    "objectID": 197,
    "hierarchy_lvl0": "RTL Support",
    "hierarchy_lvl1": "RTL Support",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Right to left support in a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/rtl-support"
  },
  {
    "objectID": 198,
    "hierarchy_lvl0": "RTL Support",
    "hierarchy_lvl1": "RTL Support",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Let's discuss about each of these requirements: Quasar needs to be set to use an RTL language. See Quasar Language Packs on how you can set a language. You can set a language as default or dynamically set one. RTL support needs to be enabled. You need to set \"rtl\" to \"true\" under quasar.conf.js > \"build\". What this does is it compiles CSS for both your website/app code and for Quasar components and add corresponding RTL CSS rules automatically. Your CSS bundle will slightly increase in size due to the addition of these CSS rules. Optional: Enable fromRTL flag. By default, Quasar assumes that all styles are written in LTR direction and generates corresponding RTL styles for them. Should you wish to write your own css directly in RTL then you need to set quasar.conf.js > \"build\" > rtl > \"fromRTL\" to true.",
    "anchor": "Introduction",
    "url": "/options/rtl-support"
  },
  {
    "objectID": 199,
    "hierarchy_lvl0": "RTL Support",
    "hierarchy_lvl1": "RTL Support",
    "hierarchy_lvl2": "Things to keep in mind",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "...will add this rule for RTL: Any CSS rule that refers to \"left\" or \"right\" is automatically triggering an equivalent RTL CSS rule to be added.",
    "anchor": "Things-to-keep-in-mind",
    "url": "/options/rtl-support"
  },
  {
    "objectID": 200,
    "hierarchy_lvl0": "RTL Support",
    "hierarchy_lvl1": "RTL Support",
    "hierarchy_lvl2": "Things to keep in mind",
    "hierarchy_lvl3": "Marking CSS rules as exceptions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "...or SCSS with indented form: ...or default SCSS: Now both RTL and non-RTL UI mode will have margin-left prop. Sometimes you'll need to make exceptions for whole DOM elements / components. In this case, add dir=\"ltr\" or dir=\"rtl\" HTML attribute to the outermost DOM element / component template: Or, if you need your RTL UI to use left-to-right (ltr) mode for a DOM element / component: html <div dir=\"ltr\"> <!-- this DIV and all its content will use non-RTL mode regardless of Quasar language pack RTL settings --> </div>",
    "anchor": "Marking-CSS-rules-as-exceptions",
    "url": "/options/rtl-support"
  },
  {
    "objectID": 201,
    "hierarchy_lvl0": "RTL Support",
    "hierarchy_lvl1": "RTL Support",
    "hierarchy_lvl2": "Handling Quasar UMD",
    "hierarchy_lvl3": "Marking CSS rules as exceptions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Check what tags you need to include in your HTML files by generating a sample with $ quasar create <folder> --kit umd and answering with \"Yes\" to the RTL question and specifying an RTL language for Quasar Language Pack. Also notice the <html dir=\"rtl\"> tag at the beginning of the generated html file -- you'll need that too.  CAVEAT Quasar CLI automatically adds equivalent RTL CSS rules for your website/app code, but this is not the case for UMD where Quasar CLI is not being used. You'll have to manage writing the RTL equivalent of your website/app CSS code by yourself. It's only Quasar components that will have this handled automatically.",
    "anchor": "Handling-Quasar-UMD",
    "url": "/options/rtl-support"
  },
  {
    "objectID": 202,
    "hierarchy_lvl0": "Installing Icon Libraries",
    "hierarchy_lvl1": "Installing Icon Libraries",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use icon libraries in a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/installing-icon-libraries"
  },
  {
    "objectID": 203,
    "hierarchy_lvl0": "Installing Icon Libraries",
    "hierarchy_lvl1": "Installing Icon Libraries",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll most likely want icons in your website/app and Quasar offers an easy way out of the box for the following icon libraries: Material Icons , Font Awesome, Ionicons, MDI, Eva Icons, Themify Icons and Line Awesome. But you can add support for others by yourself.  In regards to webfont icons, you can choose to install one or more of these icon libraries.",
    "anchor": "Introduction",
    "url": "/options/installing-icon-libraries"
  },
  {
    "objectID": 204,
    "hierarchy_lvl0": "Installing Icon Libraries",
    "hierarchy_lvl1": "Installing Icon Libraries",
    "hierarchy_lvl2": "Installing Webfonts",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Edit /quasar.conf.js: Webfont icons are available through @quasar/extras package. You don't need to import it in your app, just configure /quasar.conf.js as indicated above. Adding more than one set (showing all options): js extras: [ 'material-icons', 'material-icons-outlined', 'material-icons-round', 'material-icons-sharp', 'mdi-v3', 'ionicons-v4', 'eva-icons', 'fontawesome-v5', 'themify', 'line-awesome' ] You're now ready to use the QIcon component.",
    "anchor": "Installing-Webfonts",
    "url": "/options/installing-icon-libraries"
  },
  {
    "objectID": 205,
    "hierarchy_lvl0": "Installing Icon Libraries",
    "hierarchy_lvl1": "Installing Icon Libraries",
    "hierarchy_lvl2": "Using CDN as alternative",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In case you follow this path, do not also add the icon sets that you want in /quasar.conf.js > extras. Play with the UMD Installation Guide and edit index.template.html as described there.",
    "anchor": "Using-CDN-as-alternative",
    "url": "/options/installing-icon-libraries"
  },
  {
    "objectID": 206,
    "hierarchy_lvl0": "Installing Icon Libraries",
    "hierarchy_lvl1": "Installing Icon Libraries",
    "hierarchy_lvl2": "Using Fontawesome-Pro",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Open the Linked Accounts section in Fontawesome's user account page to grab the npm TOKENID (login if necessary). Create or append TOKENID into the .npmrc file (file path same as package.json): @fortawesome:registry=https://npm.fontawesome.com/ //npm.fontawesome.com/:_authToken=TOKENID Install Fontawesome webfonts: bash $ yarn add @fortawesome/fontawesome-pro Create new boot file: bash $ quasar new boot fontawesome-pro Edit /quasar.conf.js: js boot: [ ... 'fontawesome-pro' // Add boot file ], extras: [ // 'fontawesome' // Disable free version! ], framework: { // if you want Quasar to use Fontawesome for its icons iconSet: 'fontawesome-v5-pro' } Edit /src/boot/fontawesome-pro.js: js // required import '@fortawesome/fontawesome-pro/css/fontawesome.css' import '@fortawesome/fontawesome-pro/css/light.css' // do you want these too? // import '@fortawesome/fontawesome-pro/css/brands.css' // import '@fortawesome/fontawesome-pro/css/solid.css' // import '@fortawesome/fontawesome-pro/css/regular.css' (Optional) Override default icons: Since the default font-weight for fontawesome-pro is light or fal, some icons used by the framework components may not be desirable. The best way to handle this is to override it in the boot file that you created. For instance, to override the fal version of the close icon for chips, do this: First, find the icon used for chip close in Quasar Fontawesome v5 Pro icon-set source. (Alternatively, you can check inside the render function of the component you are overriding.) Then, override it in your /src/boot/fontawesome-pro.js",
    "anchor": "Using-Fontawesome-Pro",
    "url": "/options/installing-icon-libraries"
  },
  {
    "objectID": 207,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure icon sets for Quasar components.",
    "anchor": "Introduction",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 208,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can install multiple icon libraries, but you must choose only one to use on Quasar's components. Quasar currently supports: Material Icons, Font Awesome, Line Awesome, Ionicons, MDI, Eva Icons, and Themify Icons. It is also possible to use your own icons (as custom svgs or as images in any format) with any Quasar component, see the QIcon page for more info on this.  Related pages: Installing Icon Libraries and QIcon component.",
    "anchor": "Introduction",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 209,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Configuring the default Icon Set",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Unless configured otherwise, Quasar uses Material Icons webfont as the icon set for its components. You can however tell Quasar to use some other Icon Set, but if it's a webfont-based one then be sure to include its icon library in your website/app (see Installing Icon Libraries).",
    "anchor": "Configuring-the-default-Icon-Set",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 210,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Configuring the default Icon Set",
    "hierarchy_lvl3": "Hardcoded",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For all available options, visit the GitHub repository. Full example of including MDI & Fontawesome and telling Quasar to use Fontawesome for its components. This will enable you to use both Ionicons & Fontawesome webfonts in your app, and all Quasar components will display Fontawesome icons.",
    "anchor": "Hardcoded",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 211,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Configuring the default Icon Set",
    "hierarchy_lvl3": "Hardcoded",
    "hierarchy_lvl4": "UMD Way",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Check what tags you need to include in your HTML files on UMD / Standalone page.",
    "anchor": "UMD-Way",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 212,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Configuring the default Icon Set",
    "hierarchy_lvl3": "Hardcoded",
    "hierarchy_lvl4": "Vue CLI Way",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Vue-CLI-Way",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 213,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Configuring the default Icon Set",
    "hierarchy_lvl3": "Dynamical (non-SSR)",
    "hierarchy_lvl4": "Vue CLI Way",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Then register this boot file into /quasar.conf.js:  Always constrain a dynamic import Notice the use of the Webpack magic comment - webpackInclude. Otherwise all the available icon set files will be bundled, resulting in an increase in the compilation time and the bundle size. See Caveat for dynamic imports",
    "anchor": "Dynamical-(non-SSR)",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 214,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Configuring the default Icon Set",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Vue CLI Way",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Dynamical-(SSR)",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 215,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Change Quasar Icon Set at Runtime",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Vue CLI Way",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Change-Quasar-Icon-Set-at-Runtime",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 216,
    "hierarchy_lvl0": "Quasar Icon Sets",
    "hierarchy_lvl1": "Quasar Icon Sets",
    "hierarchy_lvl2": "Change Quasar Icon Set at Runtime",
    "hierarchy_lvl3": "Dynamical (SSR)",
    "hierarchy_lvl4": "Changing a Specific Icon Dynamically",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Changing-a-Specific-Icon-Dynamically",
    "url": "/options/quasar-icon-sets"
  },
  {
    "objectID": 217,
    "hierarchy_lvl0": "Platform Detection",
    "hierarchy_lvl1": "Platform Detection",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to detect the platform under which a Quasar app is running.",
    "anchor": "Introduction",
    "url": "/options/platform-detection"
  },
  {
    "objectID": 218,
    "hierarchy_lvl0": "Platform Detection",
    "hierarchy_lvl1": "Platform Detection",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Based on your needs, you might also want to check the Style & Identity &gt; Visibility page to see how you can achieve the same effect using CSS alone. This latter method will render your DOM elements or components regardless of platform though, so choose wisely on how you want to handle the performance of your app.",
    "anchor": "Introduction",
    "url": "/options/platform-detection"
  },
  {
    "objectID": 219,
    "hierarchy_lvl0": "Platform Detection",
    "hierarchy_lvl1": "Platform Detection",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Usage inside a Vue component template: You must import it when you use it outside of a Vue component : Platform.is by itself returns an object containing details about the current platform. For example when running Chrome on a MacOS desktop machine, Platform.is would return something similar to: Now, let's say we want to render different components or DOM elements, based on the platform that the code is running under. We want to show something on desktop and something else on mobile. We would proceed like this:",
    "anchor": "Usage",
    "url": "/options/platform-detection"
  },
  {
    "objectID": 220,
    "hierarchy_lvl0": "Platform Detection",
    "hierarchy_lvl1": "Platform Detection",
    "hierarchy_lvl2": "Properties",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following properties are available to the Platform object. It's not an exhaustive list though. See the API section below for more details.  Running on mobile means you can have this code running on a mobile device (phone or tablet) but with a browser, not within a Cordova wrapper.",
    "anchor": "Properties",
    "url": "/options/platform-detection"
  },
  {
    "objectID": 221,
    "hierarchy_lvl0": "Platform Detection",
    "hierarchy_lvl1": "Platform Detection",
    "hierarchy_lvl2": "Note about SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The ssrContext is available in boot files. And also in the preFetch feature, where it is supplied as a parameter. The reason for all this is that in a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same: each request should have a fresh, isolated app instance so that there is no cross-request state pollution. So Platform needs to be bound to each request separately.",
    "anchor": "Note-about-SSR",
    "url": "/options/platform-detection"
  },
  {
    "objectID": 222,
    "hierarchy_lvl0": "Screen Plugin",
    "hierarchy_lvl1": "Screen Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar plugin that helps in writing a dynamic and responsive UI through Javascript code.",
    "anchor": "Introduction",
    "url": "/options/screen-plugin"
  },
  {
    "objectID": 223,
    "hierarchy_lvl0": "Screen Plugin",
    "hierarchy_lvl1": "Screen Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We can also use the Screen plugin outside of a Vue component:",
    "anchor": "Introduction",
    "url": "/options/screen-plugin"
  },
  {
    "objectID": 224,
    "hierarchy_lvl0": "Screen Plugin",
    "hierarchy_lvl1": "Screen Plugin",
    "hierarchy_lvl2": "Body classes",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you enable it (see how to do it after the examples below), you can also style your content based on a particular set of CSS classes applied to document.body: screen--xs, screen--sm, ..., screen-xl. Or a sexy variant in Sass:",
    "anchor": "Body-classes",
    "url": "/options/screen-plugin"
  },
  {
    "objectID": 225,
    "hierarchy_lvl0": "Screen Plugin",
    "hierarchy_lvl1": "Screen Plugin",
    "hierarchy_lvl2": "Body classes",
    "hierarchy_lvl3": "How to enable body classes",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order to enable the behavior above, edit your /quasar.conf.js file like below. Please note that this will increase a bit the time for First Meaningful Paint.",
    "anchor": "How-to-enable-body-classes",
    "url": "/options/screen-plugin"
  },
  {
    "objectID": 226,
    "hierarchy_lvl0": "Screen Plugin",
    "hierarchy_lvl1": "Screen Plugin",
    "hierarchy_lvl2": "Configuration",
    "hierarchy_lvl3": "How to enable body classes",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Examples:",
    "anchor": "Configuration",
    "url": "/options/screen-plugin"
  },
  {
    "objectID": 227,
    "hierarchy_lvl0": "Animations",
    "hierarchy_lvl1": "Animations",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Helper CSS animations supplied by Animate.css for a Quasar app.",
    "anchor": "Introduction",
    "url": "/options/animations"
  },
  {
    "objectID": 228,
    "hierarchy_lvl0": "Animations",
    "hierarchy_lvl1": "Animations",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, Quasar can supply a big list of ready to use CSS animations. The animation effects are borrowed from Animate.css. So there are 80+ animation types available for you to use out of the box. Check the list either on Animate.css website or on the demo available for this page. Please refer to Vue documentation for learning on how to use the Vue supplied <transition> component.",
    "anchor": "Introduction",
    "url": "/options/animations"
  },
  {
    "objectID": 229,
    "hierarchy_lvl0": "Animations",
    "hierarchy_lvl1": "Animations",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// or embedding only specific animations animations: [ 'bounceInLeft', 'bounceOutRight' ] ``` If you are building a website, you can also skip configuring quasar.conf.js and use a CDN link which points to Animate.css like this (following is just an example, Google for latest link). Remember this will require an Internet connection for your user, as opposed to bundling from within quasar.conf.js.  It should be noted that when you import Animate.css through the <link> tag, all animation CSS classes must be prefixed with animate__. This is a breaking change in the migration of Animate.css from v3 to v4. If you want to avoid using prefixes, you can import the compat version. However, if you're using the Quasar CLI, no additional changes are needed.",
    "anchor": "Installation",
    "url": "/options/animations"
  },
  {
    "objectID": 230,
    "hierarchy_lvl0": "Animations",
    "hierarchy_lvl1": "Animations",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Usage",
    "url": "/options/animations"
  },
  {
    "objectID": 231,
    "hierarchy_lvl0": "Animations",
    "hierarchy_lvl1": "Animations",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Wrapping Multiple Elements",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note some things in the above example: Note <transition-group> instead of <transition>. The components and DOM elements must be keyed, like key=\"text\" or key=\"email-button\" in the example above. Both examples above have the Boolean property appear specified, which makes the entering animation kick in right after component(s) have been rendered. This property is optional.",
    "anchor": "Wrapping-Multiple-Elements",
    "url": "/options/animations"
  },
  {
    "objectID": 232,
    "hierarchy_lvl0": "Transitions",
    "hierarchy_lvl1": "Quasar Components Transitions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Out of the box CSS transitions for Quasar components.",
    "anchor": "Introduction",
    "url": "/options/transitions"
  },
  {
    "objectID": 233,
    "hierarchy_lvl0": "Transitions",
    "hierarchy_lvl1": "Quasar Components Transitions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Use the names indicated in the captions above for the transition props. Example:",
    "anchor": "Introduction",
    "url": "/options/transitions"
  },
  {
    "objectID": 234,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of Quasar security recommendations.",
    "anchor": "Introduction",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 235,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 236,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Vue Security Risks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The v-html directive is a wonderful way to programmatically render markup, but even the Vue docs come with this warning: > \"Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided content.\" If you don't know what that means, take a quick look at what OWASP has to say about XSS (aka cross-site scripting). To be fair, this is good advice, but DON'T be all hand-wavy. DO think like an attacker who will innovate, social engineer, lie, phish and steal their way into your systems. What if a webpack loader exploit arises and changes your page in an evil way? What if someone makes a dastardly and ill-intentioned PR? What if suddenly a third party API changes and instead of plaintext starts sending the same structure but with different content? What if the systems you thought were safe turn out to actually have been backdoored? What if a junior dev makes an accidental and fundamentally threatening change to the code that isn't reviewed properly? (Yes, idiocy is sometimes as dangerous as bad intentions!) The point is, DO anticipate the unexpected by preparing for the absolute worst case scenario and hardening all of your systems. DO use the v-pre directive if you need to take extra precaution.",
    "anchor": "Vue-Security-Risks",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 237,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Vue Security Risks",
    "hierarchy_lvl3": "vue-i18n",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "vue-i18n",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 238,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Quasar Components",
    "hierarchy_lvl3": "vue-i18n",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There have been a number of recent exploits (especially for older Android and iOS devices) where certain emoji and non-standard UTF-8 actually triggered mobile device restarts and boot-screen loops. DO consider a devland integration of markdown parsing in a plain-text type of input field and render it to HTML on the server side before you pass it to the chat recipients.",
    "anchor": "Quasar-Components",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 239,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Quasar Components",
    "hierarchy_lvl3": "Loading",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "OWASP cheatsheet FIDO Guidelines",
    "anchor": "Loading",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 240,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Cryptography",
    "hierarchy_lvl3": "Loading",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A great place to read about this topic and properly choose an industrial strength solution is libsodium",
    "anchor": "Cryptography",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 241,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Distribution",
    "hierarchy_lvl3": "Loading",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If someone wants to change something in your database or add some file to the server and they are not using an SSH key, DO validate AND sanitize the input.",
    "anchor": "Distribution",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 242,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Distribution",
    "hierarchy_lvl3": "Web",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Cordova Docs Page goes into detail about securing Cordova, and although it seems outdated, the information is mostly still on point.",
    "anchor": "Web",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 243,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Distribution",
    "hierarchy_lvl3": "Electron",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Electron",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 244,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Distribution",
    "hierarchy_lvl3": "Operational Security",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Audit how your production environment works: - DON'T think security through obscurity will help you when you are under attack - DON'T leave unneeded ports open - DON'T pretend containers or VM's keep you safe by their nature - DON'T ever stop being paranoid - DO turn off password and root access to your server - DO use secure transfer protocols (SSH, HTTPS, SFTP, WSS) - DO install fail2ban and rkhunter - DO regularly analyze your logs - DO encrypt data at rest - DO use advanced media-type analysis - DO use ClamAV to detect infected files - DO undertake regular system maintenance - DO remove old ciphers from permitted / available types - DO protect users with CSP headers",
    "anchor": "Operational-Security",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 245,
    "hierarchy_lvl0": "DO's and DON'Ts",
    "hierarchy_lvl1": "Security DO's and DON'Ts",
    "hierarchy_lvl2": "Distribution",
    "hierarchy_lvl3": "Organizational & Repository Security",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This is something that every team should have on their radar and put some thought into. DO consider who has access to your repositories, how commits are merged and how assets are published. Here are some good things to remember: DON'T put sensitive data in your source code DON'T ignore yarn audit or npm audit reports DON'T blindly rely on third-party services DO require a review before merging to master DO require 2FA for reviewers / code committers DO require signed commits DO take GitHub Security Warnings seriously DO undertake deep code reviews DO review critical third-party libraries, especially any working with real files DO pin versions of critical libraries DO commit package lock files DO Add .env files to your .gitignore",
    "anchor": "Organizational-%26-Repository-Security",
    "url": "/security/dos-and-donts"
  },
  {
    "objectID": 246,
    "hierarchy_lvl0": "Report a vulnerability",
    "hierarchy_lvl1": "Report a vulnerability",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to report a Quasar security threat, vulnerability or exploit.",
    "anchor": "Introduction",
    "url": "/security/report-a-vulnerability"
  },
  {
    "objectID": 247,
    "hierarchy_lvl0": "Report a vulnerability",
    "hierarchy_lvl1": "Report a vulnerability",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "DON'T create a pull-request DON'T file an issue on GitHub DON'T mention it on Discord and DON'T create a forum thread DO reach out to the team by sending an email to security@quasar.dev - we will investigate and work with you to triage this issue and help you to report it, if appropriate. At the current time we do not have the financial ability to reward bounties, but in extreme cases will at our discretion consider a reward.",
    "anchor": "Introduction",
    "url": "/security/report-a-vulnerability"
  },
  {
    "objectID": 248,
    "hierarchy_lvl0": "Get help!",
    "hierarchy_lvl1": "Get Help!",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to apply for a security audit from Quasar team's security experts.",
    "anchor": "Introduction",
    "url": "/security/get-help"
  },
  {
    "objectID": 249,
    "hierarchy_lvl0": "Get help!",
    "hierarchy_lvl1": "Get Help!",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can apply to book the Quasar team's security experts to perform a Security Audit for your project. Contact us to find out more about how to acquire, validate and publish an official timestamped and version-locked audit badge. security@quasar.dev",
    "anchor": "Introduction",
    "url": "/security/get-help"
  },
  {
    "objectID": 250,
    "hierarchy_lvl0": "Installation",
    "hierarchy_lvl1": "Quasar CLI Installation",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to install the Quasar CLI on your development machine.",
    "anchor": "Introduction",
    "url": "/quasar-cli/installation"
  },
  {
    "objectID": 251,
    "hierarchy_lvl0": "Installation",
    "hierarchy_lvl1": "Quasar CLI Installation",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not use any Node version higher than 14+. Webpack 4 does not support any Node version higher than this and we cannot move to Webpack 5 without making breaking changes. However, we will support Webpack 5 in a future release.   Do not use uneven versions of Node i.e. 13, 15, etc. These versions are not tested with Quasar and often cause issues due to their experimental nature. We highly recommend always using the LTS version of Node.   If you are using Yarn, make sure that the Yarn global install location is in your PATH: Under Windows, modify user's PATH environment variable. If you are using yarn then add %LOCALAPPDATA%\\yarn\\bin, otherwise if you're using npm then add %APPDATA%\\npm.  Then we create a project folder with Quasar CLI: tip Some advanced scenarios require to use a custom starter kit (eg. testing or personal presets). In those rare cases, you can use --kit option. Read more about this into create command description. Remember that the recommended way to go is through writing a Quasar App Extension though.  tip WSL2 Microsoft's recommended Nodejs development environment setup in WSL2. When using WSL2 (Windows Subsystem for Linux) Microsoft recommends keeping files in the linux file sytem to maximize performance. Projects will build around 3X slower and HMR (Hot Module Reload) will not work (without a hack) if the project files are on the Windows mount instead of the local linux file system. This is also true in Docker for Windows based development environments.  Note that you don't need separate projects if you want to build any of the available platforms. This one project can seamlessly handle all of them. To continue your learning about Quasar, you should familiarize yourself with the Quasar CLI in depth, because you will be using it a lot.",
    "anchor": "Introduction",
    "url": "/quasar-cli/installation"
  },
  {
    "objectID": 252,
    "hierarchy_lvl0": "Installation",
    "hierarchy_lvl1": "Quasar CLI Installation",
    "hierarchy_lvl2": "How it works",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar CLI is made up of two packages: @quasar/cli and @quasar/app. The first one is optional and only allows you to create a project folder and globally run Quasar commands. The second package is the heart of it and it gets installed into every Quasar project folder. Once a project folder has been generated, Quasar CLI will only help in running @quasar/app's commands globally. You don't need it for anything else at this point. To ensure full independence from Quasar CLI you can write npm scripts (in your package.json) to run Quasar commands. It is @quasar/app (which is specific to each project) that will run all the CLI commands. Example of adding a few npm scripts into your package.json: The above will allow you to run $ yarn dev or $ yarn build without the need of a globally installed @quasar/cli, should you wish to do so. Alternatively, you can even use npx to run quasar commands without the need of a globally installed @quasar/cli.",
    "anchor": "How-it-works",
    "url": "/quasar-cli/installation"
  },
  {
    "objectID": 253,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Where, how and what you can configure in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 254,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll notice that changing any of these settings does not require you to manually reload the dev server. Quasar detects if the changes can be injected through Hot Module Replacement and in case it can't, it will reload the dev server automatically for you. You won't lose your development flow, because you can just sit back while Quasar CLI quickly reloads the changed code, even keeping the current state. This saves tons of your time!   /quasar.conf.js is run by the Quasar CLI build system, so this code runs under Node directly, not in the context of your app. This means you can require modules like 'fs', 'path', 'webpack' and so on. Make sure the ES6 features that you want to write this file with are supported by the installed version of your Node (which should be >= 10).",
    "anchor": "Introduction",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 255,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Structure",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll notice that /quasar.conf.js exports a function that takes a ctx (context) parameter and returns an Object. This allows you to dynamically change your website/app config based on this context: What this means is that, as an example, you can load a font when building for a certain mode (like PWA), and pick another one for the others: Or you can use a global CSS file for SPA mode and another one for Cordova mode while avoiding loading any such file for the other modes. Or you can configure the dev server to run on port 8000 for SPA mode, on port 9000 for PWA mode or on port 9090 for the other modes: You can also do async work before returning the quasar configuration: The possibilities are endless.",
    "anchor": "Structure",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 256,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Structure",
    "hierarchy_lvl3": "IDE autocompletion",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can wrap the returned function with configure() helper to get a better IDE autocomplete experience (through Typescript):",
    "anchor": "IDE-autocompletion",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 257,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "IDE autocompletion",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Options-to-Configure",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 258,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: css",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Property%3A-css",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 259,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: vendor",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Property%3A-vendor",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 260,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: framework",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Filling \"components\" and \"directives\" is required only if \"all\" is set to false. More on cssAddon here.",
    "anchor": "Property%3A-framework",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 261,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: devServer",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Most used properties are: Using open prop to open with a specific browser and not with the default browser of your OS (check supported values based on the host OS): When you set devServer > https: true in your quasar.conf.js file, Quasar will auto-generate a SSL certificate for you. However, if you want to create one yourself for your localhost, then check out this blog post by Filippo. Then your quasar.conf.js > devServer > https should look like this: You can also configure automatically opening remote Vue Devtools:",
    "anchor": "Property%3A-devServer",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 262,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: build",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following properties of build are automatically configured by Quasar CLI depending on dev/build commands and Quasar mode. But if you like to override some (make sure you know what you are doing), you can do so: If, for example, you run \"quasar build --debug\", sourceMap and extractCSS will be set to \"true\" regardless of what you configure.",
    "anchor": "Property%3A-build",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 263,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: htmlVariables",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can define and then reference variables in src/index.template.html, like this: js // quasar.conf.js module.exports = function (ctx) { return { htmlVariables: { title: 'test name', some: { prop: 'my-prop' } } Then (just an example showing you how to reference a variable defined above, in this case title): html <!-- src/index.template.html --> <%= title %> <%= some.prop %>",
    "anchor": "Property%3A-htmlVariables",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 264,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Property: sourceFiles",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Property%3A-sourceFiles",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 265,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Example setting env for dev/build",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There's two concepts that need to be understood here. The env variables from the terminal that are available in /quasar.conf.js file itself and the environment variables that you pass to your UI code. Then in your website/app you can access process.env.API and it's gonna point to one of those two links above, based on dev or production build type. You can even go one step further. Supply it with values taken from the quasar dev/build env variables:  Also check out Handling process.env page.",
    "anchor": "Example-setting-env-for-dev%2Fbuild",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 266,
    "hierarchy_lvl0": "quasar.conf.js",
    "hierarchy_lvl1": "Configuring quasar.conf.js",
    "hierarchy_lvl2": "Options to Configure",
    "hierarchy_lvl3": "Example setting env for dev/build",
    "hierarchy_lvl4": "Using dotenv",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Should you wish to use .env file(s), you can even use dotenv package. The following is just an example that passes env variables from the terminal right down to your UI's app code: Then in your /quasar.conf.js: build: { env: require('dotenv').config().parsed }",
    "anchor": "Using-dotenv",
    "url": "/quasar-cli/quasar-conf-js"
  },
  {
    "objectID": 267,
    "hierarchy_lvl0": "Browser Compatibility",
    "hierarchy_lvl1": "Browser compatibility",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to handle the browser support with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/browser-compatibility"
  },
  {
    "objectID": 268,
    "hierarchy_lvl0": "Browser Compatibility",
    "hierarchy_lvl1": "Browser compatibility",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Babel will look for exactly the JS features that need transpiling (based on the configured browsers) and apply them. Be mindful about it though, as it is sufficient to add one \"bad apple\" in the options list and that will dumb down your code back to ES5. The following is the default \"browserslist\" when you create a Quasar project: More info on how to specify browser ranges: browserslist.",
    "anchor": "Introduction",
    "url": "/quasar-cli/browser-compatibility"
  },
  {
    "objectID": 269,
    "hierarchy_lvl0": "Supporting TypeScript",
    "hierarchy_lvl1": "Supporting TypeScript",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to enable support for TypeScript in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/supporting-ts"
  },
  {
    "objectID": 270,
    "hierarchy_lvl0": "Supporting TypeScript",
    "hierarchy_lvl1": "Supporting TypeScript",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following steps are only required when you have not selected TypeScript support when creating a fresh Quasar project. If you selected the TS option on project creation, TypeScript support is already enabled.",
    "anchor": "Introduction",
    "url": "/quasar-cli/supporting-ts"
  },
  {
    "objectID": 271,
    "hierarchy_lvl0": "Supporting TypeScript",
    "hierarchy_lvl1": "Supporting TypeScript",
    "hierarchy_lvl2": "Installation of TypeScript Support",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order to support TypeScript, you'll need to edit /quasar.conf.js: Then create /tsconfig.json file at the root of you project with this content: Now you can start using TypeScript into your project.  Remember that you must change the extension of your JavaScript files to .ts to be allowed to write TypeScript code inside them. To write TS code into your components, instead, change the script opening tag like so <script lang=\"ts\">.   If you enable the supportTS flag but fail to add the tsconfig.json file, the application will break at compile time!",
    "anchor": "Installation-of-TypeScript-Support",
    "url": "/quasar-cli/supporting-ts"
  },
  {
    "objectID": 272,
    "hierarchy_lvl0": "Supporting TypeScript",
    "hierarchy_lvl1": "Supporting TypeScript",
    "hierarchy_lvl2": "Handling TS Webpack loaders",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Behind the curtains, Quasar uses ts-loader and fork-ts-checker-webpack-plugin (provided by @quasar/app package) to manage TS files. If you ever need to provide a custom configuration for these libs you can do so by making supportTS property like so:",
    "anchor": "Handling-TS-Webpack-loaders",
    "url": "/quasar-cli/supporting-ts"
  },
  {
    "objectID": 273,
    "hierarchy_lvl0": "Supporting TypeScript",
    "hierarchy_lvl1": "Supporting TypeScript",
    "hierarchy_lvl2": "Handling TS Webpack loaders",
    "hierarchy_lvl3": "Linting setup",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "First add needed dependencies: Then update your ESLint configuration accordingly, like in the following example: If anything goes wrong, read the typescript-eslint guide, on which this example is based. As a last step, update your yarn lint command to also lint .ts files.  TypeScript Linting is really slow due to type-checking overhead, we suggest you to disable Webpack lint extension into quasar.conf.js for dev builds.  If you setup TypeScript linting and want fork-ts-checker-webpack-plugin (provided by @quasar/app package) to take it into account then you should make use of tsCheckerConfig property:",
    "anchor": "Linting-setup",
    "url": "/quasar-cli/supporting-ts"
  },
  {
    "objectID": 274,
    "hierarchy_lvl0": "Directory Structure",
    "hierarchy_lvl1": "Directory Structure",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The structure of a Quasar app with explanations for each folder and file.",
    "anchor": "Introduction",
    "url": "/quasar-cli/directory-structure"
  },
  {
    "objectID": 275,
    "hierarchy_lvl0": "Directory Structure",
    "hierarchy_lvl1": "Directory Structure",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-cli/directory-structure"
  },
  {
    "objectID": 276,
    "hierarchy_lvl0": "Build Commands",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar CLI list of commands for developing and building a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/build-commands"
  },
  {
    "objectID": 277,
    "hierarchy_lvl0": "Build Commands",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-cli/build-commands"
  },
  {
    "objectID": 278,
    "hierarchy_lvl0": "Build Commands",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Production",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Production",
    "url": "/quasar-cli/build-commands"
  },
  {
    "objectID": 279,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The entire list of Quasar CLI commands.",
    "anchor": "Introduction",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 280,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "See help for any command: bash $ quasar [command name] --help",
    "anchor": "Introduction",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 281,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Create",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Creates an App folder with initial project boilerplate. This command will use Quasar App Starter Kit by default, but you can specify a different one via --kit option. quasar create --kit ui and quasar create --kit app-extension will generate for you App Extension boilerplate: the former when the extension is meant to provide UI Components, the latter in all other cases. You can use a starter kit stored on your machine by providing a local path to a folder (eg. quasar create --kit ./my-custom-starter-kit). You can use a starter kit stored into any publicly accessible Git repository by providing a reference which follows this schema: - GitHub - github:owner/name or simply owner/name - GitLab - gitlab:owner/name - Bitbucket - bitbucket:owner/name master branch will be checked out by default, but you can specify the one you prefer via --branch <branch name> (eg. quasar create --kit owner/name --branch my-branch). warning The preferred way to build reusable code and UI Components into Quasar ecosystem are App Extensions. Use a custom starter kit only if you really know what you're doing and be aware that it will make more difficult for the Quasar team to provide you assistance.",
    "anchor": "Create",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 282,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Upgrade",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Check (and optionally) upgrade Quasar packages from a Quasar project folder:  Note for code editor terminals If you're using a code editor terminal instead of the real one, you run quasar upgrade and get an error Command not found or @quasar/cli version appears to be undefined, you will need to go to the settings of your code editor terminal and untick the option (or its equivalent) Add 'node_modules/.bin' from the project root to %PATH% then restart your code editor.",
    "anchor": "Upgrade",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 283,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Info",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for you to see what versions of Node, NPM, Quasar CLI, Quasar, Vue, Webpack, Cordova, Babel and many more, issue this command in a Quasar project folder: bash $ quasar info",
    "anchor": "Info",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 284,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Dev",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar development server allows you to develop your App by compiling and maintaining code in-memory. A web server will serve your App while offering hot-reload out of the box. Running in-memory offers faster rebuilds when you change your code. Hot Reload is much more than just refreshing your browser when code changes. It skips the refresh and updates your code on the fly, while maintaining your App's state (like your Vue's model data). Please note that there are cases when this is impossible, so the dev webserver will simply refresh your browser. (Always ensure you are running only one instance of Quasar CLI at a time, otherwise Hot-Reload and other stuff will break!) Based on what you want to develop, you can start the development server by using \"quasar dev\" command as follows: If you wish to change the hostname or port serving your App you have 3 options: * Edit '/quasar.conf.js': js devServer: { host: '...', port: ... } * Through '-H' (hostname) and '-p' (port) command options. * If this is a one time thing, specify the hostname and/or port as an environment variable: bash $ PORT=3000 quasar dev $ HOSTNAME=1.1.1.14 quasar dev If there appears to be an issue with hot reload, you can try two fixes: * Change the permissions for the project folder with",
    "anchor": "Dev",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 285,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Build",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI can pack everything together and optimize your App for production. It minifies source code, extracts vendor components, leverages browser cache and much more.",
    "anchor": "Build",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 286,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Clean",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Clean",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 287,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "New",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This command is simply a helper in order to quickly scaffold a page/layout/component/vuex store module. You are not required to use it, but can help you when you don't know how to start.",
    "anchor": "New",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 288,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Mode",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you initialize a project with the CLI, you can build SPA (Single Page Website/Application), SSR (Server-side Render Website/Application with optional PWA client takeover), PWA (Progressive Web App), Mobile App (through Cordova), and/or Electron Apps. When you develop for SSR, PWA, Cordova or Electron, you need these modes installed. If you issue \"quasar dev\" or \"quasar build\" they will automatically be installed. These modes will add a \"src-*\" folder into your project with very specific code for it: If for some reason you decide you don't need a mode, you can remove it. This will permanently delete the respective \"src-*\" folder.",
    "anchor": "Mode",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 289,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Describe",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Examples: $ quasar describe QIcon, $ quasar describe TouchPan, $ quasar describe Cookies.",
    "anchor": "Describe",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 290,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Inspect",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Inspect",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 291,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Ext",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Ext",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 292,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Run",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Run",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 293,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Serve",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Serve",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 294,
    "hierarchy_lvl0": "Commands List",
    "hierarchy_lvl1": "Commands List",
    "hierarchy_lvl2": "Serve",
    "hierarchy_lvl3": "Custom Node server",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Or you can build your own server. Here are some examples: If you need URL rewrites of API, or simply put you want to proxy your API requests, then you can use \"http-proxy-middleware\" package: Finally, run one of these files:",
    "anchor": "Custom-Node-server",
    "url": "/quasar-cli/commands-list"
  },
  {
    "objectID": 295,
    "hierarchy_lvl0": "CSS Preprocessors",
    "hierarchy_lvl1": "CSS Preprocessors",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Sass/SCSS are the out of the box supported css preprocessors in Quasar",
    "anchor": "Introduction",
    "url": "/quasar-cli/css-preprocessors"
  },
  {
    "objectID": 296,
    "hierarchy_lvl0": "CSS Preprocessors",
    "hierarchy_lvl1": "CSS Preprocessors",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You won't need to install any additional packages or extend the Webpack configuration.",
    "anchor": "Introduction",
    "url": "/quasar-cli/css-preprocessors"
  },
  {
    "objectID": 297,
    "hierarchy_lvl0": "CSS Preprocessors",
    "hierarchy_lvl1": "CSS Preprocessors",
    "hierarchy_lvl2": "How to",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "And, of course, standard CSS is also supported:",
    "anchor": "How-to",
    "url": "/quasar-cli/css-preprocessors"
  },
  {
    "objectID": 298,
    "hierarchy_lvl0": "Routing",
    "hierarchy_lvl1": "App Routing",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Vue Router in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/routing"
  },
  {
    "objectID": 299,
    "hierarchy_lvl0": "Routing",
    "hierarchy_lvl1": "App Routing",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Make sure to read Vue Router documentation to understand how it works. The /src/router/routes.js needs to import your website/app's Pages and Layouts. Read more on Routing with Layouts and Pages documentation page. When using Vuex the store is not directly importable from other scripts, but it is passed to the exported function of /src/router/index.js, so it can be accessed from there. For example you can use the Router.beforeEach method to check authentication in the router:",
    "anchor": "Introduction",
    "url": "/quasar-cli/routing"
  },
  {
    "objectID": 300,
    "hierarchy_lvl0": "Lazy Loading - Code Splitting",
    "hierarchy_lvl1": "Lazy Loading / Code Splitting",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to create Webpack chunks in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/lazy-loading"
  },
  {
    "objectID": 301,
    "hierarchy_lvl0": "Lazy Loading - Code Splitting",
    "hierarchy_lvl1": "Lazy Loading / Code Splitting",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "const routes = [ { path: '/some-page', component: SomePage } ] ``` Now let's change this and make the page be loaded on demand only, using dynamic imports: js const routes = [ { path: '/some-page', component: () => import('pages/SomePage') } ] Easy, right? What this does is that it creates a separate chunk for /src/pages/SomePage.vue which is then loaded only when it is needed. In this case, when a user visits the '/some-page' route.",
    "anchor": "Introduction",
    "url": "/quasar-cli/lazy-loading"
  },
  {
    "objectID": 302,
    "hierarchy_lvl0": "Lazy Loading - Code Splitting",
    "hierarchy_lvl1": "Lazy Loading / Code Splitting",
    "hierarchy_lvl2": "Lazy-load components",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now let's change this and make the component be loaded on demand only, using dynamic imports: html <script> export default { components: { SomeComponent: () => import('components/SomeComponent'), } } </script>",
    "anchor": "Lazy-load-components",
    "url": "/quasar-cli/lazy-loading"
  },
  {
    "objectID": 303,
    "hierarchy_lvl0": "Lazy Loading - Code Splitting",
    "hierarchy_lvl1": "Lazy Loading / Code Splitting",
    "hierarchy_lvl2": "Lazy-load on the fly",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "One advantage of using dynamic imports as opposed to regular imports is that the import path can be determined at runtime:",
    "anchor": "Lazy-load-on-the-fly",
    "url": "/quasar-cli/lazy-loading"
  },
  {
    "objectID": 304,
    "hierarchy_lvl0": "Lazy Loading - Code Splitting",
    "hierarchy_lvl1": "Lazy Loading / Code Splitting",
    "hierarchy_lvl2": "Caveat for dynamic imports",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "So how can we limit the number of chunks created in this case? The idea is to limit the variable part as much as you can so the matched paths are as few as possible. 1. Add file extension, even if it works without it too. This will create chunks only for that file types. Useful when that folder contains many file types. ```js // bad import('./folder/' + pageName) // much better import('./folder/' + pageName + '.vue') 2. Try to create a folder structure that will limit the files available in that variable path. Make it as specific as possible: js // bad -- makes chunks for any JSON inside ./folder (recursive search) const asset = 'my/jsons/categories.json' import('./folder/' + asset) // good -- makes chunks only for JSONs inside ./folder/my/jsons const asset = 'categories.json' import('./folder/my/jsons/' + asset) ``` 3. Try to import from folders containing only files. Take the previous example and imagine ./folder/my/jsons further contains sub-folders. We made the dynamic import better by specifying a more specific path, but it's still not optimal in this case. Best is to use terminal folders that only contain files, so we limit the number of matched paths. Use Webpack magic comments webpackInclude and webpackExclude to constrain the bundled chunks with a regular expression, for example: js await import( /* webpackInclude: /(ar|en-US|ro)\\.js$/ */ 'quasar/lang/' + langIso ) .then(lang => { Quasar.lang.set(lang.default) }) will result in bundling only the language packs you need for your site/app, instead of bundling all the language packs (more than 40!) which might hamper the performance of the commands quasar dev and quasar build. Remember that the number of matched paths equals to the number of chunks being generated.",
    "anchor": "Caveat-for-dynamic-imports",
    "url": "/quasar-cli/lazy-loading"
  },
  {
    "objectID": 305,
    "hierarchy_lvl0": "Handling Assets",
    "hierarchy_lvl1": "App Handling Assets",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use regular app assets and static assets in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/handling-assets"
  },
  {
    "objectID": 306,
    "hierarchy_lvl0": "Handling Assets",
    "hierarchy_lvl1": "App Handling Assets",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Because logo.png is not JavaScript, when treated as a module dependency, we need to use url-loader and file-loader to process it. Quasar CLI has already configured these webpack loaders for you, so you basically get features such as filename fingerprinting and conditional base64 inlining for free, while being able to use relative/module paths without worrying about deployment. Since these assets may be inlined/copied/renamed during build, they are essentially part of your source code. This is why it is recommended to place Webpack-processed assets inside /src/assets, along side other source files. In fact, you don't even have to put them all in /src/assets: you can organize them based on the module/component using them. For example, you can put each component in its own directory, with its static assets right next to it.",
    "anchor": "Introduction",
    "url": "/quasar-cli/handling-assets"
  },
  {
    "objectID": 307,
    "hierarchy_lvl0": "Handling Assets",
    "hierarchy_lvl1": "App Handling Assets",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Asset Resolving Rules",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Relative URLs, e.g. ./assets/logo.png will be interpreted as a module dependency. They will be replaced with an auto-generated URL based on your Webpack output configuration. URLs prefixed with ~ are treated as a module request, similar to require('some-module/image.png'). You need to use this prefix if you want to leverage Webpack's module resolving configurations. Quasar provides assets Webpack alias out of the box, so it is recommended that you use it like this: <img src=\"~assets/logo.png\">. Notice ~ in front of 'assets'.",
    "anchor": "Asset-Resolving-Rules",
    "url": "/quasar-cli/handling-assets"
  },
  {
    "objectID": 308,
    "hierarchy_lvl0": "Handling Assets",
    "hierarchy_lvl1": "App Handling Assets",
    "hierarchy_lvl2": "Static Assets - /public",
    "hierarchy_lvl3": "Asset Resolving Rules",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar has some smart algorithms behind the curtains which ensure that no matter what you build (SPA, PWA, Cordova, Electron), your statics are correctly referenced if and only if they do not use a relative path.  Assets vs Statics Files in the \"assets\" folder are only included in your build if they have a literal reference in one of your Vue files. Every file and folder from the \"public\" folder are copied into your production build as-is, no matter what.   When not building a SPA/PWA/SSR, then /public/icons/* and /public/favicon.ico will NOT be embedded into your app because they would not serve any purpose. For example, Electron or Cordova apps do not require those files.",
    "anchor": "Static-Assets---%2Fpublic",
    "url": "/quasar-cli/handling-assets"
  },
  {
    "objectID": 309,
    "hierarchy_lvl0": "Handling Assets",
    "hierarchy_lvl1": "App Handling Assets",
    "hierarchy_lvl2": "Vue Binding Requires Statics Only",
    "hierarchy_lvl3": "Asset Resolving Rules",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can force serving static assets by binding src to a value with Vue. Instead of src=\"path/to/image\" use :src=\" 'path/to/image' \" or :src=\"imageSrc\". Please note the usage of single quotes within double quotes on the second code example (spaces have been added to see this visually on the documentation website - normally you would not have the spaces).",
    "anchor": "Vue-Binding-Requires-Statics-Only",
    "url": "/quasar-cli/handling-assets"
  },
  {
    "objectID": 310,
    "hierarchy_lvl0": "Handling Assets",
    "hierarchy_lvl1": "App Handling Assets",
    "hierarchy_lvl2": "Getting Asset Paths in JavaScript",
    "hierarchy_lvl3": "Asset Resolving Rules",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for Webpack to return the correct asset paths, you need to use require('./relative/path/to/file.jpg'), which will get processed by file-loader and returns the resolved URL. For example: Note the above example will include every image under ./bgs/ in the final build. This is because Webpack cannot guess which of them will be used at runtime, so it includes them all.",
    "anchor": "Getting-Asset-Paths-in-JavaScript",
    "url": "/quasar-cli/handling-assets"
  },
  {
    "objectID": 311,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Managing your startup code in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 312,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since you won't be having access to any /main.js file (so that Quasar CLI can seamlessly initialize and build same codebase for SPA/PWA/SSR/Cordova/Electron) Quasar provides an elegant solution to that problem by allowing users to define so-called boot files. In earlier Quasar versions, to run code before the root Vue instance was instantiated, you could alter the /src/main.js file and add any code you needed to execute. There is a major problem with this approach: with a growing project, your main.js file was very likely to get cluttered and challenging to maintain, which breaks with Quasar's concept of encouraging developers to write maintainable and elegant cross-platform applications. With boot files, it is possible to split each of your dependencies into self-contained, easy to maintain files. It is also trivial to disable any of the boot files or even contextually determine which of the boot files get into the build through quasar.conf.js configuration.",
    "anchor": "Introduction",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 313,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "Anatomy of a boot file",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Boot files can also be async: You can wrap the returned function with boot helper to get a better IDE autocomplete experience (through Typescript): Notice we are using the ES6 destructuring assignment. Only assign what you actually need/use. You may ask yourself why we need to export a function. This is actually optional, but before you decide to remove the default export, you need to understand when you need it:",
    "anchor": "Anatomy-of-a-boot-file",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 314,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "When to use boot files",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Boot files fulfill one special purpose: they run code before the App's Vue root component is instantiated while giving you access to certain variables, which is required if you need to initialize a library, interfere with Vue Router, inject Vue prototype or inject the root instance of the Vue app.",
    "anchor": "When-to-use-boot-files",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 315,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "When to use boot files",
    "hierarchy_lvl3": "Examples of appropriate usage of boot files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Where <name> should be exchanged by a suitable name for your boot file. This command creates a new file: /src/boot/<name>.js with the following content: You can also return a Promise:  The default export can be left out of the boot file if you don't need it. These are the cases where you don't need to access the \"app\", \"router\", \"store\" and so on.  You can now add content to that file depending on the intended use of your boot file. Do not forget that your default export needs to be a function. However, you can have as many named exports as you want, should the boot file expose something for later usage. In this case, you can import any of these named exports anywhere in your app. The last step is to tell Quasar to use your new boot file. For this to happen you need to add the file in /quasar.conf.js When building a SSR app, you may want some boot files to run only on the server or only on the client, in which case you can do so like below: In case you want to specify boot files from node_modules, you can do so by prepending the path with ~ (tilde) character: If you want a boot file to be injected into your app only for a specific build type:",
    "anchor": "Examples-of-appropriate-usage-of-boot-files",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 316,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "When to use boot files",
    "hierarchy_lvl3": "Redirecting to another page",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "As it was mentioned in the previous sections, the default export of a boot file can return a Promise. If this Promise gets rejected with an Object that contains a \"url\" property, then Quasar CLI will redirect the user to that URL: Or a simpler equivalent:",
    "anchor": "Redirecting-to-another-page",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 317,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "When to use boot files",
    "hierarchy_lvl3": "Quasar App Flow",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar is initialized (components, directives, plugins, Quasar i18n, Quasar icon sets) Quasar Extras get imported (Roboto font -- if used, icons, animations, ...) Quasar CSS & your app's global CSS are imported App.vue is loaded (not yet being used) Store is imported (if using Vuex Store in src/store) Router is imported (in src/router) Boot files are imported Router default export function executed Boot files get their default export function executed (if on Electron mode) Electron is imported and injected into Vue prototype (if on Cordova mode) Listening for \"deviceready\" event and only then continuing with following steps Instantiating Vue with root component and attaching to DOM",
    "anchor": "Quasar-App-Flow",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 318,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "Examples of boot files",
    "hierarchy_lvl3": "Quasar App Flow",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Examples-of-boot-files",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 319,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "Examples of boot files",
    "hierarchy_lvl3": "vue-i18n",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "vue-i18n",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 320,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "Examples of boot files",
    "hierarchy_lvl3": "Router authentication",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Router-authentication",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 321,
    "hierarchy_lvl0": "Boot Files",
    "hierarchy_lvl1": "Boot files",
    "hierarchy_lvl2": "Accessing data from boot files",
    "hierarchy_lvl3": "Router authentication",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Fortunately, because boot files are just normal JavaScript files you can add as many named exports to your boot file as you want. Let's take the example of Axios. Sometimes you want to access your Axios instance inside your JavaScript files, but you cannot access the root Vue instance. To solve this you can export the Axios instance in your boot file and import it elsewhere. Consider the following boot file for axios: In any JavaScript file, you'll be able to import the axios instance like this. Further reading on syntax: ES6 import, ES6 export.",
    "anchor": "Accessing-data-from-boot-files",
    "url": "/quasar-cli/boot-files"
  },
  {
    "objectID": 322,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to prefetch data and initialize your Vuex store, validate the route and redirect to another page in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 323,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All the above will run before the actual route component is rendered. It is designed to work with all Quasar modes (SPA, PWA, SSR, Cordova, Electron), but it is especially useful for SSR builds.",
    "anchor": "Introduction",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 324,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you use it to pre-fetch data, you are required to use a Vuex Store, so make sure that your project folder has the /src/store folder when you create your project, otherwise generate a new project and copy the store folder contents to your current project.",
    "anchor": "Installation",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 325,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "How PreFetch Helps SSR Mode",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Another concern is that on the client, the same data needs to be available before we mount the client side app - otherwise the client app would render using a different state and the hydration would fail. To address this, the fetched data needs to live outside the view components, in a dedicated data store, or a \"state container\". On the server, we can pre-fetch and fill data into the store before rendering. The client-side store will directly pick up the server state before we mount the app.",
    "anchor": "How-PreFetch-Helps-SSR-Mode",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 326,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "When PreFetch Gets Activated",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Let's take an example in order to understand when the hook is being called. Let's say we have these routes and we've written preFetch hooks for all these components: Now, let's see how the hooks are called when the user visits these routes in the order specified below, one after another.",
    "anchor": "When-PreFetch-Gets-Activated",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 327,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Usage",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 328,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Redirecting Example",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If redirect(false) is called (supported only on client-side!), it aborts the current route navigation. Note that if you use it like this in src/App.vue it will halt the app bootup, which is undesirable. The redirect() method requires a Vue Router location Object.",
    "anchor": "Redirecting-Example",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 329,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Using preFetch to Initialize the Store",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Using-preFetch-to-Initialize-the-Store",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 330,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Store Code Splitting",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now, we can use store.registerModule() to lazy-register this module in a route component's preFetch() hook: Also note that because the module is now a dependency of the route component, it will be moved into the route component's async chunk by Webpack.  Don't forget to use the preserveState: true option for registerModule so we keep the state injected by the server.",
    "anchor": "Store-Code-Splitting",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 331,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Usage with TypeScript",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use preFetch helper to type-hint the store parameter (which will otherwise have an any type):  This is useful only to type store parameter, other parameters are automatically typed even when using the normal syntax.",
    "anchor": "Usage-with-TypeScript",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 332,
    "hierarchy_lvl0": "Prefetch Feature",
    "hierarchy_lvl1": "PreFetch Feature",
    "hierarchy_lvl2": "Loading State",
    "hierarchy_lvl3": "Usage with TypeScript",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Loading-State",
    "url": "/quasar-cli/prefetch-feature"
  },
  {
    "objectID": 333,
    "hierarchy_lvl0": "API Proxying",
    "hierarchy_lvl1": "API Proxying for Dev",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use an API proxy with the Quasar dev server.",
    "anchor": "Introduction",
    "url": "/quasar-cli/api-proxying"
  },
  {
    "objectID": 334,
    "hierarchy_lvl0": "API Proxying",
    "hierarchy_lvl1": "API Proxying for Dev",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To configure the proxy rules, edit /quasar.conf.js in devServer.proxy. You should refer to Webpack Dev Server Proxy docs for detailed usage. But here's a simple example: The above example will proxy the request /api/posts/1 to http://some.api.target.com:7070/posts/1.",
    "anchor": "Introduction",
    "url": "/quasar-cli/api-proxying"
  },
  {
    "objectID": 335,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage Webpack in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 336,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example of adding ESLint loader to Webpack (assuming you've installed it): Notice that you don't need to return anything. The parameter of extendWebpack(cfg) is the Webpack configuration Object generated by Quasar for you. You can add/remove/replace anything from it, assuming you really know what you are doing. Equivalent quasar.conf for chainWebpack(): js // quasar.conf.js build: { chainWebpack (chain, { isServer, isClient }) { chain.module.rule('eslint') .test(/\\.(js|vue)$/) .enforce('pre') .exclude .add((/[\\\\/]node_modules[\\\\/]/)) .end() .use('eslint-loader') .loader('eslint-loader') } }  The method chainWebpack() supplies a webpack-chain Object. You might want to check its documentation page.   chainWebpack() gets executed before extendWebpack(). The two examples above are equivalent. Do NOT use both methods to tamper for the same thing!",
    "anchor": "Introduction",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 337,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Inspecting Webpack Config",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Inspecting-Webpack-Config",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 338,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Webpack Aliases",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Also if you configure to build with the Vue compiler version (quasar.conf > build > vueCompiler: true), vue$ resolves to vue/dist/vue.esm.js.",
    "anchor": "Webpack-Aliases",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 339,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Webpack Aliases",
    "hierarchy_lvl3": "Adding Webpack aliases",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To add your own alias you can extend the webpack config and merge it with the existing alias. Use the path.resolve helper to resolve the path to your intended alias. Equivalent with chainWebpack(): ```js // quasar.conf.js const path = require('path') module.exports = function (ctx) { return { build: { chainWebpack (chain, { isServer, isClient }) { chain.resolve.alias .set('myalias', path.resolve(__dirname, './src/somefolder')) } } } } ```",
    "anchor": "Adding-Webpack-aliases",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 340,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Webpack loaders",
    "hierarchy_lvl3": "Adding Webpack aliases",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "So, you need a loader for it. You search Google to see what webpack loader you need. In this case, it's \"json-loader\". We first install it: After installing your new loader, we want to tell Webpack to use it. So we edit /quasar.conf.js and change build.extendWebpack() to add entries to module/rules for this new loader: Equivalent with chainWebpack(): And you're done.",
    "anchor": "Webpack-loaders",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 341,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Webpack loaders",
    "hierarchy_lvl3": "PostCSS",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Styles in *.vue files (and all other style files) are piped through PostCSS by default, so you don't need to use a specific loader for it. By default, PostCSS is configured to use Autoprefixer. Take a look at /.postcssrc.js where you can tweak it if you need to.",
    "anchor": "PostCSS",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 342,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Webpack loaders",
    "hierarchy_lvl3": "Pug",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Then you need to extend the webpack configuration through quasar.conf.js: js // quasar.conf.js build: { extendWebpack (cfg) { cfg.module.rules.push({ test: /\\.pug$/, loader: 'pug-plain-loader' }) } } Equivalent with chainWebpack(): js // quasar.conf.js build: { chainWebpack (chain) { chain.module.rule('pug') .test(/\\.pug$/) .use('pug-plain-loader') .loader('pug-plain-loader') } }",
    "anchor": "Pug",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 343,
    "hierarchy_lvl0": "Handling Webpack",
    "hierarchy_lvl1": "Handling Webpack",
    "hierarchy_lvl2": "Webpack loaders",
    "hierarchy_lvl3": "Coffeescript",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note that vue-loader uses lang=\"coffee\" to identify components which are using Coffeescript, but lang=\"coffee\" is not recognizable for ESLint. Fortunately, ESLint (following traditional HTML) uses type=\"xxx\" to identify the type of scripts. As long as a <script> tag has any type other than javascript, ESLint would mark the script as non-javascript, and skips linting it. Coffeescript's convention is to use type=\"text/coffeescript\" to identify itself. Therefore, in your Vue components which are using Coffeescript, using both lang and type to avoid ESLint warnings:",
    "anchor": "Coffeescript",
    "url": "/quasar-cli/handling-webpack"
  },
  {
    "objectID": 344,
    "hierarchy_lvl0": "Handling process.env",
    "hierarchy_lvl1": "Handling process.env",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to differentiate the runtime procedure based on process.env in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/handling-process-env"
  },
  {
    "objectID": 345,
    "hierarchy_lvl0": "Handling process.env",
    "hierarchy_lvl1": "Handling process.env",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-cli/handling-process-env"
  },
  {
    "objectID": 346,
    "hierarchy_lvl0": "Handling process.env",
    "hierarchy_lvl1": "Handling process.env",
    "hierarchy_lvl2": "Example",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Example",
    "url": "/quasar-cli/handling-process-env"
  },
  {
    "objectID": 347,
    "hierarchy_lvl0": "Handling process.env",
    "hierarchy_lvl1": "Handling process.env",
    "hierarchy_lvl2": "Stripping out code",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When compiling your website/app, if () branches depending on process.env are evaluated and if the expression is false then they get stripped out of the file. Example: Notice above that the ifs are evaluated and also completely stripped out at compile-time, resulting in a smaller bundle.",
    "anchor": "Stripping-out-code",
    "url": "/quasar-cli/handling-process-env"
  },
  {
    "objectID": 348,
    "hierarchy_lvl0": "Handling process.env",
    "hierarchy_lvl1": "Handling process.env",
    "hierarchy_lvl2": "Import based on process.env",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can combine what you learned in the section above with dynamic imports:",
    "anchor": "Import-based-on-process.env",
    "url": "/quasar-cli/handling-process-env"
  },
  {
    "objectID": 349,
    "hierarchy_lvl0": "Handling process.env",
    "hierarchy_lvl1": "Handling process.env",
    "hierarchy_lvl2": "Adding to process.env",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can add your own definitions to process.env through /quasar.conf.js file: Then in your website/app you can access process.env.API and it's gonna point to one of those two links above, based on dev or production build type. You can even go one step further. Supply it with values taken from the quasar dev/build env variables: Alternatively you can use our @quasar/dotenv or @quasar/qenv App Extensions.",
    "anchor": "Adding-to-process.env",
    "url": "/quasar-cli/handling-process-env"
  },
  {
    "objectID": 350,
    "hierarchy_lvl0": "Vuex Store",
    "hierarchy_lvl1": "App Vuex Store",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the Vuex Store in a Quasar App.",
    "anchor": "Introduction",
    "url": "/quasar-cli/vuex-store"
  },
  {
    "objectID": 351,
    "hierarchy_lvl0": "Vuex Store",
    "hierarchy_lvl1": "App Vuex Store",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We won't go into details on how to configure or use Vuex since it has great docs. Instead we'll just show you what the folder structure looks like when using it on a Quasar project. By default, if you choose to use Vuex when you create a project folder with Quasar CLI, it will set you up on using Vuex modules. Each sub-folder of /src/store represents a Vuex Module. If you don't choose the Vuex option during project creation but would like to add it later then all you need to do is to check the next section and create the src/store/index.js file.  If Vuex Modules is too much for your website app, you can change /src/store/index.js and avoid importing any module.",
    "anchor": "Introduction",
    "url": "/quasar-cli/vuex-store"
  },
  {
    "objectID": 352,
    "hierarchy_lvl0": "Vuex Store",
    "hierarchy_lvl1": "App Vuex Store",
    "hierarchy_lvl2": "Adding a Vuex Module.",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It will create a folder in /src/store named by \"store_name\" from the command above. It will contain all the boilerplate that you need. Let's say that you want to create a \"showcase\" Vuex Module. You issue $ quasar new store showcase. You then notice the newly created /src/store/showcase folder, which holds the following files: We've created the new Vuex Module, but we haven't yet informed Vuex to use it. So we edit /src/store/index.js and add a reference to it: Now we can use this Vuex Module in our Vue files. Here is a quick example. Assume we configured drawerState in the state and added updateDrawerState mutation. In a Vue file:",
    "anchor": "Adding-a-Vuex-Module.",
    "url": "/quasar-cli/vuex-store"
  },
  {
    "objectID": 353,
    "hierarchy_lvl0": "Linter",
    "hierarchy_lvl1": "App Linter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure a code linter in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/linter"
  },
  {
    "objectID": 354,
    "hierarchy_lvl0": "Linter",
    "hierarchy_lvl1": "App Linter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Standard Airbnb Prettier .. or you can configure one yourself Two dot files will be created: * .eslintrc.js -- ESLint configuration, including rules * .eslintignore -- what ESLint should ignore when linting Further extension of one of the Eslint setups above can be made. Your project will by default use eslint-plugin-vue to handle your Vue files. Take a quick look at .eslintrc.js and notice it: If you chose ESLint when creating your project folder, you'll also notice that /quasar.conf.js adds the eslint-loader to Webpack configuration for you:",
    "anchor": "Introduction",
    "url": "/quasar-cli/linter"
  },
  {
    "objectID": 355,
    "hierarchy_lvl0": "Linter",
    "hierarchy_lvl1": "App Linter",
    "hierarchy_lvl2": "Lint Rules",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can add/remove/change rules by first visiting https://eslint.org/docs/rules/ or https://github.com/vuejs/eslint-plugin-vue. Example of ESLint rules below: ```js // .eslintrc.js 'rules': { 'brace-style': [2, 'stroustrup', { 'allowSingleLine': true }], 'vue/max-attributes-per-line': 0, 'vue/valid-v-for': 0, // allow async-await 'generator-star-spacing': 'off', // allow paren-less arrow functions 'arrow-parens': 0, 'one-var': 0, 'import/first': 0, 'import/named': 2, 'import/namespace': 2, 'import/default': 2, 'import/export': 2, 'import/extensions': 0, 'import/no-unresolved': 0, 'import/no-extraneous-dependencies': 0, // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0 } ```",
    "anchor": "Lint-Rules",
    "url": "/quasar-cli/linter"
  },
  {
    "objectID": 356,
    "hierarchy_lvl0": "Linter",
    "hierarchy_lvl1": "App Linter",
    "hierarchy_lvl2": "Disabling Linter",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Disabling-Linter",
    "url": "/quasar-cli/linter"
  },
  {
    "objectID": 357,
    "hierarchy_lvl0": "Testing & Auditing",
    "hierarchy_lvl1": "Testing & Auditing",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to unit and end to end test a Quasar app and also how to audit for quality and security.",
    "anchor": "Introduction",
    "url": "/quasar-cli/testing-and-auditing"
  },
  {
    "objectID": 358,
    "hierarchy_lvl0": "Testing & Auditing",
    "hierarchy_lvl1": "Testing & Auditing",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can install multiple pre-rigged testing harnesses to your existing 1.0+ Quasar application by running a simple command. This command will pull and install a node module (with dependencies) into your project's package.json, place necessary configuration files as appropriate and if you so choose, it will also add script commands that expose some of the functionality of the respective harness. You can add multiple harnesses and even use them for your continuous integration pipelines - as appropriate. Testing is not in and of itself hard. The most complicated part is setting up the testing harness. The trick lies in knowing what to test. If you are new to testing, it is absolutely imperative that you familiarize yourself with some of the concepts and patterns. There are some links for further reading at the end of this document page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/testing-and-auditing"
  },
  {
    "objectID": 359,
    "hierarchy_lvl0": "Testing & Auditing",
    "hierarchy_lvl1": "Testing & Auditing",
    "hierarchy_lvl2": "Testing documentation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Testing has its own documentation website (https://testing.quasar.dev), so head there for full info.",
    "anchor": "Testing-documentation",
    "url": "/quasar-cli/testing-and-auditing"
  },
  {
    "objectID": 360,
    "hierarchy_lvl0": "Testing & Auditing",
    "hierarchy_lvl1": "Testing & Auditing",
    "hierarchy_lvl2": "Installing",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The lightweight extension installer will ask you which testing harnesses you want to install. Then it will install the respective extensions for these harnesses, which you can configure as you like. It is how multiple testing harnesses are ideally managed within a Quasar project. It will provide you with a new quasar run command that you can use to execute test-runners - and even your HMR dev environment at the same time. This approach can, for example, be quite helpful if you need to pass quasar.ctx to the test runner... If you ever need to review your choices you can take a look at quasar.extensions.json. If you don't want to install the base package, you don't have to do so. You can install each test harness app extension individually. They are completely standalone, but you won't have the tight integration with the quasar test command functionality.",
    "anchor": "Installing",
    "url": "/quasar-cli/testing-and-auditing"
  },
  {
    "objectID": 361,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is SPA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction on what a Single Page App is.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/introduction"
  },
  {
    "objectID": 362,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is SPA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In a SPA the appropriate resources are dynamically loaded and added to the page as necessary, usually in response to user actions. The page does not reload at any point in the process, nor does control transfer to another page, although the location hash or the HTML5 History API (using one or the other based on your Vue Router mode in quasar.conf.js) can be used to provide the perception and navigability of separate logical pages in the application. Interaction with the single page application often involves dynamic communication with the web server behind the scenes.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/introduction"
  },
  {
    "objectID": 363,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "App Icons for SPA",
    "hierarchy_lvl2": "App Icons for SPA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Quasar Single Page Application.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/app-icons-spa"
  },
  {
    "objectID": 364,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "App Icons for SPA",
    "hierarchy_lvl2": "App Icons for SPA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/app-icons-spa"
  },
  {
    "objectID": 365,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "App Icons for SPA",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The required HTML code that goes into /src/index.template.html to reference the above files:",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-spa/app-icons-spa"
  },
  {
    "objectID": 366,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "SPA Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a single page application.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/build-commands"
  },
  {
    "objectID": 367,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "SPA Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Building for Production: bash $ quasar build If you want a production build with debugging enabled:",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/build-commands"
  },
  {
    "objectID": 368,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying a SPA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to publish a Single Page App built by Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 369,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying a SPA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If your favorite deployment tool is missing feel free to create a pull request on GitHub to add it to the list.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 370,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "General deployment",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The first step in deploying your Quasar SPA is always to build a production-ready bundle of your files, which gets rid of development statements and minifies your source. To produce such a build use Quasar CLI with the following command bash $ quasar build This command will build your project in SPA mode and output your production ready bundle to a newly created folder /dist/spa. To serve your production files it is required to use a web server, so to serve over http(s):// protocol. Simply opening the index.html file from within your browser will not work, since this uses the file:// protocol instead. Common choices for web servers are nginx, Caddy, Apache, Express; but you should be able to use whatever web server you want. The web server requires no special setup (unless you built with Vue Router in \"history\" mode in quasar.conf.js). The main requirement is to be able to serve static files from a directory, so consult the documentation of your web server on how to set up static file serving. An example config for nginx may look like this:",
    "anchor": "General-deployment",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 371,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Important Hosting Configuration",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It's important that you do not allow browsers to cache the index.html file. Because otherwise updates to this file or to your app might slip through the cracks for browsers that load the index.html from cache. This is why you must always make sure to add \"Cache-Control\": \"no-cache\" to the headers of the index.html file via your hosting service. As an example how this is done for Google Firebase, you would add the following to the firebase.json configuration:",
    "anchor": "Important-Hosting-Configuration",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 372,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying with Vercel",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Then proceed to build your Quasar application using the steps described in \"General deployment\" section. After the build is finished, change directory into your deploy root (example: /dist/spa) and run: bash # from /dist/spa (or your distDir) $ vercel The Vercel CLI should now display information regarding your deployment, like the URL. That's it. You're done.",
    "anchor": "Deploying-with-Vercel",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 373,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying with Vercel",
    "hierarchy_lvl3": "Vercel configuration tips",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since Vercel expects the build script to be defined, you may add in package.json the following scripts: json { .. \"scripts\": { ... \"build\": \"quasar build\", \"deploy\": \"vercel\" } } Since Vercel expects the build results to be in /public directory, and Quasar has it in /dist/spa by default, consider updating quasar.conf.js accordingly: js module.exports = function (ctx) { return { ... build: { ... distDir: ctx.mode.spa ? 'public' : null, } In order to support SPA routing in the deployed app, consider adding vercel.json file in your root folder: json { \"routes\": [ { \"handle\": \"filesystem\" }, { \"src\": \"/.*\", \"dest\": \"/index.html\" } ] } ## Deploying with Heroku Unfortunately, Heroku does not support static sites out of the box. But don't worry, we just need to add an HTTP server to our project so Heroku can serve our Quasar application. In this example, we will use Express to create a minimal server which Heroku can use. First, we need to install the required dependencies to our project: bash $ yarn add express serve-static connect-history-api-fallback Now that we have installed the required dependencies, we can add our server. Create a file called server.js in the root directory of your project. ```js const express = require('express'), serveStatic = require('serve-static'), history = require('connect-history-api-fallback'), port = process.env.PORT || 5000 const app = express() app.use(history()) app.use(serveStatic(__dirname + '/dist/spa')) app.listen(port) ``` Heroku assumes a set of npm scripts to be available, so we have to alter our package.json and add the following under the script section: js \"build\": \"quasar build\", \"start\": \"node server.js\", \"heroku-postbuild\": \"yarn && yarn build\" Now it is time to create an app on Heroku by running: bash $ heroku create and deploy to Heroku using: bash $ heroku deploy",
    "anchor": "Vercel-configuration-tips",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 374,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying with Surge",
    "hierarchy_lvl3": "Vercel configuration tips",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Surge is a popular tool to host and deploy static sites. If you want to deploy your application with Surge you first need to install the Surge CLI tool: bash $ npm install -g surge Next, we will use Quasar CLI to build our app: bash $ quasar build Now we can deploy our application using Surge by calling: bash $ surge dist/spa Now your application should be successfully deployed using Surge. You should be able to adapt this guide to any other static site deployment tool.",
    "anchor": "Deploying-with-Surge",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 375,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying on GitHub Pages",
    "hierarchy_lvl3": "Vercel configuration tips",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To deploy your Quasar application to GitHub pages the first step is to create a special repository on GitHub which is named <username>.github.io. Clone this repository to your local machine. Next, you need to build your Quasar application like it is described in the \"General deployment section\". This will result in a /dist/spa directory. Copy the content of this folder to your cloned repository. The last step is to add a commit in your repository and push to GitHub. After a short time, you should be able to visit your Quasar application at https://<username>.github.io/.",
    "anchor": "Deploying-on-GitHub-Pages",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 376,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying on GitHub Pages",
    "hierarchy_lvl3": "Adding a custom domain to GitHub pages",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please see the GitHub pages guides for an in-depth explanation on how to set up a custom domain.",
    "anchor": "Adding-a-custom-domain-to-GitHub-pages",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 377,
    "hierarchy_lvl0": "Developing SPA",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying on GitHub Pages",
    "hierarchy_lvl3": "Automated deployment to GitHub pages with push-dir",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Manual copying all your files to your GitHub Pages repository can be a cumbersome task to do. This step can be automated by using the push-dir package. First, install the package with: js $ yarn add --dev push-dir Then add a deploy script command to your package.json: json \"scripts\": { \"deploy\": \"push-dir --dir=dist/spa --remote=gh-pages --branch=master\" } Add your GitHub Pages repository as a remote named gh-pages: bash $ git remote add gh-pages git@github.com:<username>/<username>.github.io.git Now you can build and deploy your application using: bash $ quasar build $ yarn deploy which will push the content of your build directory to your master branch on your GitHub Pages repository.",
    "anchor": "Automated-deployment-to-GitHub-pages-with-push-dir",
    "url": "/quasar-cli/developing-spa/deploying"
  },
  {
    "objectID": 378,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction on server-side rendered apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/introduction"
  },
  {
    "objectID": 379,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A server-rendered Quasar app can also be considered isomorphic or universal, in the sense that the majority of your app's code runs on both the server and the client.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/introduction"
  },
  {
    "objectID": 380,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Why SSR?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Better SEO, as the search engine crawlers will directly see the fully rendered page. Faster time-to-content, especially on slow internet or slow devices. Server-rendered markup doesn't need to wait until all JavaScript has been downloaded and executed to be displayed, so your user will see a fully-rendered page sooner. This generally results in better user experience, and can be critical for applications where time-to-content is directly associated with conversion rate. There are also some trade-offs to consider when using SSR: Development constraints. Browser-specific code can only be used inside certain lifecycle hooks; some external libraries may need special treatment to be able to run in a server-rendered app. More server-side load. Rendering a full app in Node.js is obviously going to be more CPU-intensive than just serving static files, so if you expect high traffic, be prepared for corresponding server load and wisely employ caching strategies. Before using SSR for your app, the first question you should ask is whether you actually need it. It mostly depends on how important time-to-content is for your app. For example, if you are building an internal dashboard where an extra few hundred milliseconds on initial load doesn't matter that much, SSR would be an overkill. However, in cases where time-to-content is absolutely critical, SSR can help you achieve the best possible initial load performance. Parts of this page are taken from the official Vue.js SSR guide.",
    "anchor": "Why-SSR%3F",
    "url": "/quasar-cli/developing-ssr/introduction"
  },
  {
    "objectID": 381,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Writing Universal Code",
    "hierarchy_lvl2": "Writing Universal Code",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Guide on how to write code for a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/writing-universal-code"
  },
  {
    "objectID": 382,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Writing Universal Code",
    "hierarchy_lvl2": "Writing Universal Code",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/writing-universal-code"
  },
  {
    "objectID": 383,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Writing Universal Code",
    "hierarchy_lvl2": "Data Reactivity on the Server",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Because the actual rendering process needs to be deterministic, we will also be \"pre-fetching\" data on the server - this means our application state will be already resolved when we start rendering. This means data reactivity is unnecessary on the server, so it is disabled by default. Disabling data reactivity also avoids the performance cost of converting data into reactive objects.",
    "anchor": "Data-Reactivity-on-the-Server",
    "url": "/quasar-cli/developing-ssr/writing-universal-code"
  },
  {
    "objectID": 384,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Writing Universal Code",
    "hierarchy_lvl2": "Component Lifecycle Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Another thing to note is that you should avoid code that produces global side effects in beforeCreate and created, for example setting up timers with setInterval. In client-side only code we may setup a timer and then tear it down in beforeUnmount or destroyed. However, because the destroy hooks will not be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into beforeMount or mounted instead.",
    "anchor": "Component-Lifecycle-Hooks",
    "url": "/quasar-cli/developing-ssr/writing-universal-code"
  },
  {
    "objectID": 385,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Writing Universal Code",
    "hierarchy_lvl2": "Avoid Stateful Singletons",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "So, Quasar CLI creates a new root Vue instance with a new Router and Vuex Store instances for each request. This is similar to how each user will be using a fresh instance of the app in their own browser. If we would have used a shared instance across multiple requests, it will easily lead to cross-request state pollution. Instead of directly creating a Router and Vuex Store instances, you'll be exposing a factory function that can be repeatedly executed to create fresh app instances for each request: If you're using Vuex modules don't forget to export the state as a function otherwise a singleton will be created: ```js // src/store/myModule/state.js export default () => ({ ... })",
    "anchor": "Avoid-Stateful-Singletons",
    "url": "/quasar-cli/developing-ssr/writing-universal-code"
  },
  {
    "objectID": 386,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Writing Universal Code",
    "hierarchy_lvl2": "Data Pre-Fetching and State",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI PreFetch Feature has been created to solve this problem. Take a few moments to read about it. Parts of this page are taken from the official Vue.js SSR guide.",
    "anchor": "Data-Pre-Fetching-and-State",
    "url": "/quasar-cli/developing-ssr/writing-universal-code"
  },
  {
    "objectID": 387,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to add SSR mode with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/preparation"
  },
  {
    "objectID": 388,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order to develop or build a SSR website, we first need to add the SSR mode to our Quasar project: bash $ quasar mode add ssr If you want to jump right in and start developing, you can skip the \"quasar mode\" command and issue: bash $ quasar dev -m ssr This will add SSR mode automatically, if it is missing. A new folder will appear in your project folder (which is explained in detail on the Configuring SSR page):",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/preparation"
  },
  {
    "objectID": 389,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Configuring SSR",
    "hierarchy_lvl2": "Configuring SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage your server-side rendered apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/configuring-ssr"
  },
  {
    "objectID": 390,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Configuring SSR",
    "hierarchy_lvl2": "Configuring SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you decide to go with a PWA client takeover (which is a killer combo), the Quasar CLI PWA mode will be installed too. You may want to check out the Quasar PWA guide too. But most importantly, make sure you read SSR with PWA page. When building, extendWebpack() and chainWebpack() will receive one more parameter (Object), currently containing isServer or isClient boolean props, because there will be two Webpack builds (one for the server-side and one for the client-side). If you want more information, please see this page that goes into more detail about handling webpack in the quasar.conf.js file.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/configuring-ssr"
  },
  {
    "objectID": 391,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Configuring SSR",
    "hierarchy_lvl2": "Nodejs Server",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can freely edit these files. You're not required to use an Express server. Simply choose whatever fits you best and tweak however you want. Notice a few things: These files run in a Node context (they are NOT transpiled by Babel), so use only the ES6 features that are supported by your Node version. (https://node.green/) If you import anything from node_modules, then make sure that the package is specified in package.json > dependencies and NOT in devDependencies. Do not change the names of these two files. You can however add any additional files that you may need. Just take into consideration that if you want common configuration of the Node webserver for both production & development, you need to add that to /src-ssr/extension.js file. When /src-ssr/extension.js is used by the development server, it assumes the configuration is ready to be used by an Express server. So plan accordingly. If you switch to another server, you may want to decouple extension.js from the production server (index.js). The /src-ssr is built through a Webpack config for production (only). You will see this marked as \"Webserver\" when Quasar App CLI builds your app. You can chain/extend the Webpack configuration of these files through quasar.conf.js:",
    "anchor": "Nodejs-Server",
    "url": "/quasar-cli/developing-ssr/configuring-ssr"
  },
  {
    "objectID": 392,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Configuring SSR",
    "hierarchy_lvl2": "Helping SEO",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, there are cases where you only want some boot files to run only on the server or only on the client-side. You can achieve that by specifying: Just make sure that your app is consistent, though. When a boot file runs on the server, you will have access to one more parameter (called ssrContext) on the default exported function: When you add such references (someProp surrounded by brackets in the example above) into your src/index.template.html, make sure you tell Quasar it’s only valid for SSR builds:",
    "anchor": "Helping-SEO",
    "url": "/quasar-cli/developing-ssr/configuring-ssr"
  },
  {
    "objectID": 393,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "App Icons for SSR",
    "hierarchy_lvl2": "App Icons for SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/app-icons-ssr"
  },
  {
    "objectID": 394,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "App Icons for SSR",
    "hierarchy_lvl2": "App Icons for SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/app-icons-ssr"
  },
  {
    "objectID": 395,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "App Icons for SSR",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The required HTML code that goes into /src/index.template.html to reference the above files: However, if you are developing with SSR + PWA mode, then you'll also need the PWA assets: And the corresponding HTML code to go into /src/index.template.html file (notice not all files need to be manually referenced as Quasar CLI automatically injects the other ones):",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-ssr/app-icons-ssr"
  },
  {
    "objectID": 396,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "SEO for SSR",
    "hierarchy_lvl2": "SEO for SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Managing the search engine optimizations in a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/seo-for-ssr"
  },
  {
    "objectID": 397,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "SEO for SSR",
    "hierarchy_lvl2": "SEO for SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar Meta Plugin can dynamically change page title, manage <meta> tags, manage <html> and <body> DOM element attributes, add/remove/change <style> and <script> tags in the head of your document (useful for CDN stylesheets or for json-ld markup, for example), or manage <noscript> tags.  This Quasar plugin has the most tight integration with Quasar and so it has the best performance against any other similar solution.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/seo-for-ssr"
  },
  {
    "objectID": 398,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Client Side Hydration",
    "hierarchy_lvl2": "Client Side Hydration",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What hydration is and its caveats in a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/client-side-hydration"
  },
  {
    "objectID": 399,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Client Side Hydration",
    "hierarchy_lvl2": "Client Side Hydration",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In development mode, Vue will assert the client-side generated virtual DOM tree matches the DOM structure rendered from the server. If there is a mismatch, it will bail hydration, discard existing DOM and render from scratch. In production mode, this assertion is disabled for maximum performance.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/client-side-hydration"
  },
  {
    "objectID": 400,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Client Side Hydration",
    "hierarchy_lvl2": "Hydration Caveats",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The browser will automatically inject <tbody> inside <table>, however, the virtual DOM generated by Vue does not contain <tbody>, so it will cause a mismatch. To ensure correct matching, make sure to write valid HTML in your templates.",
    "anchor": "Hydration-Caveats",
    "url": "/quasar-cli/developing-ssr/client-side-hydration"
  },
  {
    "objectID": 401,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Client Side Hydration",
    "hierarchy_lvl2": "Handling Hydration Errors",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you do receive hydration errors (as seen in console: \"Vuejs Error - The client-side rendered virtual DOM tree is not matching server-rendered content\"), you can try following these steps: 1. Show DevTools in Chrome (F12) 2. Load the page that causes \"the client-side rendered virtual DOM tree...\" warning. 3. Scroll to the warning in DevTools console. 4. Click at the source location hyperlink of the warning in vue.runtime.esm.js. 5. Set a breakpoint there (left-clicking at line number in the source code browser). 6. Make the same warning appear again. Usually by reloading the page. If there are many warnings, you can check the message by moving a mouse over msg variable. 7. When you have found your message and stopped on a breakpoint, look at the call stack. Click one frame down to call to \"patch\" to open its source. Hover mouse over hydrate function call 4 lines above the execution line in patch. Hyperlink to the source of hydrate would open. 8. In the hydrate function, move about 15 lines from the start and set a breakpoint where false is returned after assertNodeMatch returned false. Set the breakpoint there and remove all other breakpoints. 9. Make the same warning happen again. Now, when breakpoint is hit, execution should stop in the hydrate function. Switch to DevTools console and evaluate elm and then vnode. Here elm seems to be a server-rendered DOM element while vnode is a virtual DOM node. Elm is printed as HTML so you can figure out where the error happened.",
    "anchor": "Handling-Hydration-Errors",
    "url": "/quasar-cli/developing-ssr/client-side-hydration"
  },
  {
    "objectID": 402,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Handling 404 and 500 Errors",
    "hierarchy_lvl2": "SSR Handling of 404 and 500 Errors",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Managing the common 404 and 500 HTTP errors in a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/handling-404-and-500-errors"
  },
  {
    "objectID": 403,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Handling 404 and 500 Errors",
    "hierarchy_lvl2": "SSR Handling of 404 and 500 Errors",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The section above is written after catching the other possible requests (like for /public folder, the manifest.json and service worker, etc). This is where we initialize your app, along with your Router and Vue gets to render the requested page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/handling-404-and-500-errors"
  },
  {
    "objectID": 404,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Handling 404 and 500 Errors",
    "hierarchy_lvl2": "Things to be aware of",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Things-to-be-aware-of",
    "url": "/quasar-cli/developing-ssr/handling-404-and-500-errors"
  },
  {
    "objectID": 405,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Handling 404 and 500 Errors",
    "hierarchy_lvl2": "Things to be aware of",
    "hierarchy_lvl3": "Error 500",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Add a specific route in /src/router/routes.js, like: js { path: 'error500', component: () => import('pages/Error500.vue') } Write the Vue component to handle this page. In this example, we create /src/pages/Error500.vue Then in /src-ssr/index.js: js if (err.url) { ... } else if (err.code === 404) { ... } else { // We got a 500 error here; // We redirect to our \"error500\" route newly defined at step #1. res.redirect('/error500') // keep account of publicPath though! }  The only caveat is that you need to be sure that while rendering '/error500' route you don't get another 500 error, which would put your app into an infinite loop!  A perfect approach to avoid this would simply be to directly return the HTML (as String) of the error 500 page from /src-ssr/index.js:",
    "anchor": "Error-500",
    "url": "/quasar-cli/developing-ssr/handling-404-and-500-errors"
  },
  {
    "objectID": 406,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "SSR with PWA",
    "hierarchy_lvl2": "SSR with PWA Client Takeover",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure your Quasar server-side rendered app to become a Progressive Web App on the client side.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/ssr-with-pwa"
  },
  {
    "objectID": 407,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "SSR with PWA",
    "hierarchy_lvl2": "SSR with PWA Client Takeover",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The first request of a new client will be served from the webserver (so SSR supplies the initial page content). The PWA gets installed then it takes over on client side. All further requests will be served from cache (unless you have some custom configuration to change that). For more information on PWA, head on to PWA Introduction and read the whole PWA Guide section.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/ssr-with-pwa"
  },
  {
    "objectID": 408,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "SSR Frequently Asked Questions",
    "hierarchy_lvl2": "SSR FAQ",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks for a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/ssr-frequently-asked-questions"
  },
  {
    "objectID": 409,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "SSR Frequently Asked Questions",
    "hierarchy_lvl2": "SSR FAQ",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The ssrContext is available in the Boot Files or the PreFetch Feature, where it is supplied as a parameter. There is a good reason for this. In a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same thing. Each request should have a fresh, isolated app instance so that there is no cross-request state pollution. So Platform and Cookies need to be bound to each request separately. Also a good idea is to read the Writing Universal Code documentation page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/ssr-frequently-asked-questions"
  },
  {
    "objectID": 410,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "SSR Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/build-commands"
  },
  {
    "objectID": 411,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "SSR Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want a production build with debugging enabled:",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/build-commands"
  },
  {
    "objectID": 412,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to publish a Quasar server-side rendered app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/deploying"
  },
  {
    "objectID": 413,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying SSR",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll notice that it contains a package.json file of its own. It has an npm script defined, called \"start\": So what you need to do when deploying is to copy this distributables folder on your server, yarn/npm install the dependencies inside it, then run $ yarn start. This boots up the webserver and starts listening for connections.  The distributables folder generated after building your app is standalone. It does NOT require the rest of your project folder to work and it does NOT depend on @quasar/cli being installed.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-ssr/deploying"
  },
  {
    "objectID": 414,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Enhancing Performance",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "After installing PM2 on your server, your npm start script can look like this instead: js \"scripts\": { \"start\": \"pm2 start index.js\" }",
    "anchor": "Enhancing-Performance",
    "url": "/quasar-cli/developing-ssr/deploying"
  },
  {
    "objectID": 415,
    "hierarchy_lvl0": "Developing SSR",
    "hierarchy_lvl1": "Deploying",
    "hierarchy_lvl2": "Deploying with Cleavr",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Add a new NodeJS SSR site to Cleavr and then configure the web app settings with the following: Entry point: index.js Build command: npx quasar build --mode ssr Artifact path: dist/ssr",
    "anchor": "Deploying-with-Cleavr",
    "url": "/quasar-cli/developing-ssr/deploying"
  },
  {
    "objectID": 416,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is a PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction on what a Progressive Web App is and how it can be configured in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/introduction"
  },
  {
    "objectID": 417,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is a PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More information available on Addy Osmani's article about PWA.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/introduction"
  },
  {
    "objectID": 418,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Manifest File",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More information: Manifest file.",
    "anchor": "Manifest-File",
    "url": "/quasar-cli/developing-pwa/introduction"
  },
  {
    "objectID": 419,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Service Worker",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More information: Service Worker API.",
    "anchor": "Service-Worker",
    "url": "/quasar-cli/developing-pwa/introduction"
  },
  {
    "objectID": 420,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to add PWA mode with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/preparation"
  },
  {
    "objectID": 421,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want to jump right in and start developing, you can skip the \"quasar mode\" command and issue: This will add PWA mode automatically, if it is missing. A new folder will appear in your project folder (which is explained in detail on the Configuring PWA page):",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/preparation"
  },
  {
    "objectID": 422,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "PWA Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a Progressive Web App.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/build-commands"
  },
  {
    "objectID": 423,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "PWA Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not miss the HMR for PWA (Hot Module Reload) page.   Do not run Lighthouse on your development build because at this stage the code is intentionally not optimized and contains embedded source maps (among many other things).",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/build-commands"
  },
  {
    "objectID": 424,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want a production build with debugging enabled:",
    "anchor": "Building-for-Production",
    "url": "/quasar-cli/developing-pwa/build-commands"
  },
  {
    "objectID": 425,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Configuring PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage your Progressive Web Apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 426,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Configuring PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can freely edit these files. Notice a few things: register-service-worker.js is automatically imported into your app (like any other /src file). It registers the service worker (created by Workbox or your custom one, depending on workbox plugin mode -- quasar.conf.js > pwa > workboxPluginMode) and you can listen for Service Worker's events. You can use ES6 code. custom-service-worker.js will be your service worker file ONLY if workbox plugin mode is set to \"InjectManifest\" (quasar.conf.js > pwa > workboxPluginMode: 'InjectManifest'). Otherwise, Workbox will create a service-worker file for you. It makes sense to run Lighthouse tests on production builds only.  Read more on register-service-worker.js and how to interact with the Service Worker on Handling Service Worker documentation page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 427,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Quasar.conf.js",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More information: Workbox Webpack Plugin, Workbox. The metaVariables Object is used by Quasar itself only (has no meaning for Workbox) to inject specific value attributes to some PWA meta tags into the rendered HTML page. Example: <meta name=\"apple-mobile-web-app-status-bar-style\"> will have value attribute assigned to the content of metaVariables.appleMobileWebAppStatusBarStyle. You can use an alternative to metaVariables: metaVariablesFn(manifest) which can return an Array of Objects (see their form in the code above). Should you configure this function to not return an Array or to return an empty Array, then Quasar App CLI will understand not to add any tags -- so you can manually add your custom tags directly in /src/index.template.html.",
    "anchor": "Quasar.conf.js",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 428,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Picking Workbox mode",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are two Workbox operating modes: GenerateSW (default) and InjectManifest. The first one generates a service worker automatically, based on quasar.conf.js > pwa > workboxOptions (if any), while the second mode allows you to write your own service worker file. Setting the mode that you want to use is done through quasar.conf.js:  Make sure that your workboxOptions match the Workbox mode that you have picked, otherwise the workbox webpack plugin might halt your app from compiling.",
    "anchor": "Picking-Workbox-mode",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 429,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Picking Workbox mode",
    "hierarchy_lvl3": "GenerateSW",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When to use GenerateSW: * You want to precache files. * You have simple runtime configuration needs (e.g. the configuration allows you to define routes and strategies). When NOT to use GenerateSW: * You want to use other Service Worker features (i.e. Web Push). * You want to import additional scripts or add additional logic.  Please check the available workboxOptions for this mode on Workbox website.",
    "anchor": "GenerateSW",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 430,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Picking Workbox mode",
    "hierarchy_lvl3": "InjectManifest",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When to use InjectManifest: * You want more control over your service worker. * You want to precache files. * You have more complex needs in terms of routing. * You would like to use your service worker with other APIs (e.g. Web Push). When NOT to use InjectManifest: * You want the easiest path to adding a service worker to your site.  TIPS * If you want to use this mode, you will have to write the service worker (/src-pwa/custom-service-worker.js) file by yourself. * Please check the available workboxOptions for this mode on Workbox website.",
    "anchor": "InjectManifest",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 431,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Configuring Manifest File",
    "hierarchy_lvl3": "InjectManifest",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please read about the manifest config before diving in.  Note that you don't need to edit your index.html file (generated from /src/index.template.html) to link to the manifest file. Quasar CLI takes care of embedding the right things for you. :  (@quasar/app v2.1.10+) If your PWA is behind basic auth or requires an Authorization header, set quasar.conf.js > pwa > useCredentials to true to include crossorigin=\"use-credentials\" on the manifest.json meta tag. :",
    "anchor": "Configuring-Manifest-File",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 432,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "PWA Checklist",
    "hierarchy_lvl3": "InjectManifest",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not run Lighthouse on your development build because at this stage the code is intentionally not optimized and contains embedded source maps (among many other things). See the Testing and Auditing section of these docs for more information.",
    "anchor": "PWA-Checklist",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 433,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Configuring PWA",
    "hierarchy_lvl2": "Reload & Update Automatically",
    "hierarchy_lvl3": "InjectManifest",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Source",
    "anchor": "Reload-%26-Update-Automatically",
    "url": "/quasar-cli/developing-pwa/configuring-pwa"
  },
  {
    "objectID": 434,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "HMR for PWA",
    "hierarchy_lvl2": "Hot Module Reload for PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage HMR (Hot Module Reload) with Quasar PWA.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/hmr-for-dev"
  },
  {
    "objectID": 435,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "HMR for PWA",
    "hierarchy_lvl2": "Hot Module Reload for PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When your development activity does not include configuring the Service Worker (like when editing the \"/src-pwa/register-service-worker.js\" file), then you can safely trigger the $ quasar dev -m spa (instead of $ quasar dev -m pwa) command to avoid the extra hassle of paying attention to the effects of the Service Worker -- which sometimes may get in the way. One more reason to dev in SPA mode (as described above) when not dealing directly with the development of the service worker is that you may bump into the following warning (which can be ignored and is described fully here): GenerateSW has been called multiple times, perhaps due to running webpack in --watch mode. The precache manifest generated after the first call may be inaccurate! Please see https://github.com/GoogleChrome/workbox/issues/1790 for more information.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/hmr-for-dev"
  },
  {
    "objectID": 436,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "App Icons for PWA",
    "hierarchy_lvl2": "App Icons for PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Quasar Progressive Web App.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/app-icons-pwa"
  },
  {
    "objectID": 437,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "App Icons for PWA",
    "hierarchy_lvl2": "App Icons for PWA",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/app-icons-pwa"
  },
  {
    "objectID": 438,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "App Icons for PWA",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The required HTML code that goes into /src/index.template.html to reference the above files (notice not all files need to be manually referenced as Quasar CLI automatically injects the other PWA ones):",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-pwa/app-icons-pwa"
  },
  {
    "objectID": 439,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Handling Service Worker",
    "hierarchy_lvl2": "Handling Service Worker",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure the service worker in a Quasar Progressive Web App.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/handling-service-worker"
  },
  {
    "objectID": 440,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Handling Service Worker",
    "hierarchy_lvl2": "Handling Service Worker",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice the register-service-worker npm package, which comes out of the box along with Quasar CLI (so don't install it yourself).  This file is automatically bundled into your website/app by Quasar CLI because it is considered as part of app-space /src. What this means is that you can use ES6, import other files etc.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-pwa/handling-service-worker"
  },
  {
    "objectID": 441,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Handling Service Worker",
    "hierarchy_lvl2": "SSL certificate",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You may notice in some dev environments, that Workbox will not load your service workers during quasar dev if you are not using HTTPS to serve - even on localhost. You will see that there are two scripts that can't load. The Chrome browser console is relatively tight-lipped about this, but Firefox tells you what is going on. The three options you have are: - set quasar.conf.js > devServer > https: true - setup a loopback from localhost to 127.0.0.1 (but this is not without security implications) - serve your localhost over ngrok and use the https address that ngrok provides When you set devServer > https: true in your quasar.conf.js file, Quasar will auto-generate a SSL certificate for you. However, if you want to create one yourself for your localhost, then check out this blog post by Filippo. Then your quasar.conf.js > devServer > https should look like this:",
    "anchor": "SSL-certificate",
    "url": "/quasar-cli/developing-pwa/handling-service-worker"
  },
  {
    "objectID": 442,
    "hierarchy_lvl0": "Developing PWA",
    "hierarchy_lvl1": "Handling Service Worker",
    "hierarchy_lvl2": "Important Hosting Configuration",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It's important that you do not allow browsers to cache the service-worker.js file. Because otherwise updates to this file or to your app might slip through the cracks for browsers that load the service-worker from cache. This is why you must always make sure to add \"Cache-Control\": \"no-cache\" to the headers of service-worker.js file via your hosting service. As an example how this is done for Google Firebase, you would add the following to the firebase.json configuration:",
    "anchor": "Important-Hosting-Configuration",
    "url": "/quasar-cli/developing-pwa/handling-service-worker"
  },
  {
    "objectID": 443,
    "hierarchy_lvl0": "Developing Mobile Apps",
    "hierarchy_lvl1": "Developing Mobile Apps",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Developing hybrid mobile apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-mobile-apps"
  },
  {
    "objectID": 444,
    "hierarchy_lvl0": "Developing Mobile Apps",
    "hierarchy_lvl1": "Developing Mobile Apps",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Cordova is a mobile application development framework originally created by Nitobi. Adobe Systems purchased Nitobi in 2011, rebranded it as PhoneGap, and later released an open source version of the software called Apache Cordova. Capacitor was created by Ionic Framework as a more modern replacement for Cordova. It supports most, but not all, Cordova plugins as well as Capacitor-specific plugins.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-mobile-apps"
  },
  {
    "objectID": 445,
    "hierarchy_lvl0": "Developing Mobile Apps",
    "hierarchy_lvl1": "Developing Mobile Apps",
    "hierarchy_lvl2": "More info",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Check the related links below to get started.",
    "anchor": "More-info",
    "url": "/quasar-cli/developing-mobile-apps"
  },
  {
    "objectID": 446,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is Cordova",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction on one of the technologies behind Quasar hybrid mobile apps.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/introduction"
  },
  {
    "objectID": 447,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is Cordova",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can hook into the native device APIs by using Cordova Plugins.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/introduction"
  },
  {
    "objectID": 448,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Cordova App",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What you need to do before developing a Quasar hybrid mobile app with Cordova.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 449,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Cordova App",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Depending on your version of Android Studio, you might need to re-enable the \"Android SDK Tools\". You can do this by going to \"Tools > SDK Manager > SDK Tools\" then un-ticking \"Hide Obsolete Packages\" and tick \"Android SDK Tools (Obsolete)\". The instructions below assume this has been done.   The environmental variable ANDROID_HOME has been deprecated and replaced with ANDROID_SDK_ROOT. Depending on your version of Android Studio you may need one or the other. It doesn't hurt to have both set.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 450,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Cordova App",
    "hierarchy_lvl3": "Android setup",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "After this step you will need to install the Android platform SDK on your machine. You can download the Android Studio here and follow these installation steps afterwards. Make sure that after you install the Android SDK you then accept its licenses. Open the terminal and go to the folder where the SDK was installed, in tools/bin and call sdkmanager --licenses. Add Android installation to your path:",
    "anchor": "Android-setup",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 451,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Cordova App",
    "hierarchy_lvl3": "Android setup",
    "hierarchy_lvl4": "Unix (macOS, linux)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that sometimes the /Android/Sdk folder is added inside /Library/ inside your user folder. Check your user folder and if the /Android/ folder is only inside /Library/ do: export ANDROID_SDK_ROOT=\"$HOME/Library/Android/Sdk\" or export ANDROID_HOME=\"$HOME/Library/Android/Sdk\" instead.",
    "anchor": "Unix-(macOS%2C-linux)",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 452,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Cordova App",
    "hierarchy_lvl3": "Android setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "After installing Android Studio, you need to install two more pieces of software: * JDK from Oracle. It can be found here * Gradle. It used to usable from Android Studio but now you have to install it separately. There is a very specific version that cordova requires. You can download it here Then you will have to set environment variables. You will need to set the following variables. Cordova has a good guide for it already. It can be found here. You need to: * add ANDROID_SDK_ROOT. It can safely be set to: \"%USERPROFILE%\\AppData\\Local\\Android\\Sdk\" * add two ANDROID_SDK_ROOT directories to your path: %ANDROID_SDK_ROOT%\\tools;%ANDROID_SDK_ROOT%\\platform-tools * add Gradle to your path. Note that gradle does not have an installer. You just put the binary files where you want them, then add the bin directory to your path. If you have an init script for your command prompt or powershell, you can try this: bash setx ANDROID_HOME \"%USERPROFILE%\\AppData\\Local\\Android\\Sdk\" setx ANDROID_SDK_ROOT \"%USERPROFILE%\\AppData\\Local\\Android\\Sdk\" setx path \"%path%;%ANDROID_SDK_ROOT%\\tools;%ANDROID_SDK_ROOT%\\platform-tools;<gradle_path>\\bin;\" After the tools are installed, setup Android Studio with the correct SDK and create a virtual machine. Start Android studio (check the executable in the folder that you installed it in). Next step is to install the individual SDKs: Open the \"Configure\" menu at the bottom of the window: Select the desired SDKs. As per December 2019 Cordova requires android-28 (Android 9.0 - Pie) so be sure to include it. Click on \"Apply\" to install the SDKs.",
    "anchor": "Windows",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 453,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Cordova App",
    "hierarchy_lvl3": "iOS setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You will need a macOS with Xcode installed. After you've installed it, open Xcode in order to get the license prompt. Accept the license, then you can close it.",
    "anchor": "iOS-setup",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 454,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "2. Add Cordova Quasar Mode",
    "hierarchy_lvl3": "iOS setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "2.-Add-Cordova-Quasar-Mode",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 455,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "3. Add Platform",
    "hierarchy_lvl3": "iOS setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Target platforms get installed on demand by Quasar CLI. However, if you want to add a platform manually, type: To verify that everything is in order, type: On some newer Debian-based operating systems you might face a very persistent problem when running cordova requirements. Please see the \"Android SDK not found\" after installation section for assistance.",
    "anchor": "3.-Add-Platform",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 456,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "3. Add Platform",
    "hierarchy_lvl3": "Switching to iOS WkWebView",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Switching to WKWebView is highly recommended (but optional!) as UIWebView has been deprecated in iOS 12.0 as described in this Cordova blog post: https://cordova.apache.org/news/2018/08/01/future-cordova-ios-webview.html. However, choose wisely if you want to replace the default webview. Each comes with its own caveats. Make sure that you visit the link above.",
    "anchor": "Switching-to-iOS-WkWebView",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 457,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "3. Add Platform",
    "hierarchy_lvl3": "Switching to iOS WkWebView",
    "hierarchy_lvl4": "Option 1: Ionic Webview Plugin",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Install Ionic Webview Plugin Add ScrollEnabled Preference to Config.xml Consult Ionic Docs for caveats on WkWebViewPlugin https://beta.ionicframework.com/docs/building/webviewhttps://github.com/ionic-team/cordova-plugin-ionic-webview",
    "anchor": "Option-1%3A-Ionic-Webview-Plugin",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 458,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "3. Add Platform",
    "hierarchy_lvl3": "Switching to iOS WkWebView",
    "hierarchy_lvl4": "Option 2: Cordova WkWebviewEngine Plugin",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Install Cordova WkWebviewEngine Plugin For caveats and more info, visit: https://github.com/apache/cordova-plugin-wkwebview-engine",
    "anchor": "Option-2%3A-Cordova-WkWebviewEngine-Plugin",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 459,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "4. Start Developing",
    "hierarchy_lvl3": "Switching to iOS WkWebView",
    "hierarchy_lvl4": "Option 2: Cordova WkWebviewEngine Plugin",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This will add Cordova mode and project automatically, if it is missing. However, if you wish to open the IDE (Android Studio / Xcode) and from there to manually select the emulator (or multiple ones simultaneously!) to run the dev app on it/them:  In Android Studio, you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Cordova project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart.",
    "anchor": "4.-Start-Developing",
    "url": "/quasar-cli/developing-cordova-apps/preparation"
  },
  {
    "objectID": 460,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Configuring Cordova",
    "hierarchy_lvl2": "Configuring Cordova",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage your Cordova apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/configuring-cordova"
  },
  {
    "objectID": 461,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Configuring Cordova",
    "hierarchy_lvl2": "Configuring Cordova",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are two configuration files of great importance to your mobile apps. We'll go over each one.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/configuring-cordova"
  },
  {
    "objectID": 462,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Configuring Cordova",
    "hierarchy_lvl2": "config.xml",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Some properties from this file will get overwritten as we'll see in next section.",
    "anchor": "config.xml",
    "url": "/quasar-cli/developing-cordova-apps/configuring-cordova"
  },
  {
    "objectID": 463,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Configuring Cordova",
    "hierarchy_lvl2": "quasar.conf.js",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For determining the values for each of the properties mentioned above, Quasar CLI: 1. Looks in /quasar.conf.js for a \"cordova\" Object. Does it have \"version\", \"description\" and/or \"androidVersionCode\"? If yes, it will use them. 2. If not, then it looks into your /package.json for \"cordovaId\", \"version\" and \"description\" fields. Other options you can configure:",
    "anchor": "quasar.conf.js",
    "url": "/quasar-cli/developing-cordova-apps/configuring-cordova"
  },
  {
    "objectID": 464,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "App Icons for Cordova",
    "hierarchy_lvl2": "App Icons for Cordova",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Quasar hybrid mobile app with Cordova.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/app-icons-cordova"
  },
  {
    "objectID": 465,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "App Icons for Cordova",
    "hierarchy_lvl2": "App Icons for Cordova",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you discover one file that is new or missing, please open an issue.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/app-icons-cordova"
  },
  {
    "objectID": 466,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "App Icons for Cordova",
    "hierarchy_lvl2": "Icon Genie CLI",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page.",
    "anchor": "Icon-Genie-CLI",
    "url": "/quasar-cli/developing-cordova-apps/app-icons-cordova"
  },
  {
    "objectID": 467,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "App Icons for Cordova",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Unless you are using the Icon Genie CLI, this is what you need to do: And here is part of what your config.xml should look like:",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-cordova-apps/app-icons-cordova"
  },
  {
    "objectID": 468,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Cordova Plugins",
    "hierarchy_lvl2": "Cordova Plugins",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Cordova plugins in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/cordova-plugins"
  },
  {
    "objectID": 469,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Cordova Plugins",
    "hierarchy_lvl2": "Cordova Plugins",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Battery Status Camera Contacts Device Device Motion Geolocation Media Media Capture Network Information Splashscreen Vibration Statusbar",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/cordova-plugins"
  },
  {
    "objectID": 470,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Cordova Plugins",
    "hierarchy_lvl2": "Deviceready Event",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "export default { // we are sure 'deviceready' has been triggered here } </script> ``` The reason is simple. Quasar listens for the event then mounts the root Vue component. But before this, the Vue files are imported into the /src/router/routes.js file, so the code outside of the default export gets executed.",
    "anchor": "Deviceready-Event",
    "url": "/quasar-cli/developing-cordova-apps/cordova-plugins"
  },
  {
    "objectID": 471,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Cordova Plugins",
    "hierarchy_lvl2": "Using a Cordova Plugin",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We see instructions on how to install this plugin. It's always a Cordova command. So we \"cd\" into /src-cordova (which is a Cordova generated folder) and issue the install command form there: Now let's put this plugin to some good use. In one of your Quasar project's pages/layouts/components Vue file, we write:",
    "anchor": "Using-a-Cordova-Plugin",
    "url": "/quasar-cli/developing-cordova-apps/cordova-plugins"
  },
  {
    "objectID": 472,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Cordova Plugins",
    "hierarchy_lvl2": "Using a Cordova Plugin",
    "hierarchy_lvl3": "Example: Camera",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There's a mention of the deviceready event. But we already know how to handle it from the previous sections. We read the instructions on how to install this plugin. It's always a Cordova command. So we \"cd\" into /src-cordova (which is a Cordova generated folder) and issue the install command form there: Now let's put this plugin to some good use. In one of your Quasar project's pages/layouts/components Vue file, we write:",
    "anchor": "Example%3A-Camera",
    "url": "/quasar-cli/developing-cordova-apps/cordova-plugins"
  },
  {
    "objectID": 473,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Cordova Plugins",
    "hierarchy_lvl2": "Using a Cordova Plugin",
    "hierarchy_lvl3": "Example: Device",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This plugin initializes a global variable called device which describes the device's hardware and software. So it can be accessed with window.device. Read the instructions on how to install this plugin on its cordova doc page. It's always a Cordova command. So we \"cd\" into /src-cordova (which is a Cordova generated folder) and issue the install command from there: Now let's put this plugin to some good use. If you need the information of your device when starting the application, you will have to capture the created event. In one of your Quasar project's pages/layouts/components Vue file, we write:",
    "anchor": "Example%3A-Device",
    "url": "/quasar-cli/developing-cordova-apps/cordova-plugins"
  },
  {
    "objectID": 474,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Mobile App Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a hybrid mobile app with Cordova.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/build-commands"
  },
  {
    "objectID": 475,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Mobile App Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/build-commands"
  },
  {
    "objectID": 476,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Developing",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, if you wish to open the IDE (Android Studio / Xcode) and from there to manually select the emulator (or multiple ones simultaneously!) to run the dev app on it/them (or to run the dev app on a real mobile/tablet device):  In Android Studio, you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Cordova project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart. In order for you to be able to develop on a device emulator or directly on a phone (with Hot Module Reload included), Quasar CLI follows these steps: 1. Detects your machine's external IP address. If there are multiple such IPs detected, then it asks you to choose one. If you'll be using a mobile phone to develop then choose the IP address of your machine that's pingable from the phone/tablet. 2. It starts up a development server on your machine. 3. It temporarily changes the <content/> tag in /src-cordova/config.xml to point to the IP previously detected. This allows the app to connect to the development server. 3. It defers to Cordova CLI to build a native app with the temporarily changed config.xml. 4. Cordova CLI checks if a mobile phone / tablet is connected to your development machine. If it is, it installs the development app on it. If none is found, then it boots up an emulator and runs the development app. 5. Finally, it reverts the temporary changes made to /src-cordova/config.xml.  If developing on a mobile phone/tablet, it is very important that the external IP address of your build machine is accessible from the phone/tablet, otherwise you'll get a development app with white screen only. Also check your machine's firewall to allow connections to the development chosen port.",
    "anchor": "Developing",
    "url": "/quasar-cli/developing-cordova-apps/build-commands"
  },
  {
    "objectID": 477,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Developing",
    "hierarchy_lvl3": "Enabling iOS modern build",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, Xcode modern build for iOS is disabled due to Cordova issues. However, if you know what you are doing and you want to enable it, do so from /quasar.conf.js: The above applies also if you want to specify the build type in your \"build.json\".",
    "anchor": "Enabling-iOS-modern-build",
    "url": "/quasar-cli/developing-cordova-apps/build-commands"
  },
  {
    "objectID": 478,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": "Enabling iOS modern build",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "These commands parse and build your /src folder then overwrite /src-cordova/www then defer to Cordova CLI to trigger the actual native app creation. Built packages will be located in /dist/cordova unless configured otherwise. If you wish to skip the Cordova CLI packaging step and only fill /src-cordova/www folder: Should you wish to manually build the final assets using the IDE (Android Studio / Xcode) instead of doing a terminal build, then:  In Android Studio, you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Cordova project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart. If you want a production build with debugging enabled for the UI code:",
    "anchor": "Building-for-Production",
    "url": "/quasar-cli/developing-cordova-apps/build-commands"
  },
  {
    "objectID": 479,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks for a Quasar hybrid mobile app with Cordova.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 480,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This way you have Chrome Dev Tools directly for your App running on the emulator/phone/table. Inspect elements, check console output, and so on and so forth.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 481,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": "Accept Licenses",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If this is the case you need to accept ALL the licenses. Thankfully there is a tool for this: Linux: sdkmanager --licenses macOS: ~/Library/Android/sdk/tools/bin/sdkmanager --licenses Windows: %ANDROID_SDK_ROOT%/tools/bin/sdkmanager --licenses",
    "anchor": "Accept-Licenses",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 482,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": "Android SDK not found after installation of the SDK",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The environmental variable ANDROID_HOME has been deprecated and replaced with ANDROID_SDK_ROOT. Depending on your version of Android Studio you may need one or the other. It doesn't hurt to have both set.  Some newer Debian-based OS (e.g. ubuntu, elementary OS) might leave you with a Android SDK not found. after you installed and (correctly) configured the environment. The output might look similar to this: This could have two different reasons: Usually the paths aren't configured correctly. The first step is to verify if your paths are set correctly. This can be done by running the following commands: The expected output should be a path similar to this $HOME/Android/Sdk. After this run: To ensure the folder contains the SDK. The expected output should contain folders like 'tools', 'sources', 'platform-tools', etc. The output should contain each one entry for the Android SDK 'tools'-folder and 'platform-tools'-tools. This could look like this: If you ensured your paths are set correctly and still get the error on cordova requirements you can try the following fix: Replacing the Android Studio 'tools' folder manually",
    "anchor": "Android-SDK-not-found-after-installation-of-the-SDK",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 483,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": "Android Studio",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In Android Studio (if you open it on /src-cordova/platforms/android), you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Cordova project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart.",
    "anchor": "Android-Studio",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 484,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": "Setting up device on Linux",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You may bump into ?????? no permissions problem when trying to run your App directly on an Android phone/tablet. Here's how you fix this: The content for 51-android.rules: SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0bb4\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0e79\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0502\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0b05\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"413c\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0489\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"091e\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"18d1\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0bb4\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"12d1\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"24e3\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"2116\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0482\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"17ef\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1004\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"22b8\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0409\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"2080\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0955\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"2257\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"10a9\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1d4d\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0471\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"04da\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"05c6\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1f53\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"04e8\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"04dd\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0fce\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0930\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"19d2\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1bbb\", MODE=\"0666\" Now running adb devices should discover your device.",
    "anchor": "Setting-up-device-on-Linux",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 485,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Cordova Troubleshooting and Tips",
    "hierarchy_lvl3": "Post-build debugging",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Important! If you find a bug using one of the above methods, do not edit the output files (probably the www folder) directly, as they will soon be overwritten. Go back to your quasar source, fix the bug, then re-run quasar build.",
    "anchor": "Post-build-debugging",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 486,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "Post-build debugging",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Then it means you need to specify an emulator. Depending on your Cordova CLI version, here are some examples:",
    "anchor": "iOS-Tips",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 487,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "Enabling modern build",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The above applies also if you want to specify the build type in your \"build.json\".",
    "anchor": "Enabling-modern-build",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 488,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "iOS remote debugging",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This way you have Safari developer tools directly for your App running on the emulator/phone/table. Inspect elements, check console output, and so on and so forth. First enable the \"developer\" menu option in the Settings of Safari. Then if you navigate to the \"developer\" menu option you will see your emulator or connected device listed near the top. From here you can open the developer tools.",
    "anchor": "iOS-remote-debugging",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 489,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "Status bar and notch safe-areas",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar has support for these CSS safe-areas by default in QHeader/QFooter and Notify. However it's important to always check your Cordova build on several models to see if all cases of your app are dealing with the safe areas correctly. In cases you need to manually tweak your CSS you can do so with: Of course you can also use the above example with margin instead of padding depending on your app. In order to make sure these are only added when opened on mobile via the Cordova build, you can check for the CSS class .cordova which is automatically added to the body by Quasar. Example:",
    "anchor": "Status-bar-and-notch-safe-areas",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 490,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "Disabling iOS rubber band effect",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Disabling-iOS-rubber-band-effect",
    "url": "/quasar-cli/developing-cordova-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 491,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Managing Google Analytics",
    "hierarchy_lvl2": "Managing Google Analytics",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use analytics in a Quasar hybrid mobile app with Cordova.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/managing-google-analytics"
  },
  {
    "objectID": 492,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Managing Google Analytics",
    "hierarchy_lvl2": "Managing Google Analytics",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You may also want to read these great tutorials: - Google Tag Manager and Analytics Setup for an SPA Website - Google Analytics Setup for a Cordova App  You'll need to include a <script> tag provided by Google in /src/index.template.html, which will make your App depend on an Internet connection!",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/managing-google-analytics"
  },
  {
    "objectID": 493,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Managing Google Analytics",
    "hierarchy_lvl2": "Prerequisites",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Place the Tag Manager snippet into head of your index.html file (if you've followed the Multiminds article, you already have this.) Create a new file in your codebase called analytics.js with the following contents: To make sure all the pages in your application are automatically posted to Google Analytics, we create an app boot file: Then we edit the newly created file: /src/boot/google-analytics.js: Finally we register the app boot file in /quasar.conf.js. We can do so only for Cordova wrapped apps if we want: More information about events can be found in the Analytics documentation on events. You'll see the events and pageviews coming in when you run your app. It usually takes around 5 to 10 seconds for a pageview to be registered in the realtime view.",
    "anchor": "Prerequisites",
    "url": "/quasar-cli/developing-cordova-apps/managing-google-analytics"
  },
  {
    "objectID": 494,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to publish a Quasar hybrid mobile app with Cordova to Google Play Store and to Apple App Store.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 495,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This will generate a release build based on the settings in your /src-cordova/config.xml. Next, we can find our unsigned APK file in \"/src-cordova/platforms/android/app/build/outputs/apk/release\" or equivalent path (written in the output of terminal). Filename usually ends with \"-release-unsigned.apk\". Now, we need to sign the unsigned APK and run an alignment utility on it to optimize it and prepare it for the app store. If you already have a signing key, skip these steps and use that one instead. Let’s generate our private key using the keytool command that comes with the JDK. If this tool isn’t found, refer to the installation guide: You’ll first be prompted to create a password for the keystore. Then, answer the rest of the nice tool’s questions and when it’s all done, you should have a file called my-release-key.keystore created in the current directory.  Make sure to save this file somewhere safe, if you lose it you won’t be able to submit updates to your app!  To sign the unsigned APK, run the jarsigner tool which is also included in the JDK: This signs the apk in place. Finally, we need to run the zip align tool to optimize the APK. The zipalign tool can be found in /path/to/Android/sdk/build-tools/VERSION/zipalign. For example, on OS X with Android Studio installed, zipalign is in ~/Library/Android/sdk/build-tools/VERSION/zipalign: Now we have our final release binary called HelloWorld.apk and we can release this on the Google Play Store for all the world to enjoy! (There are a few other ways to sign APKs. Refer to the official Android App Signing documentation for more information.)",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 496,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": "Google Play Store",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To start, you’ll need to visit the Google Play Store Developer Console and create a new developer account. Unfortunately, this is not free. However, the cost is only $25 compared to Apple’s $99. Once you have a developer account, you can go ahead and click “Publish an Android App on Google Play”. Then, you can go ahead and click the button to edit the store listing (We will upload an APK later). You’ll want to fill out the description for the app. When you are ready, upload the APK for the release build and publish the listing. Be patient and your hard work should be live in the wild!",
    "anchor": "Google-Play-Store",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 497,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": "Updating your App",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for the Google Play Store to accept updated APKs, you’ll need to bump the app version (from /package.json or from /quasar.conf.js > cordova > version, then rebuild the app for release.",
    "anchor": "Updating-your-App",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 498,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Updating your App",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Click the Create button next to the iOS Distribution option. You can learn more about maintaining your signing identities and certificates from the official documentation.",
    "anchor": "iOS-Publishing",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 499,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Setting up the app identifier",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Once you’re logged in you should choose Certificates, Identifiers, and Profiles option. Also select the Identifiers option under the iOS Apps. Then select the + button in order to add a new iOS App ID. Then you’ll have to set the name of your app, use the Explicit App ID option and set the Bundle ID to the value of the id in your Cordova config.xml tag. Additionally, you’ll have to choose any of the services that need to be enabled. For example, if you use Apple Pay or Wallet in your app, you need to choose those option. You can learn more about registering app identifiers from the official documentation.",
    "anchor": "Setting-up-the-app-identifier",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 500,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Creating the app listing",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This will show three options in a dropdown, and you should select the New App. After this the popup appears where you have to choose the name of the application, platform, primary language, bundle ID and SKU. Once you’re done, click on the Create button and you’ll be presented with a screen where you’ll have to set some basic options like Privacy Policy URL, category and sub category. Now, before we fill out everything in the listing, we’ll build our app and get it uploaded with Xcode. Then you’ll come back to finish the listing. You can learn more about managing your app in iTunes Connect from the official documentation.",
    "anchor": "Creating-the-app-listing",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 501,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Building the app for production",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If everything went well you’ll see the BUILD SUCCEEDED output in the console.",
    "anchor": "Building-the-app-for-production",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 502,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Opening the project in Xcode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Once the Xcode opens up the project, you should see the details about your app in the general view. You should just check that the bundle identifier is set up correctly, so that it’s the same as the value you specified earlier in the app ID. Also, make sure that the version and build numbers are correct. Team option should be set to your Apple developer account. Under the deployment target you can choose which devices your application will support.",
    "anchor": "Opening-the-project-in-Xcode",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 503,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Creating an archive of the application",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To create an archive, choose a Generic iOS Device, or your device if it’s connected to your Mac (you can’t create an archive if simulator is selected), from the Scheme toolbar menu in the project editor. Next, select Product > Archive, and the Archive organizer appears and displays the new archive. At this point you can click the Upload to App Store... button, and if everything goes fine you’ll have an uploaded app, and the only thing that’s left to do is to complete the iTunes Connect listing and submit it for review! At this point you should get an email from iTunes Connect shortly after you uploaded the archive with the content.",
    "anchor": "Creating-an-archive-of-the-application",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 504,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Finishing the app list process",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You don’t have to worry about forgetting to insert any crucial and required information about your application, since you’ll be notified about what’s missing and what needs to be added/changed if you try to submit the app for review before all details are filled in. Next, click on the 1.0 Prepare for Submission button on the left-hand side, as shown on the image below. When we uploaded our archive, iTunes Connect automatically determined which device sizes are supported. You’ll need to upload at least one screenshot image for each of the various app sizes that were detected by iTunes Connect. Next, you’ll have to insert Description, Keywords, Support URL and Marketing URL (optionally). In the Build section you have to click on the + button and select the build that was uploaded through Xcode in the previous steps. Next, you’ll have to upload the icon, edit the rating, and set some additional info like copyright and your information. Note that the size of the icon that you’ll have to upload here will have to be 1024 by 1024 pixels. Thankfully, you can use the splash.png from the second tutorial. If you’re the sole developer then the data in the App Review Information should be your own. Finally, as the last option, you can leave the default checked option that once your app is approved that it is automatically released to the App Store. Now that we’re finished with adding all of the details to the app listing, we can press Save and then Submit for Review. Finally, you’ll be presented with the last form that you’ll have to fill out. After you submit your app for review you’ll see the status of it in the My Apps as Waiting for review, as shown on the image below. Also, shortly after you submit your app for review you’ll get a confirmation email from iTunes Connect that your app is in review. Apple prides itself with a manual review process, which basically means it can take several days for your app to be reviewed. You’ll be notified of any issues or updates to your app status.",
    "anchor": "Finishing-the-app-list-process",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 505,
    "hierarchy_lvl0": "Developing Cordova Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Updating the app",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Once you submit for the review, you’ll have to wait for the review process again.",
    "anchor": "Updating-the-app",
    "url": "/quasar-cli/developing-cordova-apps/publishing-to-store"
  },
  {
    "objectID": 506,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is Capacitor",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction on one of the technologies behind Quasar hybrid mobile apps.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/introduction"
  },
  {
    "objectID": 507,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Capacitor App",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What you need to do before developing a Quasar hybrid mobile app with Capacitor.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 508,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Capacitor App",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You will need to install Android Studio and the Android platform SDK on your machine. You can download the Android Studio here and follow these installation steps afterwards. Make sure that after you install the Android SDK you then accept its licenses. Open the terminal and go to the folder where the SDK was installed, in tools/bin and call sdkmanager --licenses.  The environmental variable ANDROID_HOME has been deprecated and replaced with ANDROID_SDK_ROOT. Depending on your version of Android Studio you may need one or the other. It doesn't hurt to have both set.  Add Android installation to your path:",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 509,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Capacitor App",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Unix (macOS, linux)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that sometimes the /Android/Sdk folder is added inside /Library/ inside your user folder. Check your user folder and if the /Android/ folder is only inside /Library/ do: export ANDROID_SDK_ROOT=\"$HOME/Library/Android/Sdk\" or export ANDROID_HOME=\"$HOME/Library/Android/Sdk\" instead.",
    "anchor": "Unix-(macOS%2C-linux)",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 510,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Capacitor App",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Start Android studio (check the executable in the folder that you installed it in). Next step is to install the individual SDKs: Open the \"Configure\" menu at the bottom of the window: Select the desired SDKs and click on \"Apply\" to install the SDKs.",
    "anchor": "Windows",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 511,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Capacitor App",
    "hierarchy_lvl3": "iOS setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You will need a macOS with Xcode installed. After you've installed it, open Xcode in order to get the license prompt. Accept the license, then you can close it.",
    "anchor": "iOS-setup",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 512,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "2. Add Capacitor Quasar Mode",
    "hierarchy_lvl3": "iOS setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order to develop/build a Mobile app, we need to add the Capacitor mode to our Quasar project. This will use the Capacitor CLI to generate a Capacitor project in /src-capacitor folder.",
    "anchor": "2.-Add-Capacitor-Quasar-Mode",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 513,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "3. Start Developing",
    "hierarchy_lvl3": "iOS setup",
    "hierarchy_lvl4": "Windows",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To start a dev server with HMR, run the command below: Once the dev server is ready, your IDE will open (Android Studio or Xcode)and from there you can manually select the emulator (or multiple ones simultaneously!) and install the dev app on it/them. You can also run the dev app on a connected mobile/tablet device.  In Android Studio, you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Capacitor project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart.",
    "anchor": "3.-Start-Developing",
    "url": "/quasar-cli/developing-capacitor-apps/preparation"
  },
  {
    "objectID": 514,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Configuring Capacitor",
    "hierarchy_lvl2": "Configuring Capacitor",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage your Capacitor apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/configuring-capacitor"
  },
  {
    "objectID": 515,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Configuring Capacitor",
    "hierarchy_lvl2": "Configuring Capacitor",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are two configuration files of great importance to your mobile apps. We'll go over each one.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/configuring-capacitor"
  },
  {
    "objectID": 516,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Configuring Capacitor",
    "hierarchy_lvl2": "capacitor.config.json",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Some properties from this file will get overwritten as we'll see in next section.",
    "anchor": "capacitor.config.json",
    "url": "/quasar-cli/developing-capacitor-apps/configuring-capacitor"
  },
  {
    "objectID": 517,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Configuring Capacitor",
    "hierarchy_lvl2": "quasar.conf.js",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "And you can also configure: Finally, you can also disable or configure the back button hook (used for Dialogs):",
    "anchor": "quasar.conf.js",
    "url": "/quasar-cli/developing-capacitor-apps/configuring-capacitor"
  },
  {
    "objectID": 518,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "App Icons for Capacitor",
    "hierarchy_lvl2": "App Icons for Capacitor",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Quasar hybrid mobile app with Capacitor.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/app-icons-capacitor"
  },
  {
    "objectID": 519,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "App Icons for Capacitor",
    "hierarchy_lvl2": "App Icons for Capacitor",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you discover one file that is new or missing, please open an issue.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/app-icons-capacitor"
  },
  {
    "objectID": 520,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "App Icons for Capacitor",
    "hierarchy_lvl2": "Icon Genie CLI",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page. Depending on what packager (electron-packager or electron-builder) you will be using, please see their docs on how to hook the icons.",
    "anchor": "Icon-Genie-CLI",
    "url": "/quasar-cli/developing-capacitor-apps/app-icons-capacitor"
  },
  {
    "objectID": 521,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "App Icons for Capacitor",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Unless you are using the Icon Genie app extension, these are the files that you need to replace:",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-capacitor-apps/app-icons-capacitor"
  },
  {
    "objectID": 522,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Capacitor API",
    "hierarchy_lvl2": "Capacitor APIs",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Capacitor plugins in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/capacitor-api"
  },
  {
    "objectID": 523,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Capacitor API",
    "hierarchy_lvl2": "Capacitor APIs",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Background Task Camera Console Device Filesystem Geolocation Motion Network Push Notifications Share Splash Screen Status Bar",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/capacitor-api"
  },
  {
    "objectID": 524,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Capacitor API",
    "hierarchy_lvl2": "Using a Capacitor API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now let's put this plugin to some good use. In one of your Quasar project's pages/layouts/components Vue file, we write:",
    "anchor": "Using-a-Capacitor-API",
    "url": "/quasar-cli/developing-capacitor-apps/capacitor-api"
  },
  {
    "objectID": 525,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Capacitor API",
    "hierarchy_lvl2": "Using a Capacitor API",
    "hierarchy_lvl3": "Example: Camera",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now let's put this API to some good use. In one of your Quasar project's pages/layouts/components Vue file, we write: Some Capacitor plugins, such as Camera, have a web-based UI available when not running natively but in a standard web browser. To enable these controls, add @ionic/pwa-elements to your project: Then create a boot file to initialize them, for example src/boot/capacitor.js: Don't forget to call the boot script in quasar.conf.js Now you are able to use the Camera API not just in native Android or iOS, but also in web based projects like a SPA or PWA.",
    "anchor": "Example%3A-Camera",
    "url": "/quasar-cli/developing-capacitor-apps/capacitor-api"
  },
  {
    "objectID": 526,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Capacitor API",
    "hierarchy_lvl2": "Using a Capacitor API",
    "hierarchy_lvl3": "Example: Device",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now let's put this API to some good use. In one of your Quasar project's pages/layouts/components Vue file, we write:",
    "anchor": "Example%3A-Device",
    "url": "/quasar-cli/developing-capacitor-apps/capacitor-api"
  },
  {
    "objectID": 527,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Capacitor Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a hybrid mobile app with Capacitor.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/build-commands"
  },
  {
    "objectID": 528,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Capacitor Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It will open the IDE (Android Studio / Xcode) and from there you can manually select the emulator (or multiple ones simultaneously!) and install the dev app on it/them. You can also run the dev app on a real mobile/tablet device.  In Android Studio, you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Capacitor project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart. In order for you to be able to develop on a device emulator or directly on a phone (with Hot Module Reload included), Quasar CLI follows these steps: Detects your machine's external IP address. If there are multiple such IPs detected, then it asks you to choose one. If you'll be using a mobile phone to develop then choose the IP address of your machine that's pingable from the phone/tablet. It starts up a development server on your machine. It tells Capacitor to use the IP previously detected. This allows the app to connect to the development server. It uses the Capacitor CLI to update all of your plugins. Finally, it opens your native IDE. Run your app here, and it will automatically connect to the dev server.  If developing on a mobile phone/tablet, it is very important that the external IP address of your build machine is accessible from the phone/tablet, otherwise you'll get a development app with white screen only. Also check your machine's firewall to allow connections to the development chosen port.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/build-commands"
  },
  {
    "objectID": 529,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "These commands parse and build your /src folder then overwrite /src-capacitor/www then use the Gradle/xcodebuild to generate the final assets that go into a phone/tablet. Built packages will be located in /dist/capacitor unless configured otherwise. If you wish to skip the Gradle/xcodebuild step and only fill /src-capacitor/www folder: Should you wish to manually build the final assets using the IDE (Android Studio / Xcode) instead of doing a terminal build, then:  In Android Studio, you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Capacitor project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart. If you want a production build with debugging enabled for the UI code:",
    "anchor": "Building-for-Production",
    "url": "/quasar-cli/developing-capacitor-apps/build-commands"
  },
  {
    "objectID": 530,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Capacitor Troubleshooting and Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks for a Quasar hybrid mobile app with Capacitor.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 531,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Capacitor Troubleshooting and Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are debugging Android Apps, you can use Google Chrome Remote Debugging through a USB cable attached to your Android phone/tablet. It can be used for emulator too. This way you have Chrome Dev Tools directly for your App running on the emulator/phone/table. Inspect elements, check console output, and so on and so forth.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 532,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Capacitor Troubleshooting and Tips",
    "hierarchy_lvl3": "Accept Licenses",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are having problems getting Android builds to finish and you see a message like: If this is the case you need to accept ALL the licenses. Thankfully there is a tool for this: Linux: sdkmanager --licenses macOS: ~/Library/Android/sdk/tools/bin/sdkmanager --licenses Windows: %ANDROID_SDK_ROOT%/tools/bin/sdkmanager --licenses",
    "anchor": "Accept-Licenses",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 533,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Capacitor Troubleshooting and Tips",
    "hierarchy_lvl3": "Android SDK not found after installation of the SDK",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The environmental variable ANDROID_HOME has been deprecated and replaced with ANDROID_SDK_ROOT. Depending on your version of Android Studio you may need one or the other. It doesn't hurt to have both set.  Some newer Debian-based OS (e.g. ubuntu, elementary OS) might leave you with a Android SDK not found. after you installed and (correctly) configured the environment. This could have two different reasons: Usually the paths aren't configured correctly. The first step is to verify if your paths are set correctly. This can be done by running the following commands: The expected output should be a path similar to this $HOME/Android/Sdk. After this run: To ensure the folder contains the SDK. The expected output should contain folders like 'tools', 'sources', 'platform-tools', etc. The output should contain each one entry for the Android SDK 'tools'-folder and 'platform-tools'-tools. This could look like this: If you ensured your paths are set correctly and still get the error, you can try the following fix: Replacing the Android Studio 'tools' folder manually",
    "anchor": "Android-SDK-not-found-after-installation-of-the-SDK",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 534,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Capacitor Troubleshooting and Tips",
    "hierarchy_lvl3": "Android Studio",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In Android Studio (if you open it on /src-capacitor/android), you will be greeted with a message recommending to upgrade the Gradle version. DO NOT UPGRADE GRADLE as it will break the Capacitor project. Same goes for any other requested upgrades. If you encounter any IDE errors then click on File > Invalidate caches and restart.",
    "anchor": "Android-Studio",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 535,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Capacitor Troubleshooting and Tips",
    "hierarchy_lvl3": "Setting up device on Linux",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You may bump into ?????? no permissions problem when trying to run your App directly on an Android phone/tablet. Here's how you fix this: The content for 51-android.rules: Now running adb devices should discover your device.",
    "anchor": "Setting-up-device-on-Linux",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 536,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "Setting up device on Linux",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are debugging iOS Apps, you can use the Safari developer tools to remotely debug through a USB cable attached to your iOS phone/tablet. It can be used for emulator too. This way you have Safari developer tools directly for your App running on the emulator/phone/table. Inspect elements, check console output, and so on and so forth. First enable the \"developer\" menu option in the Settings of Safari. Then if you navigate to the \"developer\" menu option you will see your emulator or connected device listed near the top. From here you can open the developer tools.",
    "anchor": "iOS-Tips",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 537,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "iOS Tips",
    "hierarchy_lvl3": "Status bar and notch safe-areas",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since mobile phones have a status bar and/or notches, your app's styling might need some tweaking when building on Capacitor. In order to prevent parts of your app from going behind the status bar, there is a global CSS variable that can be used for creating a \"safe-area\". This variable can then be applied in your app's top and bottom padding or margin. Quasar has support for these CSS safe-areas by default in QHeader/QFooter and Notify. However it's important to always check your Capacitor build on several models to see if all cases of your app are dealing with the safe areas correctly. In cases you need to manually tweak your CSS you can do so with: Of course you can also use the above example with margin instead of padding depending on your app.",
    "anchor": "Status-bar-and-notch-safe-areas",
    "url": "/quasar-cli/developing-capacitor-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 538,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Managing Google Analytics",
    "hierarchy_lvl2": "Managing Google Analytics",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use analytics in a Quasar hybrid mobile app with Capacitor.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/managing-google-analytics"
  },
  {
    "objectID": 539,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Managing Google Analytics",
    "hierarchy_lvl2": "Managing Google Analytics",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You may also want to read this great tutorial: Google Tag Manager and Analytics Setup for an SPA Website  You'll need to include a <script> tag provided by Google in /src/index.template.html, which will make your App depend on an Internet connection!",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/managing-google-analytics"
  },
  {
    "objectID": 540,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Managing Google Analytics",
    "hierarchy_lvl2": "Prerequisites",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Place the Tag Manager snippet into head of your index.html file (if you've followed the Multiminds article, you already have this.) Create a new file in your codebase called analytics.js with the following contents: To make sure all the pages in your application are automatically posted to Google Analytics, we create an app boot file: Then we edit the newly created file: /src/boot/google-analytics.js: Finally we register the app boot file in /quasar.conf.js. We can do so only for Capacitor wrapped apps if we want: More information about events can be found in the Analytics documentation on events. You'll see the events and pageviews coming in when you run your app. It usually takes around 5 to 10 seconds for a pageview to be registered in the realtime view.",
    "anchor": "Prerequisites",
    "url": "/quasar-cli/developing-capacitor-apps/managing-google-analytics"
  },
  {
    "objectID": 541,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to publish a Quasar hybrid mobile app with Capacitor to Google Play Store and to Apple App Store.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 542,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To generate a release build for Android, we can use the following Quasar CLI command: This will compile the web assets (and if \"--ide\" param is also specified, it will open up Android Studio IDE where you need to trigger a release build). Next, we find our unsigned APK file generated by the Android Studio. Now, we need to sign the unsigned APK and run an alignment utility on it to optimize it and prepare it for the app store. If you already have a signing key, skip these steps and use that one instead. Let’s generate our private key using the keytool command that comes with the JDK. If this tool isn’t found, refer to the installation guide: You’ll first be prompted to create a password for the keystore. Then, answer the rest of the nice tool’s questions and when it’s all done, you should have a file called my-release-key.keystore created in the current directory.  Make sure to save this file somewhere safe and secure, if you lose it you won’t be able to submit updates to your app!  To sign the unsigned APK, run the jarsigner tool which is also included in the JDK: This signs the apk in place. Finally, we need to run the zip align tool to optimize the APK. The zipalign tool can be found in /path/to/Android/sdk/build-tools/VERSION/zipalign. For example, on OS X with Android Studio installed, zipalign is in ~/Library/Android/sdk/build-tools/VERSION/zipalign: Now we have our final release binary called HelloWorld.apk and we can release this on the Google Play Store for all the world to enjoy! (There are a few other ways to sign APKs. Refer to the official Android App Signing documentation for more information.)",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 543,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": "Google Play Store",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now that we have our release APK ready for the Google Play Store, we can create a Play Store listing and upload our APK. To start, you’ll need to visit the Google Play Store Developer Console and create a new developer account. Unfortunately, this is not free. However, the cost is only $25 compared to Apple’s $99. Once you have a developer account, you can go ahead and click “Publish an Android App on Google Play”. Then, you can go ahead and click the button to edit the store listing (We will upload an APK later). You’ll want to fill out the description for the app. When you are ready, upload the APK for the release build and publish the listing. Be patient and your hard work should be live in the wild!",
    "anchor": "Google-Play-Store",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 544,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "Publishing to Store",
    "hierarchy_lvl3": "Updating your App",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "As you develop your app, you’ll want to update it periodically. In order for the Google Play Store to accept updated APKs, you’ll need to bump the app version (from /package.json or from /quasar.conf.js > capacitor > version, then rebuild the app for release.",
    "anchor": "Updating-your-App",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 545,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Updating your App",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "First, you need to enroll in Apple Developer Program. As with Google, if you have a personal account with Apple, you can create an additional one for your applications.",
    "anchor": "iOS-Publishing",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 546,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Connecting Xcode with your developer account",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "After you receive your developer status, open Xcode on your Mac and go to Preferences > Accounts. Add your account to Xcode by clicking the + button on the lower left-hand side and follow the instructions.",
    "anchor": "Connecting-Xcode-with-your-developer-account",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 547,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Signing",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now that you linked Xcode with your developer account, go to Preferences > Accounts, select your Apple Id on the left-hand side and then click the View Details button shown on the previous image. Click the Create button next to the iOS Distribution option. You can learn more about maintaining your signing identities and certificates from the official documentation.",
    "anchor": "Signing",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 548,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Setting up the app identifier",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Next, through the Apple Developer Member Center we’ll set up the app ID identifier details. Identifiers are used to allow an app to have access to certain app services like for example Apple Pay. You can login to Apple Developer Member Center with your Apple ID and password. Once you’re logged in you should choose Certificates, Identifiers, and Profiles option. Also select the Identifiers option under the iOS Apps. Then select the + button in order to add a new iOS App ID. Then you’ll have to set the name of your app, use the Explicit App ID option and set the Bundle ID to the value of the id in your capacitor.config.json. Additionally, you’ll have to choose any of the services that need to be enabled. For example, if you use Apple Pay or Wallet in your app, you need to choose those option. You can learn more about registering app identifiers from the official documentation.",
    "anchor": "Setting-up-the-app-identifier",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 549,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Creating the app listing",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apple uses iTunes Connect to manage app submissions. After your login, you should select the My Apps button, and on the next screen select the + button, just below the iTunes Connect My Apps header. This will show three options in a dropdown, and you should select the New App. After this the popup appears where you have to choose the name of the application, platform, primary language, bundle ID and SKU. Once you’re done, click on the Create button and you’ll be presented with a screen where you’ll have to set some basic options like Privacy Policy URL, category and sub category. Now, before we fill out everything in the listing, we’ll build our app and get it uploaded with Xcode. Then you’ll come back to finish the listing. You can learn more about managing your app in iTunes Connect from the official documentation.",
    "anchor": "Creating-the-app-listing",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 550,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Building the app for production",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This will compile the web assets (and if \"--ide\" param is also specified, it will open up Xcode where you need to trigger a release build).",
    "anchor": "Building-the-app-for-production",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 551,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Configuring the project in Xcode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Once Xcode opens up the project (\"--ide\" param required), you should see the details about your app in the general view. You should just check that the bundle identifier is set up correctly, so that it’s the same as the value you specified earlier in the app ID. Also, make sure that the version and build numbers are correct. Team option should be set to your Apple developer account. Under the deployment target you can choose which devices your application will support.",
    "anchor": "Configuring-the-project-in-Xcode",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 552,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Creating an archive of the application",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In Xcode, select Product > Scheme > Edit Scheme to open the scheme editor. Next, select the Archive from the list on the left-hand side. Make sure that the Build configuration is set to Release. To create an archive, choose a Generic iOS Device, or your device if it’s connected to your Mac (you can’t create an archive if simulator is selected), from the Scheme toolbar menu in the project editor. Next, select Product > Archive, and the Archive organizer appears and displays the new archive. At this point you can click the Upload to App Store... button, and if everything goes fine you’ll have an uploaded app, and the only thing that’s left to do is to complete the iTunes Connect listing and submit it for review! At this point you should get an email from iTunes Connect shortly after you uploaded the archive with the content.",
    "anchor": "Creating-an-archive-of-the-application",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 553,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Finishing the app list process",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now you should head back to the iTunes Connect portal and login. Next, click on the Pricing and Availability on the left-hand side under APP STORE INFORMATION. You don’t have to worry about forgetting to insert any crucial and required information about your application, since you’ll be notified about what’s missing and what needs to be added/changed if you try to submit the app for review before all details are filled in. Next, click on the 1.0 Prepare for Submission button on the left-hand side, as shown on the image below. When we uploaded our archive, iTunes Connect automatically determined which device sizes are supported. You’ll need to upload at least one screenshot image for each of the various app sizes that were detected by iTunes Connect. Next, you’ll have to insert Description, Keywords, Support URL and Marketing URL (optionally). In the Build section you have to click on the + button and select the build that was uploaded through Xcode in the previous steps. Next, you’ll have to upload the icon, edit the rating, and set some additional info like copyright and your information. Note that the size of the icon that you’ll have to upload here will have to be 1024 by 1024 pixels. Thankfully, you can use the splash.png from the second tutorial. If you’re the sole developer then the data in the App Review Information should be your own. Finally, as the last option, you can leave the default checked option that once your app is approved that it is automatically released to the App Store. Now that we’re finished with adding all of the details to the app listing, we can press Save and then Submit for Review. Finally, you’ll be presented with the last form that you’ll have to fill out. After you submit your app for review you’ll see the status of it in the My Apps as Waiting for review, as shown on the image below. Also, shortly after you submit your app for review you’ll get a confirmation email from iTunes Connect that your app is in review. Apple prides itself with a manual review process, which basically means it can take several days for your app to be reviewed. You’ll be notified of any issues or updates to your app status.",
    "anchor": "Finishing-the-app-list-process",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 554,
    "hierarchy_lvl0": "Developing Capacitor Apps",
    "hierarchy_lvl1": "Publishing to Store",
    "hierarchy_lvl2": "iOS Publishing",
    "hierarchy_lvl3": "Updating the app",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since you’ll probably want to update your app at some point you’ll first need to bump the app version (from /package.json), then rebuild the app for release. Once Xcode opens, follow the same steps all over again. Once you submit for the review, you’ll have to wait for the review process again.",
    "anchor": "Updating-the-app",
    "url": "/quasar-cli/developing-capacitor-apps/publishing-to-store"
  },
  {
    "objectID": 555,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction about the technology behind Quasar desktop apps.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/introduction"
  },
  {
    "objectID": 556,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrade guide on Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Upgrading instructions when dealing with Electron in Quasar.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 557,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrade guide on Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Before upgrading Electron, please consult its release notes. Are there breaking changes?",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 558,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrading from Quasar v1",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that there's no electron-main.dev.js file anymore (not needed anymore) and that the electron-preload/main.js files need to be moved directly under /src-electron.",
    "anchor": "Upgrading-from-Quasar-v1",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 559,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrading from Quasar v1",
    "hierarchy_lvl3": "The electron-main.js file",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "The-electron-main.js-file",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 560,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrading from Quasar v1",
    "hierarchy_lvl3": "The electron-preload.js file",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More info: preload script.  You will need to transfer all the Node.js stuff away from your renderer thread (the UI code from /src) and into the preload script. Provide the same functionality through the contextBridge as seen below.  This is the default content of electron-preload.js:",
    "anchor": "The-electron-preload.js-file",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 561,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrading from Quasar v1",
    "hierarchy_lvl3": "Quasar.conf changes",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Quasar.conf-changes",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 562,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrading from Quasar v1",
    "hierarchy_lvl3": "Renderer thread (/src)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Furthermore, the openURL util can no longer tap into Electron to open a new window. You will need to provide your own util from the preload script.  You will need to transfer all the Node.js stuff away from your renderer thread (the UI code from /src) and into the preload script. Provide the same functionality through the contextBridge as seen in the preload script section above.",
    "anchor": "Renderer-thread-(%2Fsrc)",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 563,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Upgrade guide",
    "hierarchy_lvl2": "Upgrading from Quasar v1",
    "hierarchy_lvl3": "Browser Devtools",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Browser-Devtools",
    "url": "/quasar-cli/developing-electron-apps/electron-upgrade-guide"
  },
  {
    "objectID": 564,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to add Electron mode into a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/preparation"
  },
  {
    "objectID": 565,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Every Electron app has two threads: the main thread (deals with the window and initialization code -- from the newly created folder /src-electron) and the renderer thread (which deals with the actual content of your app from /src). The new folder has the following structure:",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/preparation"
  },
  {
    "objectID": 566,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for Electron",
    "hierarchy_lvl3": "A note for Windows Users",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The first item we need to check is our npm version and ensure that it is not outdated. This is accomplished using npm-windows-upgrade. If you are using yarn, then you can skip this check. Once that is complete, we can then continue to setup the needed build tools. Using windows-build-tools, most of the dirty work is done for us. Installing this globally will in turn setup Visual C++ packages, Python, and more.  Note: April 2019 In Powershell.exe (Run as Admin) npm install --global windows-build-tools seems to fail at the moment with errors pointing to python2 and vctools. You can get around this with Chocolatey. One-liner install: Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) and then run choco upgrade python2 visualstudio2017-workload-vctools.  At this point things should successfully install, but if not then you will need a clean installation of Visual Studio. Please note that these are not problems with Quasar, but they are related to NPM and Windows.",
    "anchor": "A-note-for-Windows-Users",
    "url": "/quasar-cli/developing-electron-apps/preparation"
  },
  {
    "objectID": 567,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "2. Start Developing",
    "hierarchy_lvl3": "A note for Windows Users",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This will add Electron mode automatically, if it is missing. It will open up an Electron window which will render your app along with Developer Tools opened side by side.",
    "anchor": "2.-Start-Developing",
    "url": "/quasar-cli/developing-electron-apps/preparation"
  },
  {
    "objectID": 568,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Configuring Electron",
    "hierarchy_lvl2": "Configuring Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage your Electron apps with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/configuring-electron"
  },
  {
    "objectID": 569,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Configuring Electron",
    "hierarchy_lvl2": "Configuring Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The \"packager\" prop refers to electron-packager options. The dir and out properties are overwritten by Quasar CLI to ensure the best results. The \"builder\" prop refers to electron-builder options.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/configuring-electron"
  },
  {
    "objectID": 570,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "App Icons for Electron",
    "hierarchy_lvl2": "App Icons for Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Desktop Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/app-icons-electron"
  },
  {
    "objectID": 571,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "App Icons for Electron",
    "hierarchy_lvl2": "App Icons for Electron",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/app-icons-electron"
  },
  {
    "objectID": 572,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "App Icons for Electron",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-electron-apps/app-icons-electron"
  },
  {
    "objectID": 573,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Electron Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a desktop app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/build-commands"
  },
  {
    "objectID": 574,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Electron Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It opens up an Electron window with dev-tools included. You have HMR for the renderer process and changes to main process are also picked up (but the latter restarts the Electron window on each change). Check how you can tweak Webpack config Object for the Main Process and the Preload script on the Configuring Electron page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/build-commands"
  },
  {
    "objectID": 575,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Electron Build Commands",
    "hierarchy_lvl3": "Chrome DevTools",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Chrome-DevTools",
    "url": "/quasar-cli/developing-electron-apps/build-commands"
  },
  {
    "objectID": 576,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": "Chrome DevTools",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It builds your app for production and then uses electron-packager to pack it into an executable. Check how to configure this on Configuring Electron page. If you want a production build with debugging enabled for the UI code:",
    "anchor": "Building-for-Production",
    "url": "/quasar-cli/developing-electron-apps/build-commands"
  },
  {
    "objectID": 577,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": "A note for non-Windows users",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can specify using electron-builder to build your app either directly on the command line (--bundler builder) or by setting it explicitly within quasar.conf.js at electron.bundler. This flag has no effect when using electron-packager. Currently (June 2019) supported publishing destinations include Github, Bintray, S3, Digital Ocean Spaces, or a generic HTTPS server. More information, including how to create valid publishing instructions, can be found here. Valid options for -P are \"onTag\", \"onTagOrDraft\", \"always\" and \"never\" which are explained at the above link. In addition, you must have valid publish configuration instructions in your quasar.conf.js at electron.builder. A very basic configuration to publish a Windows EXE setup file to Amazon S3 might look like this:",
    "anchor": "A-note-for-non-Windows-users",
    "url": "/quasar-cli/developing-electron-apps/build-commands"
  },
  {
    "objectID": 578,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preload Script",
    "hierarchy_lvl2": "Electron Preload Script",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to handle Electron Node Integration with an Electron Preload script with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-preload-script"
  },
  {
    "objectID": 579,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preload Script",
    "hierarchy_lvl2": "Electron Preload Script",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since the preload script runs from Node.js, be careful what you do with it and what you expose to the renderer thread!",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-preload-script"
  },
  {
    "objectID": 580,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preload Script",
    "hierarchy_lvl2": "How to use it",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Make sure that your /src-electron/electron-main.[js|ts] has the following (near the \"webPreferences\" section): Example of /src-electron/main-process/electron-preload.[js|ts] content:  1. Be aware that this file runs in a Node.js context. 2. If you import anything from node_modules, then make sure that the package is specified in /package.json > dependencies and NOT in devDependencies.",
    "anchor": "How-to-use-it",
    "url": "/quasar-cli/developing-electron-apps/electron-preload-script"
  },
  {
    "objectID": 581,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preload Script",
    "hierarchy_lvl2": "Security considerations",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It directly exposes a powerful API without any kind of argument filtering. This would allow any website to send arbitrary IPC messages which you do not want to be possible. The correct way to expose IPC-based APIs would instead be to provide one method per IPC message.",
    "anchor": "Security-considerations",
    "url": "/quasar-cli/developing-electron-apps/electron-preload-script"
  },
  {
    "objectID": 582,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Preload Script",
    "hierarchy_lvl2": "Custom path to the preload script",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Custom-path-to-the-preload-script",
    "url": "/quasar-cli/developing-electron-apps/electron-preload-script"
  },
  {
    "objectID": 583,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Packages",
    "hierarchy_lvl2": "Electron Packages",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of Electron packages available in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-packages"
  },
  {
    "objectID": 584,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Accessing files",
    "hierarchy_lvl2": "Electron Accessing Files",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to access files in a Quasar desktop app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-accessing-files"
  },
  {
    "objectID": 585,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Accessing files",
    "hierarchy_lvl2": "Electron Accessing Files",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-accessing-files"
  },
  {
    "objectID": 586,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Accessing files",
    "hierarchy_lvl2": "Read & Write Local Files",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We can use the userData directory, which is reserved specifically for our application, so we can have confidence other programs or other user interactions should not tamper with this file space. If for some reason, you have important files that you are storing in the /public folder, you can access those too by following the code below. To understand why you need to access them this way, please read the \"Using dirname & filename\" section above.",
    "anchor": "Read-%26-Write-Local-Files",
    "url": "/quasar-cli/developing-electron-apps/electron-accessing-files"
  },
  {
    "objectID": 587,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Frameless Electron Window",
    "hierarchy_lvl2": "Frameless Electron Window",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to hide the window frame in a Quasar desktop app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/frameless-electron-window"
  },
  {
    "objectID": 588,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Frameless Electron Window",
    "hierarchy_lvl2": "Frameless Electron Window",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that we need to explicitly enable the remote module too. We'll be using it in the preload script to provide the renderer thread with the window minimize/maximize/close functionality.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/frameless-electron-window"
  },
  {
    "objectID": 589,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Frameless Electron Window",
    "hierarchy_lvl2": "Frameless Electron Window",
    "hierarchy_lvl3": "The preload script",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "The-preload-script",
    "url": "/quasar-cli/developing-electron-apps/frameless-electron-window"
  },
  {
    "objectID": 590,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Frameless Electron Window",
    "hierarchy_lvl2": "Renderer thread",
    "hierarchy_lvl3": "The preload script",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What this does is that it allows the user to drag the app window when clicking, holding and simultaneously dragging the mouse on the screen. While this is a good feature, you must also take into account that you'll need to specify some exceptions. There may be elements in your custom statusbar that you do not want to trigger the window dragging. By default, QBtn is excepted from this behavior (no need to do anything for this). Should you want to add exceptions to any children of the element having q-electron-drag class, you can attach the q-electron-drag--exception CSS class to them. Example of adding an exception to an icon:",
    "anchor": "Renderer-thread",
    "url": "/quasar-cli/developing-electron-apps/frameless-electron-window"
  },
  {
    "objectID": 591,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Frameless Electron Window",
    "hierarchy_lvl2": "Renderer thread",
    "hierarchy_lvl3": "Minimize, maximize and close app",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example above, notice that we add q-electron-drag to our QBar and we also add handlers for the minimize, maximize and close app buttons by using the injected window.myWindowAPI Object (from the Electron preload script).",
    "anchor": "Minimize%2C-maximize-and-close-app",
    "url": "/quasar-cli/developing-electron-apps/frameless-electron-window"
  },
  {
    "objectID": 592,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Electron Security Concerns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The things you should know about security in a Quasar desktop app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 593,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Electron Security Concerns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Under no circumstances should you load and execute remote code. Instead, use only local files (packaged together with your application) to execute Node.js code in your main thread and/or preload script.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 594,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Checklist: Security Recommendations",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Make sure that you leave webPreferences > contextIsolation set to true. Use the preload script to inject only must-have APIs to the renderer thread. If you must load remote content and cannot work around that, then only load secure content Use ses.setPermissionRequestHandler() in all sessions that load remote content Do not disable webSecurity Do not set allowRunningInsecureContent to true Do not enable experimental features Do not use enableBlinkFeatures <webview>: Do not use allowpopups <webview>: Verify options and params Disable or limit navigation Disable or limit creation of new windows Except for items 3 and 4 above, Electron will put a warning in the dev console if one of the these issues have been detected.",
    "anchor": "Checklist%3A-Security-Recommendations",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 595,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Tips and Tricks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "use strong crypto (i.e. collision resistant and not md5) do not invent a novel type of encryption follow the implementation instructions explicitly think about the user-experience",
    "anchor": "Tips-and-Tricks",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 596,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Tips and Tricks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Disable developer tools in production",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You probably don't want rogue hoody-wearing menaces to be executing something like this in the console of your app: The key-combination <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>I</kbd> (or <kbd>ALT</kbd>+<kbd>CMD</kbd>+<kbd>I</kbd> on Mac) will open the dev tools and enable inspection of the application. It will even enable some degree of modification. Prevent the simple evil maid attack by catching these keypresses and return false.",
    "anchor": "Disable-developer-tools-in-production",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 597,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Tips and Tricks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Publish checksums",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Publish-checksums",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 598,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Tips and Tricks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Sign the builds",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Permit only GPG-signed commits to be merged and require at least two team members (who did not make the PR) to review and approve the commit. Reconsider your node package management system: - use a private npm registry (like JFrog) - fix your packages to specific versions known to work - use pnpm - audit each and every single module and its dependencies",
    "anchor": "Sign-the-builds",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 599,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Electron Security Concerns",
    "hierarchy_lvl2": "Tips and Tricks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": "Pay to get hacked",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Parts of this page have been taken from the official Electron Security Guide.",
    "anchor": "Pay-to-get-hacked",
    "url": "/quasar-cli/developing-electron-apps/electron-security-concerns"
  },
  {
    "objectID": 600,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Troubleshooting and Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks for a Quasar desktop app with Electron.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 601,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Troubleshooting and Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "While we're at it, why not also open devtools by default when we're on dev mode.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-electron-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 602,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Debugging Main Process",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Debugging-Main-Process",
    "url": "/quasar-cli/developing-electron-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 603,
    "hierarchy_lvl0": "Developing Electron Apps",
    "hierarchy_lvl1": "Troubleshooting and Tips",
    "hierarchy_lvl2": "Application does not open on Windows with Dark Theme",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please follow electron bug report for more details.",
    "anchor": "Application-does-not-open-on-Windows-with-Dark-Theme",
    "url": "/quasar-cli/developing-electron-apps/troubleshooting-and-tips"
  },
  {
    "objectID": 604,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is a Browser Extension",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction on what a Browser Extension (BEX) is.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/introduction"
  },
  {
    "objectID": 605,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is a Browser Extension",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "They are built on web technologies such as HTML, JavaScript, and CSS and will aim to fulfill a single purpose. A single BEX can be built in any way the user deems fit but must contribute towards fulfilling that single purpose. Here a few things a BEX can do: Override page content Add to (or alter) the browser's interface Intercept page requests Be a full featured app that runs in the browser. Interact with and alter the development tools of the browser. We've all used Browser Extensions in some capacity. Quasar BEX allows you to do anything a browser extension allows but with the simplicity Quasar offers in all other modes.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/introduction"
  },
  {
    "objectID": 606,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "What is a Browser Extension",
    "hierarchy_lvl3": "Supported Browsers",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Whilst BEX mode has been tested and developed on Firefox and Chrome, all Chromium based browsers should be supported. Where Chrome is mentioned in the documentation, you can safely assume this will apply to the various Chromium browsers as well. If in doubt, refer to the specific browser documentation for clarification.",
    "anchor": "Supported-Browsers",
    "url": "/quasar-cli/developing-browser-extensions/introduction"
  },
  {
    "objectID": 607,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for BEX",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to add the Browser Extension (BEX) mode into a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/preparation"
  },
  {
    "objectID": 608,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "Preparation for BEX",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want to jump right in and start developing, you can skip the \"quasar mode\" command and issue: This will add BEX mode automatically, if it is missing adding a src-bex folder to your project. tip The src-bex folder is just a standard browser extension folder so you are free to use it as you would any other browser extension project folder. Please refer to supported Browser Extension documentation to learn more. Mozilla FireFox Browser Extension Documentation Google Chrome Browser Extension Documentation Other Chromium Based Browsers Refer to their specific documentation.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/preparation"
  },
  {
    "objectID": 609,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Preparation",
    "hierarchy_lvl2": "2. Understand The Anatomy Of src-bex",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The new folder has the following structure: bash . └── src-bex/ ├── css # CSS to use in the Browser Context | ├── content-css.css # CSS file which is auto injected into the consuming webpage via the manifest.json ├── icons/ # Icons of your app for all platforms | ├── icon-16x16.png # Icon file at 16px x 16px | ├── icon-48x48.png # Icon file at 48px x 48px | └── icon-128x128.png # Icon file at 128px x 128px ├── js/ # Javascript files used within the context of the BEX. | ├── background.js # Standard background script BEX file - auto injected via manifest.json | ├── background-hooks.js # Background script with a hook into the BEX communication layer | ├── content-hooks.js # Content script script with a hook into the BEX communication layer | ├── content-script.js # Standard content script BEX file - auto injected via manifest.json | └── dom-hooks.js # JS file which is injected into the DOM with a hook into the BEX communication layer └── www/ # Compiled BEX source - compiled from /src (Quasar app) └── manifest.json # Main thread code for production The next section will discuss these in more detail.",
    "anchor": "2.-Understand-The-Anatomy-Of-src-bex",
    "url": "/quasar-cli/developing-browser-extensions/preparation"
  },
  {
    "objectID": 610,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Configuring BEX",
    "hierarchy_lvl2": "Configuring BEX",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage your Browser Extensions with Quasar CLI.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/configuring-bex"
  },
  {
    "objectID": 611,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Configuring BEX",
    "hierarchy_lvl2": "Configuring BEX",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Runs in its own tab in the browser Runs in the Developer Tools window. Runs in a Popup window. Runs as Options window. Runs in the context of a web page (injected into a website) You do not need a new Quasar App per BEX type above as a single Quasar Application can run in all of the instances above. You can find out more about these in the types section.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/configuring-bex"
  },
  {
    "objectID": 612,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Configuring BEX",
    "hierarchy_lvl2": "Manifest.json",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The most important config file for your BEX is /src-bex/manifest.json. It is recommended that you read up on this file before starting your project. When you create your Quasar BEX, the manifest file is already configured to add the basic properties you will need in order to run your BEX. This includes default background scripts, content scripts and a css file which is injected in the context of the web page the BEX is running on. tip Be aware that the manifest.json file is modified on build so as to auto inject required javascript files.",
    "anchor": "Manifest.json",
    "url": "/quasar-cli/developing-browser-extensions/configuring-bex"
  },
  {
    "objectID": 613,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Configuring BEX",
    "hierarchy_lvl2": "Background And Content Scripts",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Behind every BEX is a content script and a background script. It's a good idea to understand what each of these are before writing your first BEX. In summary: Background Script runs in the context of the BEX itself and can listen to all available browser extension events. There will only ever be one instance of each background script per BEX. Content Script runs in the context of the web page. There will be a new content script instance per tab running the extension. tip Given content scripts run in the web page context, this means that only BEX's that interact with a web page can use content scripts. Popups, Options and Devtools will not have a content script running behind them. They will all however have a background script.",
    "anchor": "Background-And-Content-Scripts",
    "url": "/quasar-cli/developing-browser-extensions/configuring-bex"
  },
  {
    "objectID": 614,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Configuring BEX",
    "hierarchy_lvl2": "CSS",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Any styles you want to be made available to your web page (not your Quasar App) should be included in src-bex/css/content-css.css as this file ia automatically injected into the manifest.json file. warning This must be native CSS as it's not preprocessed via Sass.",
    "anchor": "CSS",
    "url": "/quasar-cli/developing-browser-extensions/configuring-bex"
  },
  {
    "objectID": 615,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Configuring BEX",
    "hierarchy_lvl2": "Hook Files",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In a Quasar BEX, you are provided with background-hook.js, content-hook.js and dom-hook.js. These files are designed to give you access to a bridge which closes the gap in communication with each layer of a BEX. We will explore them in more detail in the next section.",
    "anchor": "Hook-Files",
    "url": "/quasar-cli/developing-browser-extensions/configuring-bex"
  },
  {
    "objectID": 616,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "App Icons for BEX",
    "hierarchy_lvl2": "App Icons for (BEX)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to manage the app icons for a Quasar Browser Extension (BEX).",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/app-icons-browser-extension"
  },
  {
    "objectID": 617,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "App Icons for BEX",
    "hierarchy_lvl2": "App Icons for (BEX)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI, because it consumes a source icon and automatically clones, scales, minifies and places the icons in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.  Quickly bootstrap the necessary images with Icon Genie CLI. For a complete list of options, please visit the Icon Genie CLI command list page.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/app-icons-browser-extension"
  },
  {
    "objectID": 618,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "App Icons for BEX",
    "hierarchy_lvl2": "Manual instructions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Manual-instructions",
    "url": "/quasar-cli/developing-browser-extensions/app-icons-browser-extension"
  },
  {
    "objectID": 619,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "BEX Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar CLI list of commands when developing or building a Browser Extension (BEX).",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 620,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "BEX Build Commands",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Start developing a Browser Extension with just one command. You may or may not have already had a src-bex folder, but you will definitely have one now. You will also have a set of files under src-bex/www. These files are the output from the webpack development server. Normally, these files are kept in memory, which is why you wouldn't see them when creating an SPA, but for Browser Extension development, physical files are required in order for the process to work.  Do not edit anything under the src-bex/www folder, as these changes are overridden via Hot Module Reloading (HMR). This folder is just the built output of your src folder, so make the changes there instead.  Now that we've created a development environment, we need to load generated browser extension into your browser.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 621,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "BEX Build Commands",
    "hierarchy_lvl3": "Chrome",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In line with the screenshot above, the following steps must be taken: In Chrome, navigate to chrome://extensions Toggle \"Developer Mode\". Click \"Load unpacked\". This will present you with the folder selection dialog. Navigate to and select your src-bex folder. You should now see your BEX mounted in Chrome. More information about debugging Chrome Browser Extensions can be found in the official documentation.",
    "anchor": "Chrome",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 622,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "BEX Build Commands",
    "hierarchy_lvl3": "Other Chromium Browsers",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Although we haven't tested all the various Chromium based browsers, BEX mode should be compatible with them. Please refer to the appropriate browser documentation on how to add a browser extension to that particular browser.",
    "anchor": "Other-Chromium-Browsers",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 623,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "BEX Build Commands",
    "hierarchy_lvl3": "Firefox",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In line with the screenshot above, the following steps must be taken: In Firefox, navigate to about:debugging Click on \"This Firefox\" Click \"Load Temporary Add-on...\". This will present you with the file selection dialog. Navigate to and select your src-bex/manifest.json file. Note: Firefox requires the manifest file, not the src-bex folder like Chromium browsers. You should now see your BEX mounted in Firefox. More information about debugging Firefox temporary addons can be found in the Firefox Extension Workshop.",
    "anchor": "Firefox",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 624,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "BEX Build Commands",
    "hierarchy_lvl3": "Hot Module Reloading (HMR)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "HMR works with Browser Extension development but does work slightly differently depending on which browser you're developing on. In both cases, the Quasar application being built will reload when changes are made. The quasar application in this instance would refer to changes made to everything under the src folder.  Chrome vs Firefox Nuances - When developing your Browser Extension, you will often need to make changes to the files under the src-bex folder as well. This will be done when configuring hooks, setting up popups etc. Firefox will see these changes and automatically re-load the Browser Extension. Chrome on the other hand will not. When you have made these changes in Chrome, you will need to navigate to your Extension (see the Chrome section above) and click on the refresh icon in your Development Browser Extension.",
    "anchor": "Hot-Module-Reloading-(HMR)",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 625,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": "Hot Module Reloading (HMR)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The new folder has the following structure: bash . └── dist/ ├── UnPackaged/ # Built code ready for testing in your development environment └── Packaged/ ├── Chrome | └── your-project-name.zip # A zip file ready for submission to the Chrome Browser Extension Store / Other Chromium based stores. └── Firefox └── your-project-name.zip # A zip file ready for submission to the Firefox Extension Store  If you want to test out the your-project-name.zip file, you can do this by dragging the file into the same place you load the Extension in development mode; for Chrome chrome://extensions and Firefox about:debugging. See the development screenshots above for more information.",
    "anchor": "Building-for-Production",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 626,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Building for Production",
    "hierarchy_lvl3": "A Note on Minification",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Part of the review process for Browser Extensions in both Chrome and Firefox must allow the relative teams to examine the code being deployed as a live extension. With this in mind, minified code is not allowed. So, to allow for the review process, Quasar will not obfuscate and minify the built code for Browser Extensions. Given any extension will be ran directly on the user's computer, upload speed isn't a factor to worry about here, so minifying the code isn't necessary.",
    "anchor": "A-Note-on-Minification",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 627,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Build Commands",
    "hierarchy_lvl2": "Publishing to the Stores",
    "hierarchy_lvl3": "A Note on Minification",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since Quasar removes the burden of building and packaging your Browser Extension, once you are finished developing your extension, it is ready to be published. The publishing process differs between browsers, but the official documentation will guide you through the process. Chrome - Publishing a Chrome Browser Extension Firefox - Publishing a Firefox Add On (Browser Extension)  BEX mode should be compatible with all chromium based browsers. Please refer to their relative documentation on publishing extensions.",
    "anchor": "Publishing-to-the-Stores",
    "url": "/quasar-cli/developing-browser-extensions/build-commands"
  },
  {
    "objectID": 628,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Types of BEX",
    "hierarchy_lvl2": "Types of BEX",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to configure each type of Browser Extensions in Quasar.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/types-of-bex"
  },
  {
    "objectID": 629,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Types of BEX",
    "hierarchy_lvl2": "Types of BEX",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This is the default way in which a BEX will run. It is accessed by clicking on the BEX icon in your browser. The Quasar App will run in that new (blank) tab.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/types-of-bex"
  },
  {
    "objectID": 630,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Types of BEX",
    "hierarchy_lvl2": "Dev Tools, Options and Popup",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "These all follow the same pattern, set up a route and configure the manifest.json file to look at that route when it's trying to show either one of the types. For instance: You could configure your manifest.json file with the following so the options page is loaded from that route:",
    "anchor": "Dev-Tools%2C-Options-and-Popup",
    "url": "/quasar-cli/developing-browser-extensions/types-of-bex"
  },
  {
    "objectID": 631,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Types of BEX",
    "hierarchy_lvl2": "Web Page",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This is where the real power comes in. With a little ingenuity we can inject our Quasar application into a web page and use it as an overlay making it seem like our Quasar App is part of the page experience. Here's a brief rundown of how you could achieve this: src-bex/js/content-hooks.js The idea here is to create an IFrame and add our Quasar app into it, then inject that into the page. Given our Quasar App might need to take the full height of the window (and thus stop any interaction with the underlying page) we have an event to handle setting the height of the IFrame. By default the IFrame height is just high enough to allow for the Quasar toolbar to show (and in turn allowing interaction with the rest of the page). We can call this event from our Quasar App any time we know we're opening the drawer and thus changing the height of the IFrame to allow the whole draw to be visible. src-bex/css/content-css.css Add a margin to the top of our document so our Quasar toolbar doesn't overlap the actual page content. Quasar App Then in our Quasar app (/src), we have a function that toggles the drawer and sends an event to the content script telling it to resize the IFrame thus allowing our whole app to be visible: Now you have a Quasar App running in a web page. You can now trigger other events from the Quasar App that the content script can listen to and interact with the underlying page.",
    "anchor": "Web-Page",
    "url": "/quasar-cli/developing-browser-extensions/types-of-bex"
  },
  {
    "objectID": 632,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "BEX Communication",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to communicate between different parts of your Browser Extension (BEX) in Quasar.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 633,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "BEX Communication",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Quasar App itself - this is true for all types of BEX i.e Popup, Options Page, Dev Tools or Web Page Background Script Content Script The web page that the BEX is running on",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 634,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "Communication Rules",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There is a fundamental rule to understand with the communication bridge in Quasar. Not all BEX types have a content script - Only BEX which run in the context of a web page will have a content script. This is how browser extensions in general work. This means if you're adding a listener for an event on a content script and trying to trigger it from a Quasar BEX running as Dev Tools, Options Page or Popup - it won't work. If you want to allow your Dev Tools, Popup or Options Page BEX to communicate with a web page, you will need to use the background script as a proxy. You would do this by: Adding a listener on the background script which in turn emits another event. Add a listener to your Quasar App running in the Web Page context which listens for the event the background script is raising Emitting the event to your background script from your Dev Tools, Popup or Options Page. Once you get your head around this concept, there are no limits to how the BEX can communicate with each part.",
    "anchor": "Communication-Rules",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 635,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "The Bridge",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The bridge is a promise based event system which is shared between all parts of the BEX and as such allows you to listen for events in your Quasar App, emit them from other parts or vice versa. This is what gives Quasar BEX mode it's power. To access the bridge from within your Quasar App you can use $q.bex. In other areas, the bridge is made available via the bridge parameter in the respective hook files. Let's see how it works.",
    "anchor": "The-Bridge",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 636,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "The Bridge",
    "hierarchy_lvl3": "Trigger an event and wait for the response",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Trigger-an-event-and-wait-for-the-response",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 637,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "The Bridge",
    "hierarchy_lvl3": "Listen for an event and sending a response",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Listen-for-an-event-and-sending-a-response",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 638,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "BEX Communication / Events",
    "hierarchy_lvl2": "The Bridge",
    "hierarchy_lvl3": "Clean up your listeners",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Wait, what's bridge.send(event.eventResponseKey)? The Quasar bridge does some work behind the scenes to convert the normal event based communication into promises and as such, in order for the promise to resolve, we need to send a new event which is captured and promisified. warning If you omit bridge.send(event.eventResponseKey) the promise on .send() will not resolve.  tip The bridge also does some work to split large data which is too big to be transmitted in one go due to the browser extension 60mb data transfer limit. In order for this to happen, the payload must be an array.",
    "anchor": "Clean-up-your-listeners",
    "url": "/quasar-cli/developing-browser-extensions/bex-communication"
  },
  {
    "objectID": 639,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Background Hooks",
    "hierarchy_lvl2": "Background Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to communicate using your background script with other parts of your Browser Extension (BEX).",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/background-hooks"
  },
  {
    "objectID": 640,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Background Hooks",
    "hierarchy_lvl2": "Background Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The added benefit of this file is this function: This function is called automatically via the Quasar BEX build chain and injects a bridge which is shared between all parts of the BEX meaning you can communicate with any part of your BEX. The bridge param is the bridge to use for communication. The activeConnections param provides an array of all the BEX connections registered via the bridge i.e All the Web Page, Options, Popup and Dev Tools BEX's used by the same Quasar App. For example, let's say we want to listen for a new tab being opened in the web browser and then react to it in our Quasar App. First, we'd need to listen for the new tab being opened and emit a new event to tell the Quasar App this has happened: Then in our Quasar App, we'd listen for this in one of our component lifecycle hooks, like so: There are wide variety of events available to the browser extension background script - Google is your friend if you're trying to do something in this area. What if you want to modify the underlying web page content in some way? That's where we'd use content-hooks.js. Let's look at that in the next section.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/background-hooks"
  },
  {
    "objectID": 641,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Content Hooks",
    "hierarchy_lvl2": "Content Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to communicate using your content script with your Quasar App and Background Script in Quasar Browser Extension mode.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/content-hooks"
  },
  {
    "objectID": 642,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "Content Hooks",
    "hierarchy_lvl2": "Content Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The added benefit of this file is this function: This function is called automatically via the Quasar BEX build chain and injects a bridge which is shared between your Quasar App instance and the background script of the BEX. For example, let's say we want to react to a button being pressed on our Quasar App and highlight some text on the underlying web page, this would be done via the content scripts like so: Content scripts live in an isolated world, allowing a content script to makes changes to its JavaScript environment without conflicting with the page or additional content scripts. Isolated worlds do not allow for content scripts, the extension, and the web page to access any variables or functions created by the others. This also gives content scripts the ability to enable functionality that should not be accessible to the web page. This is where dom-hooks come in.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/content-hooks"
  },
  {
    "objectID": 643,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "DOM Hooks",
    "hierarchy_lvl2": "DOM Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to communicate to the underlying web page using dom hooks in Quasar Browser Extension mode.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/dom-hooks"
  },
  {
    "objectID": 644,
    "hierarchy_lvl0": "Developing Browser Extensions",
    "hierarchy_lvl1": "DOM Hooks",
    "hierarchy_lvl2": "DOM Hooks",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you ever find yourself needing to inject a JS file into your underlying web page, you can use dom hooks instead as it means you can maintain that chain of communication in the BEX. For example, lets say you wanted to write a BEX that detects whether or not a Quasar app is running on a page, the only way to do this is by running some javascript in the context of the web page. The bridge above will notify all listeners in the BEX that Quasar has been found and along with that send the instance information.",
    "anchor": "Introduction",
    "url": "/quasar-cli/developing-browser-extensions/dom-hooks"
  },
  {
    "objectID": 645,
    "hierarchy_lvl0": "Ajax Requests",
    "hierarchy_lvl1": "Ajax Requests",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using Axios for fetching data in a Quasar app.",
    "anchor": "Introduction",
    "url": "/quasar-cli/ajax-requests"
  },
  {
    "objectID": 646,
    "hierarchy_lvl0": "Ajax Requests",
    "hierarchy_lvl1": "Ajax Requests",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you haven't selected Axios during the project initialization then you should create a new boot file axios.js that looks like this: (Here you can also specify additional settings for your axios instance) Also make sure to yarn/npm install the axios package.  Be sure to check out Prefetch Feature if you are using Quasar CLI.  Usage in your single file components methods will be like: Usage in Vuex Actions for globally adding headers to axios (such as during authentication): Also look at Axios docs for more information.",
    "anchor": "Introduction",
    "url": "/quasar-cli/ajax-requests"
  },
  {
    "objectID": 647,
    "hierarchy_lvl0": "Opening Dev Server To Public",
    "hierarchy_lvl1": "Opening Your Dev Server to the Public",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to offer temporary access to your development server to anyone on the Internet.",
    "anchor": "Introduction",
    "url": "/quasar-cli/opening-dev-server-to-public"
  },
  {
    "objectID": 648,
    "hierarchy_lvl0": "Opening Dev Server To Public",
    "hierarchy_lvl1": "Opening Your Dev Server to the Public",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you've finished with your demonstration or testing, make sure to stop localhost.run or ngrok. This will prevent any unwanted access of your computer through them.",
    "anchor": "Introduction",
    "url": "/quasar-cli/opening-dev-server-to-public"
  },
  {
    "objectID": 649,
    "hierarchy_lvl0": "Opening Dev Server To Public",
    "hierarchy_lvl1": "Opening Your Dev Server to the Public",
    "hierarchy_lvl2": "Using localhost.run (easiest)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Assuming you have an SSH shell, you only need issue the following command (substituting your details) bash $ ssh -R 80:localhost:8080 ssh.localhost.run # In case your development server doesn't run on port 8080 you need to change the number to the correct port That's it, and you will now have a random subdomain based on your current system username assigned to you like so: bash $ ssh -R 80:localhost:8080 ssh.localhost.run Connect to http://fakeusername-random4chars.localhost.run or https://fakeusername-random4chars.localhost.run Press ctrl-c to quit. It's not currently possible to request your own subdomain.",
    "anchor": "Using-localhost.run-(easiest)",
    "url": "/quasar-cli/opening-dev-server-to-public"
  },
  {
    "objectID": 650,
    "hierarchy_lvl0": "Opening Dev Server To Public",
    "hierarchy_lvl1": "Opening Your Dev Server to the Public",
    "hierarchy_lvl2": "Using Ngrok",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Download and install ngrok here. (Please note that the ngrok executable file does not need to be placed in or run from inside your cordova folder. When on a mac it's best to place the ngrok executable file inside /usr/local/bin to be able to run it globally.) Start your Dev server bash $ quasar dev Create your ngrok connection bash $ ngrok http 8080 # In case your development server doesn't run on port 8080 you need to change the number to the correct port ngrok shows the url in the command line when it started. ``` bash Tunnel Status online Version 2.0/2.0 Web Interface http://127.0.0.1:4040 Forwarding http://92832de0.ngrok.io -> localhost:8080 Forwarding https://92832de0.ngrok.io -> localhost:8080 Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 ``` Please be careful as the 'Forwarding' URL will be accessible to anyone until this connection is closed again.",
    "anchor": "Using-Ngrok",
    "url": "/quasar-cli/opening-dev-server-to-public"
  },
  {
    "objectID": 651,
    "hierarchy_lvl0": "Opening Dev Server To Public",
    "hierarchy_lvl1": "Opening Your Dev Server to the Public",
    "hierarchy_lvl2": "Using Ngrok",
    "hierarchy_lvl3": "Inspecting traffic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When running ngrok, visit http://localhost:4040 to inspect the traffic. This tool allows for custom domains, password protection and a lot more. If you require further assistance, please refer to the ngrok docs for more information.",
    "anchor": "Inspecting-traffic",
    "url": "/quasar-cli/opening-dev-server-to-public"
  },
  {
    "objectID": 652,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "Icon Genie CLI",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar tool for generating all your app's icons and splash screens in 100+ formats.",
    "anchor": "Introduction",
    "url": "/icongenie/introduction"
  },
  {
    "objectID": 653,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "Icon Genie CLI",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are many different situations where your icon might be seen: in the browser tab, on the desktop, on the home screen of a mobile phone and even in an app store. Then there are splash screens to create in all the various device sizes and orientations. This means you need your logo in about 100+ different sizes with representative names, arcane formats, placed in the correct folders and probably some proper <xml> declarations for Cordova too. Even if you know exactly what you're doing, this is a tedious and error-prone task. To make your life easy and care-free, we've built the Icon Genie CLI tool to make this exhausting process dead simple.",
    "anchor": "Introduction",
    "url": "/icongenie/introduction"
  },
  {
    "objectID": 654,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "Icon Genie CLI",
    "hierarchy_lvl2": "How it helps you",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We highly recommend using the Icon Genie CLI for your Quasar CLI-generated projects because it consumes a source icon and automatically clones, scales, minifies and places the icons and splash screens in the appropriate directories for you. When needed, it also tells you what tags you'll need to add to your /src/index.template.html file.",
    "anchor": "How-it-helps-you",
    "url": "/icongenie/introduction"
  },
  {
    "objectID": 655,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "Icon Genie CLI",
    "hierarchy_lvl2": "Requirements",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This tool was built by the Quasar Team especially with the Quasar CLI project structure in mind. If you build your project folder with another CLI, you should explore Icon Genie profile files.",
    "anchor": "Requirements",
    "url": "/icongenie/introduction"
  },
  {
    "objectID": 656,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to install the Icon Genie CLI on your development machine.",
    "anchor": "Introduction",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 657,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not use uneven versions of Node i.e. 11, 13, etc. These versions aren't tested with Quasar and often cause issues due to their experimental nature. We highly recommend always using the LTS version of Node.  You will be installing the Icon Genie CLI globally. You don't need to install it in your project folder. This will install the icongenie command line tool.  Attention developers on Windows If you get an error like \"pngquant failed to build\" then you need to also globally install windows-build-tools (\"yarn global add windows-build-tools\" or \"npm install --global windows-build-tools\"). Then go to C:\\Users\\<windows_username>\\.windows-build-tools and run vs_BuildTools.exe. From there select npm/yarn and python to install. After this step it might require you to reboot your machine, otherwise you can now install @quasar/icongenie.",
    "anchor": "Introduction",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 658,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": "Installation tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are using Yarn, make sure that the Yarn global install location is in your PATH: Under Windows, modify user's PATH environment variable. If you are using yarn then add %LOCALAPPDATA%\\yarn\\bin, otherwise if you're using npm then add %APPDATA%\\npm.",
    "anchor": "Installation-tips",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 659,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": "Upgrading to Icon Genie v2",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This section applies to those that have been using Icon Genie v1 and are now upgrading to Icon Genie v2.",
    "anchor": "Upgrading-to-Icon-Genie-v2",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 660,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": "Upgrading to Icon Genie v2",
    "hierarchy_lvl3": "NPM package name change",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Version 1 was a Quasar App Extension and so you installed it into your project folder. The new version (v2) does NOT need to be installed locally as it is installed globally. Your CI/CD will not need it as it is a one-time process and the output files (images) will be added directly to your project folder. As a consequence, please uninstall Icon Genie v1 from your project folder:",
    "anchor": "NPM-package-name-change",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 661,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": "Upgrading to Icon Genie v2",
    "hierarchy_lvl3": "Input files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "With version 1 you required to have an app-icon.png and an app-splashscreen.png (at a fixed width and height). This is no longer the case with version 2. You will now just need a png file (its name can be anything) with transparency and with minimum of 64x64 px (but the higher, the better! -- recommended min size: 1024x1024) for the icon, and then another optional png (any name) for the background of the splash screens (min 128x128 px, but recommended minimum is 1024x1024 px). The splash screens work in a completely different manner too. They will get generated with the icon on top of the optional background. The size ratio of the icon to width or height (whichever is lower) can be adjusted with the CLI params (--splashscreen-icon-ratio). You can even tell Icon Genie that the ratio is 0 so it won't add the icon on top of the background.",
    "anchor": "Input-files",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 662,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": "Upgrading to Icon Genie v2",
    "hierarchy_lvl3": "Output files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We have refined the list of icons and splash screens that are generated to match the latest standards and to also avoid duplication. So you will notice that some of the older files don't get generated anymore and some are completely new. Icon Genie will now tell you what tags you need to add (if any) to your /src/index.template.html (you can copy paste the tags and replace your old ones) -- so be mindful about the list of tags. It might be a good idea to delete all your current icon/splashscreen files and let Icon Genie do its job again. This way you will be sure that what you're left with is actually used in your Quasar App.",
    "anchor": "Output-files",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 663,
    "hierarchy_lvl0": "Installation / Upgrade notes",
    "hierarchy_lvl1": "Icon Genie CLI Installation",
    "hierarchy_lvl2": "What's new in Icon Genie v2",
    "hierarchy_lvl3": "Output files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon Genie v2 is a complete rewrite from top to bottom. Icon Genie is now a CLI on its own, not a Quasar App Extension any more. The input files (for the icon and the background) can have any name, be placed anywhere, and they don't need to have a fixed width + height. Starting with v2.1, the icon input file does not needs to have same width and height. Also, the icon input file is now automatically trimmed. You can now configure a padding for the icon input file. (v2.1+) We have refined the list of icons and splash screens that get generated to match the latest standards and to also avoid duplication. Splash screens are created in a better manner, with the icon on top of the background (with the icon having any size ratio that you want, including 0 which means: \"I only want the background image with no icon on top\") New commands: generate, verify, and profile, each with its own purpose. The generate command now also shows you what tags you need in your /src/index.template.html file. The verify command can even check if every file is in the right place and it has the right width by height. A lot of new parameters: quality, svg-color, png-color, splashscreen-color, splashscreen-icon-ratio, etc etc. Check the command list page. You can now control each type of asset (ico, png, splashscreen, ...) for each Quasar mode individually, each with its own settings/parameters. Check the --filter, --quality and all the color parameters. One good use case is with the .ico files. Automation is now possible through Icon Genie profile files. You can now generate your own custom image files using the Icon Genie API through the profile files. Finally, we need to emphasize again on the quality parameter, which will dictate how good-looking and how big (KB) your images will be.",
    "anchor": "What's-new-in-Icon-Genie-v2",
    "url": "/icongenie/installation"
  },
  {
    "objectID": 664,
    "hierarchy_lvl0": "Command list",
    "hierarchy_lvl1": "Icon Genie CLI Command List",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Command list for Icon Genie CLI.",
    "anchor": "Introduction",
    "url": "/icongenie/command-list"
  },
  {
    "objectID": 665,
    "hierarchy_lvl0": "Command list",
    "hierarchy_lvl1": "Icon Genie CLI Command List",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "See help for any command:",
    "anchor": "Introduction",
    "url": "/icongenie/command-list"
  },
  {
    "objectID": 666,
    "hierarchy_lvl0": "Command list",
    "hierarchy_lvl1": "Icon Genie CLI Command List",
    "hierarchy_lvl2": "Generate",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The generate command is used for generating app icons and splash screens. It's at the heart of Icon Genie as it does the heavy lifting. Take a look below at usage and some examples. The most important parameter to note is --icon (or -i), which takes a transparent PNG as input for your app's icons and splash screens. Minimum size of the PNG is 64x64px, but it is highly recommended to go above 1024x1024px. For splash screens, you may want to combine it with the --background (or -b) if you want your icon to be placed on top of a background. You may also want to use the --profile (or -p) parameter, which can run one or more Icon Genie profile files.",
    "anchor": "Generate",
    "url": "/icongenie/command-list"
  },
  {
    "objectID": 667,
    "hierarchy_lvl0": "Command list",
    "hierarchy_lvl1": "Icon Genie CLI Command List",
    "hierarchy_lvl2": "Verify",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The verify command confirms that you have all required app icons and splash screens in the right place and that each file has the correct resolution in pixels.",
    "anchor": "Verify",
    "url": "/icongenie/command-list"
  },
  {
    "objectID": 668,
    "hierarchy_lvl0": "Command list",
    "hierarchy_lvl1": "Icon Genie CLI Command List",
    "hierarchy_lvl2": "Profile",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon Genie also supports profile files. These files are in JSON format and tell Icon Genie which images to generate and how to generate them. The profile command is a helper to scaffold these profiles. They are very useful for automation, if needed. The generic form of a JSON profile file is: You can also generate multiple profile files (with different params/settings). For more information please head on to the Profile files page.",
    "anchor": "Profile",
    "url": "/icongenie/command-list"
  },
  {
    "objectID": 669,
    "hierarchy_lvl0": "App Icons List",
    "hierarchy_lvl1": "App Icons List",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "List of the app icons and splash screens that are generated by the Icon Genie CLI based on the Quasar mode.",
    "anchor": "Introduction",
    "url": "/icongenie/app-icons-list"
  },
  {
    "objectID": 670,
    "hierarchy_lvl0": "App Icons List",
    "hierarchy_lvl1": "App Icons List",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Here are the links to each mode's list: App Icons for SPA mode App Icons for PWA mode App Icons for SSR mode App Icons for Cordova mode App Icons for Capacitor mode App Icons for Electron mode App Icons for BEX mode",
    "anchor": "Introduction",
    "url": "/icongenie/app-icons-list"
  },
  {
    "objectID": 671,
    "hierarchy_lvl0": "Profile files",
    "hierarchy_lvl1": "Icon Genie Profile Files",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use profile files with the Icon Genie CLI.",
    "anchor": "Introduction",
    "url": "/icongenie/profile-files"
  },
  {
    "objectID": 672,
    "hierarchy_lvl0": "Profile files",
    "hierarchy_lvl1": "Icon Genie Profile Files",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "These configuration files are called \"profile files\". The files are in JSON format and tell Icon Genie which images to generate and how to generate them. They also spare you from having to remember the whole set of Icon Genie commands and parameters to generate your assets.",
    "anchor": "Introduction",
    "url": "/icongenie/profile-files"
  },
  {
    "objectID": 673,
    "hierarchy_lvl0": "Profile files",
    "hierarchy_lvl1": "Icon Genie Profile Files",
    "hierarchy_lvl2": "File structure",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The generic form of a JSON profile file is: We will be discussing each in the next sections.",
    "anchor": "File-structure",
    "url": "/icongenie/profile-files"
  },
  {
    "objectID": 674,
    "hierarchy_lvl0": "Profile files",
    "hierarchy_lvl1": "Icon Genie Profile Files",
    "hierarchy_lvl2": "File structure",
    "hierarchy_lvl3": "Params",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The params object from a JSON profile file takes the same prop names as the generate command parameters (but camelCased instead of the CLI's kebab-case). There is one key difference: instead of using mode (examples: \"spa,pwa\", \"all\") you will be writing include (examples: [ \"spa\", \"pwa\" ], [ \"all\" ]). Full list of props that you can write for the params object:",
    "anchor": "Params",
    "url": "/icongenie/profile-files"
  },
  {
    "objectID": 675,
    "hierarchy_lvl0": "Profile files",
    "hierarchy_lvl1": "Icon Genie Profile Files",
    "hierarchy_lvl2": "File structure",
    "hierarchy_lvl3": "Assets",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The assets array can contain custom definitions for extra assets, should you need them. This can be used when Icon Genie's default list for each mode is not sufficient for your use case. If you don't specify the include prop in params you can only generate your custom assets. In 99% of the cases you won't need to specify the assets array, but Icon Genie is designed to be very flexible, so it includes this feature too. Some examples for assets from which you can extract the syntax for every type of possible asset that Icon Genie can generate:",
    "anchor": "Assets",
    "url": "/icongenie/profile-files"
  },
  {
    "objectID": 676,
    "hierarchy_lvl0": "Profile files",
    "hierarchy_lvl1": "Icon Genie Profile Files",
    "hierarchy_lvl2": "Bootstrap profiles",
    "hierarchy_lvl3": "Assets",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon Genie also offers the profile command which can bootstrap JSON profile files for you. It can help you create one or more such files that you can then run in batch through the generate command with --profile param (or short -p). The most handy use case is to generate multiple profile files into one specific folder, each with their own parameters, and then run all of them through $ icongenie generate -p /path/to/folder.",
    "anchor": "Bootstrap-profiles",
    "url": "/icongenie/profile-files"
  },
  {
    "objectID": 677,
    "hierarchy_lvl0": "Typography",
    "hierarchy_lvl1": "Typography",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The typography of a Quasar app and its helper CSS classes.",
    "anchor": "Introduction",
    "url": "/style/typography"
  },
  {
    "objectID": 678,
    "hierarchy_lvl0": "Typography",
    "hierarchy_lvl1": "Typography",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Roboto comes with 5 different font weights you can use: 100, 300, 400, 500, 700. This is where Roboto font comes embedded by default, if you are looking to remove it:",
    "anchor": "Introduction",
    "url": "/style/typography"
  },
  {
    "objectID": 679,
    "hierarchy_lvl0": "Typography",
    "hierarchy_lvl1": "Typography",
    "hierarchy_lvl2": "Add custom fonts",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Copy your new webfont [customfont].woff (or whatever extension it has; recommended is woff for compatibility across all browsers) in a directory of your choice, for example: ./src/css/fonts/[customfont.woff] Declare your font in ./src/css/app.{css|sass|scss|styl} (or in any place you see fit, but correctly update the relative path to the webfont file): Then use that class where you need it.",
    "anchor": "Add-custom-fonts",
    "url": "/style/typography"
  },
  {
    "objectID": 680,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use and customize the Quasar Color Palette.",
    "anchor": "Introduction",
    "url": "/style/color-palette"
  },
  {
    "objectID": 681,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "TIPS Also check Theme Builder for a tool on customizing the brand colors of your website/app.",
    "anchor": "Introduction",
    "url": "/style/color-palette"
  },
  {
    "objectID": 682,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Color List",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Here's the list of colors provided out of the box. Within your app's *.vue files you can use them as CSS classes (in HTML templates) or as Sass/SCSS variables in <style lang=\"...\"> tags.",
    "anchor": "Color-List",
    "url": "/style/color-palette"
  },
  {
    "objectID": 683,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Using as CSS Classes",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Using-as-CSS-Classes",
    "url": "/style/color-palette"
  },
  {
    "objectID": 684,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Using Sass/SCSS Variables",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In your app's *.vue files you can use the colors as $primary, $red-1, and so on.",
    "anchor": "Using-Sass%2FSCSS-Variables",
    "url": "/style/color-palette"
  },
  {
    "objectID": 685,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Adding Your Own Colors",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now we can use this color for Quasar components: html <q-btn color=\"brand\" ... /> You can access a custom color value (hex string) in JS context with the getPaletteColor util.",
    "anchor": "Adding-Your-Own-Colors",
    "url": "/style/color-palette"
  },
  {
    "objectID": 686,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Dynamic Change of Brand Colors (Dynamic Theme Colors)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can dynamically customize the brand colors during run-time: primary, secondary, accent, dark, positive, negative, info, warning. That means you can have one build of your application with a default color theme but show it with a runtime selected one. The main color configuration is done using CSS custom properties, stored on the root element (:root). Each property has a name of --q-${name} (example: --q-primary, --q-secondary) and should have a valid CSS color as value. The CSS Custom properties use the same inheritance rules as normal CSS, so you can only redefine your desired colors and the rest will be inherited from the parent elements. The recommended workflow is to set your customized color properties on the html (document.documentElement) or body (document.body) elements. This will allow you to revert to the default color by just deleting your custom one. More info on CSS custom properties (variables) on MDN.",
    "anchor": "Dynamic-Change-of-Brand-Colors-(Dynamic-Theme-Colors)",
    "url": "/style/color-palette"
  },
  {
    "objectID": 687,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Dynamic Change of Brand Colors (Dynamic Theme Colors)",
    "hierarchy_lvl3": "Util: setCssVar",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar offers a helper function for setting Quasar CSS variables that can be used for the brand colors too: setCssVar(colorName, colorValue[, element]) Example of setting brand colors using the helper: Example of setting brand colors using the helper:",
    "anchor": "Util%3A-setCssVar",
    "url": "/style/color-palette"
  },
  {
    "objectID": 688,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Dynamic Change of Brand Colors (Dynamic Theme Colors)",
    "hierarchy_lvl3": "Util: getCssVar",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar offers a helper function for getting the value of Quasar CSS variables that can be used for brand colors too: getCssVar(colorName[, element]) Example of getting brand colors using the helper: What this helper does is wrap the raw Javascript getPropertyValue() and it's available for convenience. Here is an example of equivalent vanilla Javascript:",
    "anchor": "Util%3A-getCssVar",
    "url": "/style/color-palette"
  },
  {
    "objectID": 689,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Dynamic Change of Brand Colors (Dynamic Theme Colors)",
    "hierarchy_lvl3": "More color utils",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Besides the utils above, we also have a dedicated section in docs for handling colors that you might be interested in: Color utils.",
    "anchor": "More-color-utils",
    "url": "/style/color-palette"
  },
  {
    "objectID": 690,
    "hierarchy_lvl0": "Color Palette",
    "hierarchy_lvl1": "Color Palette",
    "hierarchy_lvl2": "Setting Up Defaults",
    "hierarchy_lvl3": "More color utils",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This is how you can set up some brand colors without tampering with the Sass variables: Or with a boot file: If you are using the Quasar UMD version or Vue CLI:",
    "anchor": "Setting-Up-Defaults",
    "url": "/style/color-palette"
  },
  {
    "objectID": 691,
    "hierarchy_lvl0": "Theme Builder",
    "hierarchy_lvl1": "Theming",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Theme builder for a Quasar app with which you can play with the brand colors.",
    "anchor": "Introduction",
    "url": "/style/theme-builder"
  },
  {
    "objectID": 692,
    "hierarchy_lvl0": "Theme Builder",
    "hierarchy_lvl1": "Theming",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Click on the colored buttons besides the layout below and when you are ready, hit the Export button at the bottom. Recommended way is to go with the Sass/SCSS form.",
    "anchor": "Introduction",
    "url": "/style/theme-builder"
  },
  {
    "objectID": 693,
    "hierarchy_lvl0": "Dark Mode",
    "hierarchy_lvl1": "Dark Mode",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Handle dark mode with Quasar.",
    "anchor": "Introduction",
    "url": "/style/dark-mode"
  },
  {
    "objectID": 694,
    "hierarchy_lvl0": "Dark Mode",
    "hierarchy_lvl1": "Dark Mode",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The advantages of Dark Mode are that: * It enhances visual ergonomics by reducing eye strain. * Provides comfort of use at night or in dark environments. * It conserves battery power mainly if the device screen is OLED or AMOLED, thereby enabling device usage for longer periods without charging.",
    "anchor": "Introduction",
    "url": "/style/dark-mode"
  },
  {
    "objectID": 695,
    "hierarchy_lvl0": "Dark Mode",
    "hierarchy_lvl1": "Dark Mode",
    "hierarchy_lvl2": "What it does",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It sets a default dark background for the pages (that you can easily override through CSS with the body.body--dark selector) All Quasar components with a dark property will have it automatically set to true. No need to do it manually. The auto-detection works by looking at prefers-color-scheme: dark media query and is dynamic. If the client browser/platform switches to/from Dark mode while your app is running, it will also update Quasar's Dark mode (if Dark mode is set to auto).",
    "anchor": "What-it-does",
    "url": "/style/dark-mode"
  },
  {
    "objectID": 696,
    "hierarchy_lvl0": "Dark Mode",
    "hierarchy_lvl1": "Dark Mode",
    "hierarchy_lvl2": "How to use it",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can easily switch between Dark mode and light mode (which is default) through the Dark Plugin.",
    "anchor": "How-to-use-it",
    "url": "/style/dark-mode"
  },
  {
    "objectID": 697,
    "hierarchy_lvl0": "Dark Mode",
    "hierarchy_lvl1": "Dark Mode",
    "hierarchy_lvl2": "How to style your app",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since your app can be in Dark mode or not, you can easily style it by taking advantage of the body tag attached CSS class: body--light or body--dark. That is if you want to support both modes. Should you wish to override the default Dark mode page background color:",
    "anchor": "How-to-style-your-app",
    "url": "/style/dark-mode"
  },
  {
    "objectID": 698,
    "hierarchy_lvl0": "Spacing",
    "hierarchy_lvl1": "CSS Spacing Classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of CSS classes supplied by Quasar to simplify the specification of responsive paddings and margins.",
    "anchor": "Introduction",
    "url": "/style/spacing"
  },
  {
    "objectID": 699,
    "hierarchy_lvl0": "Spacing",
    "hierarchy_lvl1": "CSS Spacing Classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "T - type - values: p (padding), m (margin) D - direction - values: t (top), r (right), b (bottom), l (left), a (all), x (both left & right), y (both top & bottom) S - size - values: none, auto (ONLY for specific margins: q-ml-, q-mr-, q-mx-*), xs (extra small), sm (small), md (medium), lg (large), xl (extra large) ```",
    "anchor": "Introduction",
    "url": "/style/spacing"
  },
  {
    "objectID": 700,
    "hierarchy_lvl0": "Spacing",
    "hierarchy_lvl1": "CSS Spacing Classes",
    "hierarchy_lvl2": "Examples",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Examples",
    "url": "/style/spacing"
  },
  {
    "objectID": 701,
    "hierarchy_lvl0": "Spacing",
    "hierarchy_lvl1": "CSS Spacing Classes",
    "hierarchy_lvl2": "Flex Addons",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note that there will be a noticeable bump in CSS footprint when enabling it. So only do it if you really need it. Examples: q-pa-xs-md q-pa-sm-sm q-px-md-lg q-py-md-md",
    "anchor": "Flex-Addons",
    "url": "/style/spacing"
  },
  {
    "objectID": 702,
    "hierarchy_lvl0": "Spacing",
    "hierarchy_lvl1": "CSS Spacing Classes",
    "hierarchy_lvl2": "Table of permutations",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "See more details about the Flex Addons.",
    "anchor": "Table-of-permutations",
    "url": "/style/spacing"
  },
  {
    "objectID": 703,
    "hierarchy_lvl0": "Shadows",
    "hierarchy_lvl1": "CSS Shadows (Elevation)",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of CSS classes supplied by Quasar for defining elevation on DOM elements.",
    "anchor": "Introduction",
    "url": "/style/shadows"
  },
  {
    "objectID": 704,
    "hierarchy_lvl0": "Shadows",
    "hierarchy_lvl1": "CSS Shadows (Elevation)",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The shadows above point towards the bottom of the element. If you want them to point towards the top of the element, add up before the number:",
    "anchor": "Introduction",
    "url": "/style/shadows"
  },
  {
    "objectID": 705,
    "hierarchy_lvl0": "Breakpoints",
    "hierarchy_lvl1": "Breakpoints",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar's list of CSS breakpoints.",
    "anchor": "Introduction",
    "url": "/style/breakpoints"
  },
  {
    "objectID": 706,
    "hierarchy_lvl0": "Breakpoints",
    "hierarchy_lvl1": "Breakpoints",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To learn how to use them, please visit the Visibility page. You might also want to take a look at the Introduction to Flexbox on the \"Responsive Design\" section.",
    "anchor": "Introduction",
    "url": "/style/breakpoints"
  },
  {
    "objectID": 707,
    "hierarchy_lvl0": "Breakpoints",
    "hierarchy_lvl1": "Breakpoints",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Sass",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use the breakpoints in Sass: The syntax for these variables is shown below, where <breakpoint> is to be replaced by \"xs\", \"sm\", \"md\", \"lg\" or \"xl\": There's also: If enabled (only), you can also style your content based on a particular set of CSS classes applied to document.body: screen--xs, screen--sm, ..., screen--xl.",
    "anchor": "Sass",
    "url": "/style/breakpoints"
  },
  {
    "objectID": 708,
    "hierarchy_lvl0": "Body classes",
    "hierarchy_lvl1": "Body classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar's helper classes that get added to document.body.",
    "anchor": "Introduction",
    "url": "/style/body-classes"
  },
  {
    "objectID": 709,
    "hierarchy_lvl0": "Body classes",
    "hierarchy_lvl1": "Body classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/style/body-classes"
  },
  {
    "objectID": 710,
    "hierarchy_lvl0": "Visibility",
    "hierarchy_lvl1": "CSS Visibility",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of CSS classes supplied by Quasar to manage responsiveness and visibility of components and DOM elements.",
    "anchor": "Introduction",
    "url": "/style/visibility"
  },
  {
    "objectID": 711,
    "hierarchy_lvl0": "Visibility",
    "hierarchy_lvl1": "CSS Visibility",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now on to the window width related CSS classes. You can also show some DOM element or component if it's lower than one of the sizes. Same for greater than one of the sizes. Just attach lt- or gt- prefixes, which come from \"lower than\" and \"greater than\". Example: lt-md (display on xs and sm only), lt-xl (display on xs, sm, md and lg windows only), gt-md (display on greater than medium windows: lg and xl).  You can combine the visibility classes with the inline class for inline-blocks. Example: <span class=\"gt-sm inline\">...</span>   If you want to e.g. show hide based on JavaScript properties, you can use the Screen Plugin.",
    "anchor": "Introduction",
    "url": "/style/visibility"
  },
  {
    "objectID": 712,
    "hierarchy_lvl0": "Visibility",
    "hierarchy_lvl1": "CSS Visibility",
    "hierarchy_lvl2": "Platform Related",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Hide on:  Based on your needs, you might want to also check Platform Detection page to see how you can achieve the same effect using Javascript. This latter method allows you to not even render a DOM element or component. It is useful when the rendering process is expensive.",
    "anchor": "Platform-Related",
    "url": "/style/visibility"
  },
  {
    "objectID": 713,
    "hierarchy_lvl0": "Positioning",
    "hierarchy_lvl1": "CSS Positioning Classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of CSS classes supplied by Quasar to simplify the positioning of a DOM element.",
    "anchor": "Introduction",
    "url": "/style/positioning"
  },
  {
    "objectID": 714,
    "hierarchy_lvl0": "Positioning",
    "hierarchy_lvl1": "CSS Positioning Classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Instead of using float-left or float-right we recommend that you read on the Quasar Grid System.  Vertical alignment:",
    "anchor": "Introduction",
    "url": "/style/positioning"
  },
  {
    "objectID": 715,
    "hierarchy_lvl0": "Sass/SCSS Variables",
    "hierarchy_lvl1": "Sass/SCSS Variables",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Sass/SCSS variables defined by Quasar.",
    "anchor": "Introduction",
    "url": "/style/sass-scss-variables"
  },
  {
    "objectID": 716,
    "hierarchy_lvl0": "Sass/SCSS Variables",
    "hierarchy_lvl1": "Sass/SCSS Variables",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This applies to Quasar CLI managed apps only.",
    "anchor": "Introduction",
    "url": "/style/sass-scss-variables"
  },
  {
    "objectID": 717,
    "hierarchy_lvl0": "Sass/SCSS Variables",
    "hierarchy_lvl1": "Sass/SCSS Variables",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You don't need to necessarily have the src/css/quasar.variables.sass or src/css/quasar.variables.scss files if you want to access the Quasar Sass/SCSS variables. Create one of them only if you want to customize the variables.   When creating or deleting any of the src/css/quasar.variables.* files, you will need to restart your dev server in order for it to take effect. However, when you change the content of these files it won't be necessary to also restart.",
    "anchor": "Usage",
    "url": "/style/sass-scss-variables"
  },
  {
    "objectID": 718,
    "hierarchy_lvl0": "Sass/SCSS Variables",
    "hierarchy_lvl1": "Sass/SCSS Variables",
    "hierarchy_lvl2": "Caveat",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar CLI detects if the file contains at least one '$' character, and if so, it automatically imports the Quasar Sass/SCSS variables. If, however, you have a nested importing statement and the file from which you are importing does not contain any '$' characters, this won't work. In this case, you need to add a simple comment (// $) so Quasar can detect at least one '$' character: Same is required for .sass/.scss files that are included from quasar.conf.js > css.",
    "anchor": "Caveat",
    "url": "/style/sass-scss-variables"
  },
  {
    "objectID": 719,
    "hierarchy_lvl0": "Sass/SCSS Variables",
    "hierarchy_lvl1": "Sass/SCSS Variables",
    "hierarchy_lvl2": "Customizing",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can freely override any of Quasar's variables (see next section) in those files. For convenience, if you picked Sass or SCSS when you created your Quasar project folder, these files initially contain only the brand color-related variables.  Quasar is very easy to customize without the need of tampering with the Sass/SCSS variables, so make sure that you really need to do that. Not having one of the two files will actually speed up your build while the default variables will still be supplied to .sass/.scss/.vue files.",
    "anchor": "Customizing",
    "url": "/style/sass-scss-variables"
  },
  {
    "objectID": 720,
    "hierarchy_lvl0": "Sass/SCSS Variables",
    "hierarchy_lvl1": "Sass/SCSS Variables",
    "hierarchy_lvl2": "Quasar's CSS",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Does src/css/quasar.variables.scss exists? Use that. If not, then does src/css/quasar.variables.sass exists? Use that. If not, then use pre-compiled Quasar CSS.",
    "anchor": "Quasar's-CSS",
    "url": "/style/sass-scss-variables"
  },
  {
    "objectID": 721,
    "hierarchy_lvl0": "Other Helper Classes",
    "hierarchy_lvl1": "Other CSS Helper Classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of CSS helper classes for mouse, size, orientation and border that are supplied by Quasar.",
    "anchor": "Introduction",
    "url": "/style/other-helper-classes"
  },
  {
    "objectID": 722,
    "hierarchy_lvl0": "Other Helper Classes",
    "hierarchy_lvl1": "Other CSS Helper Classes",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/style/other-helper-classes"
  },
  {
    "objectID": 723,
    "hierarchy_lvl0": "Other Helper Classes",
    "hierarchy_lvl1": "Other CSS Helper Classes",
    "hierarchy_lvl2": "Scroll Related",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Scroll-Related",
    "url": "/style/other-helper-classes"
  },
  {
    "objectID": 724,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Introduction to Flexbox",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What the flexbox CSS is and how it can be used in a Quasar App.",
    "anchor": "Introduction",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 725,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Introduction to Flexbox",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Flexbox (upon which Quasar Flex CSS classes are based) module aims to provide a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”).  This page covers the basic theory of Quasar Flex CSS classes and prepares you for the in-depth pages on Grid Row, Grid Column and Grid Gutter.",
    "anchor": "Introduction",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 726,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Key concept",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Key-concept",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 727,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Parent",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example: html <div class=\"row\"> <div>First column</div> <div>Second column</div> <div>Third column</div> </div>",
    "anchor": "Managing-Parent",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 728,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Parent",
    "hierarchy_lvl3": "Wrapping by default",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However if you explicitly do not want to wrap and by so doing you want to fit all content into one line, then add no-wrap CSS helper class. Also, if you want to wrap in reverse order, then reverse-wrap is available.",
    "anchor": "Wrapping-by-default",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 729,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Parent",
    "hierarchy_lvl3": "Alignment",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For alignment along the main axis, use classes below. It helps distribute left over free space when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line. For alignment perpendicular to the main axis, use classes below. This defines the default behavior for how flex items are laid out along the cross axis on the current line. Think of it as the horizontal-* version for the cross-axis (perpendicular to the main-axis). The next classes align a flex container's lines within when there is extra space in the cross-axis, similar to how horizontal-* aligns individual items within the main-axis.",
    "anchor": "Alignment",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 730,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Children",
    "hierarchy_lvl3": "Alignment",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example above, col-8 fills two thirds (2/3) of the row width, because 8/12 = 2/3 = 66%, while col-2 occupies one sixth (2/12 = 1/6 ~ 16.67%). CSS helper class col-auto makes the cell fill only the space it needs to be rendered. col, on the other hand, tries to fill all space available while also shrinking if needed. CSS helper class col-grow makes the cell fill at least the space it needs to be rendered, with the possibility to grow when more space is available. CSS helper class col-shrink makes the cell fill at most the space it needs to be rendered, with the possibility to shrink when not enough space is available. It is also possible to offset a cell. For example: offset-4 offsets a third of space (4/12 = 1/3 = 33%).",
    "anchor": "Managing-Children",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 731,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Children",
    "hierarchy_lvl3": "Wrapping",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This allows you, among other things, to dynamically stack rows vertically on smaller screens while displaying them on a single line on bigger screens. Read the \"Responsive Design\" section. Note that rows are wrappable by default. Should you wish to disable this, use the no-wrap CSS helper class.",
    "anchor": "Wrapping",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 732,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Children",
    "hierarchy_lvl3": "Self Alignment",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Self-Alignment",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 733,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Managing Children",
    "hierarchy_lvl3": "Order",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, flex items are laid out in source order. However, the order property controls the order in which they appear in the flex container. If you need more granularity, use order CSS property and assign the desired value. Example: html <div class=\"row\"> <div style=\"order: 2\">Second column</div> <div class=\"order-last\">Third column</div> <div class=\"order-first\">First column</div> </div> Here is how the CSS order property works:",
    "anchor": "Order",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 734,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Responsive Design",
    "hierarchy_lvl3": "Order",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What we've learned so far is that, for example, we can size the columns regardless of window width. If we are to create a responsive UI, we need to dynamically change the sizing while taking window width into account. First, let's learn about some tokens that you can inject in middle of col-*, offset-* and col-auto helper classes (look at table below for tokens). Example: col-md-7, offset-lg-3, col-xs-auto. A full example: let's say we have a row with three children. In extra small windows, we need to stack the children vertically, In small windows we need to display them side by side (each having equal width), and starting with medium windows we should display them all on same line: Notice in the above example that we used col-xs-12 (12/12 = 100% of row, so each child will take full width of the container making all children stack vertically, since rows wrap content by default), col-sm-6 (6/12 = 50% of row) and col-md-4 (4/12 = 33% of row). Like previously mentioned, rows wrap content by default, so when 12 (or more) grid points are used for a row, content is wrapped to the next line. If we have two <div>s and we use col-8 on both, they will also stack, since 8 + 8 = 16 and we can only display 12 points on a single line. Also check Visibility Style page to see thresholds on window width and these tokens (xs, sm, md, lg, xl) used on their own to hide or show DOM elements.",
    "anchor": "Responsive-Design",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 735,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Introduction to Flexbox",
    "hierarchy_lvl2": "Flex Addons",
    "hierarchy_lvl3": "Order",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When enabled (through quasar.conf > framework > cssAddon: true) it provides breakpoint aware versions for all flex (and display) related CSS classes.  Note that there will be a noticeable bump in CSS footprint when enabling it. So only do it if you really need it.  There are also responsive classes for spacing, both for padding and for margin: Examples: row-md, items-lg-end, q-pa-xs q-pa-sm-sm q-px-md-lg q-py-md-md",
    "anchor": "Flex-Addons",
    "url": "/layout/grid/introduction-to-flexbox"
  },
  {
    "objectID": 736,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Row",
    "hierarchy_lvl2": "Grid Row",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Quasar grid for rows.",
    "anchor": "Introduction",
    "url": "/layout/grid/row"
  },
  {
    "objectID": 737,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Row",
    "hierarchy_lvl2": "Grid Row",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Utilize breakpoint-specific column classes for equal-width columns. Add any number of unit-less classes for each breakpoint you need and every column will be the same width.",
    "anchor": "Introduction",
    "url": "/layout/grid/row"
  },
  {
    "objectID": 738,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Row",
    "hierarchy_lvl2": "Equal-width",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For example, here are two grid layouts that apply to every device and viewport, from xs to xl.",
    "anchor": "Equal-width",
    "url": "/layout/grid/row"
  },
  {
    "objectID": 739,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Row",
    "hierarchy_lvl2": "Setting one column width",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The grid includes five tiers of predefined classes for building complex responsive layouts. Customize the size of your columns on extra small, small, medium, large, or extra large devices however you see fit.",
    "anchor": "Setting-one-column-width",
    "url": "/layout/grid/row"
  },
  {
    "objectID": 740,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Column",
    "hierarchy_lvl2": "Grid Column",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Quasar grid for columns.",
    "anchor": "Introduction",
    "url": "/layout/grid/column"
  },
  {
    "objectID": 741,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Column",
    "hierarchy_lvl2": "Grid Column",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Utilize breakpoint-specific row classes for equal-height rows. Add any number of unit-less classes for each breakpoint you need and every row will be the same height.",
    "anchor": "Introduction",
    "url": "/layout/grid/column"
  },
  {
    "objectID": 742,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Column",
    "hierarchy_lvl2": "Equal-height",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For example, here are two grid layouts that apply to every device and viewport, from xs to xl.",
    "anchor": "Equal-height",
    "url": "/layout/grid/column"
  },
  {
    "objectID": 743,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Column",
    "hierarchy_lvl2": "Setting one row height",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The grid includes five tiers of predefined classes for building complex responsive layouts. Customize the size of your rows on extra small, small, medium, large, or extra large devices however you see fit.",
    "anchor": "Setting-one-row-height",
    "url": "/layout/grid/column"
  },
  {
    "objectID": 744,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Gutter",
    "hierarchy_lvl2": "Grid Gutter",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the Quasar grid for gutter spaces.",
    "anchor": "Introduction",
    "url": "/layout/grid/gutter"
  },
  {
    "objectID": 745,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Gutter",
    "hierarchy_lvl2": "Grid Gutter",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Gutter Quasar CSS classes offer an easy way to space out elements (especially in a Grid Row) one from each other at equal distance.",
    "anchor": "Introduction",
    "url": "/layout/grid/gutter"
  },
  {
    "objectID": 746,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Gutter",
    "hierarchy_lvl2": "Types",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Suffixes (-none, -xs, -sm, -md, -lg, -xl) do not refer to device screen size, but to the size of gutter between elements.",
    "anchor": "Types",
    "url": "/layout/grid/gutter"
  },
  {
    "objectID": 747,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Gutter",
    "hierarchy_lvl2": "Classes \"q-gutter-{size}\"",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The q-gutter-* classes apply a negative top and left margins to the parent and a positive top and left margins to the children. Take this into account when working with the other Spacing classes so as to not to break the gutter's css.  These classes are to be used when the direct children don't have col-* or offset-* classes specifying a width. There's also the q-gutter-none class (equivalent to: no gutter applied) which wasn't included in the example above.",
    "anchor": "Classes-%22q-gutter-%7Bsize%7D%22",
    "url": "/layout/grid/gutter"
  },
  {
    "objectID": 748,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Gutter",
    "hierarchy_lvl2": "Classes \"q-col-gutter-{size}\"",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The q-col-gutter-* classes apply a negative top and left margins to the parent and a positive top and left paddings to the children. Take this into account when working with the other Spacing classes so as to not to break the gutter's css.  These classes are to be used when the direct children have col-* or offset-* classes that specify a width.",
    "anchor": "Classes-%22q-col-gutter-%7Bsize%7D%22",
    "url": "/layout/grid/gutter"
  },
  {
    "objectID": 749,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Grid Gutter",
    "hierarchy_lvl2": "Pros, cons and how to workaround problems - \"q-gutter-{size}\" vs. \"q-col-gutter-{size}\"",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Both set of classes have pros and cons.  Because both q-gutter-* and q-col-gutter-* classes apply a negative top and left margins to the parent you should not apply styling targeting background, margin or border related properties on the parent. Instead you need to wrap them in a container, apply the styling on the container, and add overflow-auto or row class on the container   The q-gutter-* classes do not change the internal dimensions of the children, so you can use background or border directly on children.   The q-gutter-* classes do change the external dimensions of the children, so you cannot use col-* or offset-* classes specifying a width on children anymore.   Because q-col-gutter-* classes apply a negative top and left padding to the children you should not apply styling targeting background, padding or border related properties on the children. Instead you need to put the styled element inside the child and apply the styling on that element.",
    "anchor": "Pros%2C-cons-and-how-to-workaround-problems---%22q-gutter-%7Bsize%7D%22-vs.-%22q-col-gutter-%7Bsize%7D%22",
    "url": "/layout/grid/gutter"
  },
  {
    "objectID": 750,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Flexbox patterns",
    "hierarchy_lvl2": "Flexbox Patterns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Common recipes for working with flexbox CSS is and how it can be used in a Quasar App.",
    "anchor": "Introduction",
    "url": "/layout/grid/flexbox-patterns"
  },
  {
    "objectID": 751,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Flexbox patterns",
    "hierarchy_lvl2": "Flexbox Patterns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When using column type flex you must define a height for the container. The height must be large enough to hold the longest column.",
    "anchor": "Introduction",
    "url": "/layout/grid/flexbox-patterns"
  },
  {
    "objectID": 752,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Flexbox patterns",
    "hierarchy_lvl2": "Masonry-like layout",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You must know how many columns you want use for the layout. Also for best visual aspect the elements in the layout should be close in height one to the others.  The general CSS formula for $x number of columns is: Example, supossing you want a 4 column layout: For the HTML there are some requirements that should be followed: - the flex column container must have a height defined - the column breaking elements must be placed at the start - the column breaking elements must be as many as the columns - the first column breaking element must be hidden (class hidden or style display: none) Example, supossing you want a 4 column layout:",
    "anchor": "Masonry-like-layout",
    "url": "/layout/grid/flexbox-patterns"
  },
  {
    "objectID": 753,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Flexbox patterns",
    "hierarchy_lvl2": "Masonry with pseudo selectors to break rows / columns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Masonry-with-pseudo-selectors-to-break-rows-%2F-columns",
    "url": "/layout/grid/flexbox-patterns"
  },
  {
    "objectID": 754,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Flex Playground",
    "hierarchy_lvl2": "Flex Grid Playground",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Interactively play with Quasar Flex Grid",
    "anchor": "Introduction",
    "url": "/layout/grid/flex-playground"
  },
  {
    "objectID": 755,
    "hierarchy_lvl0": "Flex Grid",
    "hierarchy_lvl1": "Flex Playground",
    "hierarchy_lvl2": "Flex Grid Playground",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The active child will have a blue index. Being active relates to the Child Classes and Child Styles listed below the results.",
    "anchor": "Introduction",
    "url": "/layout/grid/flex-playground"
  },
  {
    "objectID": 756,
    "hierarchy_lvl0": "Layout",
    "hierarchy_lvl1": "Layout",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QLayout component. Manages the whole window of your Quasar app.",
    "anchor": "Introduction",
    "url": "/layout/layout"
  },
  {
    "objectID": 757,
    "hierarchy_lvl0": "Layout",
    "hierarchy_lvl1": "Layout",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Layout Builder might use components not already inserted into quasar.conf.js. You are likely going to need the following components - QLayout, QHeader, QToolbar, QToolbarTitle, QBtn, QAvatar, QTabs, QRouteTab, QDrawer, QPageContainer, QFooter.   Keep an eye on your developer console for handy helpers on which components are being used but not declared in your quasar.conf.js file.",
    "anchor": "Introduction",
    "url": "/layout/layout"
  },
  {
    "objectID": 758,
    "hierarchy_lvl0": "Layout",
    "hierarchy_lvl1": "Layout",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using margin CSS will break the layout QLayout depends on taking up the whole screen and so QPageContainer, QHeader, QFooter and QLayoutDrawer positions are managed by it (through the view prop). You cannot use CSS margins as a style neither on QLayout itself nor on any of the QLayout components mentioned above. However you can safely use CSS padding.   If your layout uses Vue Router sub-routes (recommended), then it makes sense to use Vue's <router-view /> component, which is just a placeholder where sub-routes are injected. For more information, please read Routing with Layouts and Pages.",
    "anchor": "Usage",
    "url": "/layout/layout"
  },
  {
    "objectID": 759,
    "hierarchy_lvl0": "Layout",
    "hierarchy_lvl1": "Layout",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Understanding the \"view\" prop",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To explain how this works, imagine your Layout is a 3x3 matrix of containers (depicted in blue below). The first row of containers would be the header and the last row would be the footer. The first column of containers would be the \"left\" and last column would be the \"right\". The center of the matrix, below the header and above the footer, would be the page or main content container. This matrix of containers or \"QLayout View\" can be represented by a string that you should supply to the view property of QLayout. This string must contain exactly 11 characters: 3 defining the header row then a space 3 defining the middle row a space then 3 defining the footer row The letters shown above are also case sensitive. For example, using at least one \"L\" (uppercase character instead of lowercase) will make your layout left side (drawer) be in a fixed position. Same applies for \"H\" (header), \"F\" (footer) and finally \"R\" (right side / drawer). For example, if you want your layout's right side / drawer to be placed on the right of the header, page and footer, you'd use hhr lpr ffr. If you'd like to also make it fixed, just transform one r character to uppercase, like this: hhr lpR ffr, or hhR lpr ffr or hhr lpr ffR. These settings are completely up to you to use as you'd like. You could even go wild with a setup like this: lhh LpR ffr. Try it out!  * It is important that you specify all sections of a QLayout, even if you don't use them. For example, even if you don't use footer or right side drawer, still specify them within your QLayout's view prop. * When QDrawer is set into overlay mode, it will force it to go into fixed position, regardless if QLayout's \"view\" prop is configured with \"l/r\" or \"L/R\". Also, if on iOS platform and QLayout is containerized, the fixed position will also be forced upon QDrawer due to platform limitations that cannot be overcome.",
    "anchor": "Understanding-the-%22view%22-prop",
    "url": "/layout/layout"
  },
  {
    "objectID": 760,
    "hierarchy_lvl0": "Layout",
    "hierarchy_lvl1": "Layout",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Containerized QLayout",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that it requires a CSS height (or min-height) being set explicitly, otherwise it can't and it won't work.  In the example below, there is a containerized QLayout with drawers on each side (breakpoint of 700px on the left-side drawer and 500px on the right-side drawer). The breakpoint does not refer to the window width, but to the actual width of the QLayout container.",
    "anchor": "Containerized-QLayout",
    "url": "/layout/layout"
  },
  {
    "objectID": 761,
    "hierarchy_lvl0": "Routing with Layouts and Pages",
    "hierarchy_lvl1": "Routing with Layouts and Pages",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to connect the Vue Router with your Quasar layouts and pages.",
    "anchor": "Introduction",
    "url": "/layout/routing-with-layouts-and-pages"
  },
  {
    "objectID": 762,
    "hierarchy_lvl0": "Routing with Layouts and Pages",
    "hierarchy_lvl1": "Routing with Layouts and Pages",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To make it more clear, let's take an example. We have one layout ('user') and two pages ('user-feed' and 'user-profile'). We want to configure the website/app routes like this: /user/feed and /user/profile.",
    "anchor": "Introduction",
    "url": "/layout/routing-with-layouts-and-pages"
  },
  {
    "objectID": 763,
    "hierarchy_lvl0": "Routing with Layouts and Pages",
    "hierarchy_lvl1": "Routing with Layouts and Pages",
    "hierarchy_lvl2": "Creating Files",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar does not enforce a specific folder structure. The following is just an example. You can put layouts and pages together in a folder, or put pages in your specific folder structure of choice, or create your own layout and page folders. It doesn't matter for Quasar. All that matters is that you reference them correctly in /src/router/routes.js. Let's create the layout and page files. You can use a helper command of Quasar CLI or simply create them yourself. The commands above create the following folder structure: bash src/ ├── layouts │ └── User.vue # our QLayout definition └── pages ├── Posts.vue # page for /user/feed route └── Profile.vue # page for /user/profile route",
    "anchor": "Creating-Files",
    "url": "/layout/routing-with-layouts-and-pages"
  },
  {
    "objectID": 764,
    "hierarchy_lvl0": "Routing with Layouts and Pages",
    "hierarchy_lvl1": "Routing with Layouts and Pages",
    "hierarchy_lvl2": "Defining Routes",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example of routes.js: ```js // we define our routes in this file import LandingPage from 'pages/Landing' const routes = [ { path: '/', component: LandingPage } ] export default routes ``` Example of routes.js using lazy-loading / on-demand loading:  More in-depth analysis of Lazy loading / code-splitting.   Configuring routes to use Layouts and Pages basically consists of correctly nesting routes, as we'll see in the next section.",
    "anchor": "Defining-Routes",
    "url": "/layout/routing-with-layouts-and-pages"
  },
  {
    "objectID": 765,
    "hierarchy_lvl0": "Routing with Layouts and Pages",
    "hierarchy_lvl1": "Routing with Layouts and Pages",
    "hierarchy_lvl2": "Nested Routes",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "With Vue Router, it is very simple to express this relationship using nested route configurations. We notice some things: both pages need to be wrapped by a User component. Hey, User component is then a Layout! Since User layout wraps inner pages, they need an injection point. This is supplied by the <router-view> component: Our example has some routes specified (/user/profile and /user/posts). So how can we put everything together now? We edit the routes file. That's where we will configure routes, tell which components are Layouts and which are Pages and also reference/import them into our app:  Note that nested paths that start with / will be treated as a root path. This allows you to leverage component nesting without having to use a nested URL.  Our routes configuration (/src/router/routes.js) should look like this: Please notice a few things: * We are using lazy loading of layouts and pages (() => import(<path>)). If your website/app is small, then you can skip the lazy loading benefits as they could add more overhead than what it's worth: ```js import UserLayout from 'layouts/user' import UserFeed from 'pages/user-feed' import UserProfile from 'pages/user-profile' export default [ path: '/user', component: UserLayout, children: [ { path: 'feed', component: UserFeed }, { path: 'profile', component: UserProfile } ] ] `` * Quasar provides some out of the box Webpack aliases ('layouts' which points to '/src/layouts' and 'pages' which points to '/src/pages'), which are used in the above examples. * Pages of a Layout are declared as children of it in the Vue Router configuration so that <router-view/>` will know what page component to inject. Remember to always use this Vue component whenever your Layout has pages attached to it.  Please check Vue Router documentation to fully understand the examples above and how to configure the router and its routes for your app.",
    "anchor": "Nested-Routes",
    "url": "/layout/routing-with-layouts-and-pages"
  },
  {
    "objectID": 766,
    "hierarchy_lvl0": "Layout Header and Footer",
    "hierarchy_lvl1": "Layout Header and Footer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QHeader and QFooter components. The top and bottom bars of your Quasar app.",
    "anchor": "Introduction",
    "url": "/layout/header-and-footer"
  },
  {
    "objectID": 767,
    "hierarchy_lvl0": "Layout Header and Footer",
    "hierarchy_lvl1": "Layout Header and Footer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use glossy class on toolbars in header and footer.",
    "anchor": "Introduction",
    "url": "/layout/header-and-footer"
  },
  {
    "objectID": 768,
    "hierarchy_lvl0": "Layout Header and Footer",
    "hierarchy_lvl1": "Layout Header and Footer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Various content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, scroll the page to see the QHeader and QFooter behavior.",
    "anchor": "Various-content",
    "url": "/layout/header-and-footer"
  },
  {
    "objectID": 769,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QDrawer component. The sidebars of your Quasar app.",
    "anchor": "Introduction",
    "url": "/layout/drawer"
  },
  {
    "objectID": 770,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QDrawer is the sidebar part of your QLayout.",
    "anchor": "Introduction",
    "url": "/layout/drawer"
  },
  {
    "objectID": 771,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, QDrawer has touch actions attached to it. If this interferes with your drawer content components, disable it by specifying the Boolean no-swipe-close property.   When QDrawer is set into overlay mode, it will force it to go into fixed position, regardless if QLayout's \"view\" prop is configured with \"l/r\" or \"L/R\". Also, if on iOS platform and QLayout is containerized, the fixed position will also be forced upon QDrawer due to platform limitations that cannot be overcome.",
    "anchor": "Layout-Builder",
    "url": "/layout/drawer"
  },
  {
    "objectID": 772,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Consider using QItems with routing props (like to) below. For demoing purposes these props have not been added as it would break the UMD version.",
    "anchor": "Basic",
    "url": "/layout/drawer"
  },
  {
    "objectID": 773,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": "Mini-mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Drawer can operate in two modes: 'normal' and 'mini', and you can switch between them by using the Boolean mini property on QLayoutDrawer.  Please note that mini mode does not apply when in mobile behavior.  There are some CSS classes that will help you customize the drawer when dealing with \"mini\" mode. These are very useful especially when using the \"click\" trigger: You can also write your own CSS classes based on the fact that QLayoutDrawer has q-drawer--standard CSS class when in \"normal\" mode and q-drawer--mini when in \"mini\" mode. Also, when drawer is in \"mobile\" behavior, it gets q-drawer--mobile CSS class.",
    "anchor": "Mini-mode",
    "url": "/layout/drawer"
  },
  {
    "objectID": 774,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": "Mini-mode",
    "hierarchy_lvl4": "Mouseover/mouseout trigger",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Consider using QItems with routing props (like to) below. For demoing purposes these props have not been added as it would break the UMD version.",
    "anchor": "Mouseover%2Fmouseout-trigger",
    "url": "/layout/drawer"
  },
  {
    "objectID": 775,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": "Mini-mode",
    "hierarchy_lvl4": "Mini to overlay",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The mini-to-overlay Boolean property will always set your drawer with fixed position, regardless of your configuration from the view prop, but will occupy space on the layout only as wide as when in mini-mode.",
    "anchor": "Mini-to-overlay",
    "url": "/layout/drawer"
  },
  {
    "objectID": 776,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": "Mini-mode",
    "hierarchy_lvl4": "Click trigger",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Consider using QItems with routing props (like to) below. For demoing purposes these props have not been added as it would break the UMD version.",
    "anchor": "Click-trigger",
    "url": "/layout/drawer"
  },
  {
    "objectID": 777,
    "hierarchy_lvl0": "Layout Drawer",
    "hierarchy_lvl1": "Layout Drawer",
    "hierarchy_lvl2": "Layout Builder",
    "hierarchy_lvl3": "Mini-mode",
    "hierarchy_lvl4": "Slots",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On the example below, click the menu icon to see the drawer in action. It's best viewed on a desktop with a window of at least 500px width (this is the breakpoint that is set on this demo).",
    "anchor": "Slots",
    "url": "/layout/drawer"
  },
  {
    "objectID": 778,
    "hierarchy_lvl0": "Layout Page",
    "hierarchy_lvl1": "Layout Page",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use QPageContainer and QPage components. They define the contents of your Quasar app pages.",
    "anchor": "Introduction",
    "url": "/layout/page"
  },
  {
    "objectID": 779,
    "hierarchy_lvl0": "Layout Page",
    "hierarchy_lvl1": "Layout Page",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A QPage must be encapsulated by QPageContainer, which in turn must be a child of QLayout. Usually, the QPageContainer is part of the Layout template (where it contains a <router-view /> child only), and its content goes into separate vue files under /src/pages. If you haven't already, please read Routing with Layouts and Pages.",
    "anchor": "Introduction",
    "url": "/layout/page"
  },
  {
    "objectID": 780,
    "hierarchy_lvl0": "Layout Page",
    "hierarchy_lvl1": "Layout Page",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Example",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you wish to tweak, or even remove this property, you can do so by using the style-fn property:",
    "anchor": "Example",
    "url": "/layout/page"
  },
  {
    "objectID": 781,
    "hierarchy_lvl0": "Layout Gallery",
    "hierarchy_lvl1": "Layout Gallery",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Gallery of a few layouts for your Quasar apps.",
    "anchor": "Introduction",
    "url": "/layout/gallery"
  },
  {
    "objectID": 782,
    "hierarchy_lvl0": "Page Sticky",
    "hierarchy_lvl1": "Layout QPageSticky",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QPageSticky component. Statically place components on the layout without overlapping with header/footer/sidebars.",
    "anchor": "Introduction",
    "url": "/layout/page-sticky"
  },
  {
    "objectID": 783,
    "hierarchy_lvl0": "Page Sticky",
    "hierarchy_lvl1": "Layout QPageSticky",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The great advantage of this is that the elements wrapped by this component will never overlap the layout header, footer or drawer(s), even if those are not configured to be fixed. In the latter case, the position will be offset so that the overlap won't occur. Try it out with a non-fixed footer for example. When user reaches bottom of screen and footer comes into view, the component will shift up so it won't overlap with the footer.",
    "anchor": "Introduction",
    "url": "/layout/page-sticky"
  },
  {
    "objectID": 784,
    "hierarchy_lvl0": "Page Sticky",
    "hierarchy_lvl1": "Layout QPageSticky",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "* In order for QPageSticky to work, it must be placed within a QLayout component. * QPageSticky must be the last child element within its parent, so it can display on top of other content",
    "anchor": "Usage",
    "url": "/layout/page-sticky"
  },
  {
    "objectID": 785,
    "hierarchy_lvl0": "Page Sticky",
    "hierarchy_lvl1": "Layout QPageSticky",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By using expanded QPageSticky you can, for example, have a page-specific QToolbar as below.",
    "anchor": "Basic",
    "url": "/layout/page-sticky"
  },
  {
    "objectID": 786,
    "hierarchy_lvl0": "Page Scroller",
    "hierarchy_lvl1": "Layout QPageScroller",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QPageScroller component. Places components that will appear on screen after user scrolls the page.",
    "anchor": "Introduction",
    "url": "/layout/page-scroller"
  },
  {
    "objectID": 787,
    "hierarchy_lvl0": "Page Scroller",
    "hierarchy_lvl1": "Layout QPageScroller",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The great advantage of this is that the elements wrapped by this component will never overlap the layout header, footer or drawer(s), even if those are not configured to be fixed. In the latter case, the position will be offset so that the overlap won't occur. Try it out with a non-fixed footer for example. When user reaches bottom of screen and footer comes into view, the component will shift up so it won't overlap with the footer. Essentially QPageScroller is very similar to QPageSticky. Whereas a QPageSticky component is always visible, a QPageScroller component only appears after a scroll-offset (property) is reached. Once visible, the user can click on it to quickly get back to the top of the page via duration property.",
    "anchor": "Introduction",
    "url": "/layout/page-scroller"
  },
  {
    "objectID": 788,
    "hierarchy_lvl0": "Page Scroller",
    "hierarchy_lvl1": "Layout QPageScroller",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "* In order for QPageScroller to work, it must be placed within a QLayout component. * QPageScroller must be the last child element within its parent, so it can display on top of other content",
    "anchor": "Usage",
    "url": "/layout/page-scroller"
  },
  {
    "objectID": 789,
    "hierarchy_lvl0": "Ajax Bar",
    "hierarchy_lvl1": "Ajax Bar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QAjaxBar Vue component displays a loading bar whenever an Ajax call is in progress.",
    "anchor": "Introduction",
    "url": "/vue-components/ajax-bar"
  },
  {
    "objectID": 790,
    "hierarchy_lvl0": "Ajax Bar",
    "hierarchy_lvl1": "Ajax Bar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QAjaxBar is a component which displays a loading bar (like Youtube) whenever an Ajax call (regardless of Ajax library used) is in progress. It can be manually triggered as well.  If you'd like a simpler and more convenient way to offer an Ajax Bar to your users, have a look at the Loading Bar Plugin, which is actually the recommended way.",
    "anchor": "Introduction",
    "url": "/vue-components/ajax-bar"
  },
  {
    "objectID": 791,
    "hierarchy_lvl0": "Ajax Bar",
    "hierarchy_lvl1": "Ajax Bar",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below triggers events manually for demonstrating purposes only. This one is set to appear at bottom (multiple positions available!) of the page, with a 10px size (default is different) and uses a custom color. Please check out the API section for all properties that you can use.",
    "anchor": "Usage",
    "url": "/vue-components/ajax-bar"
  },
  {
    "objectID": 792,
    "hierarchy_lvl0": "Ajax Bar",
    "hierarchy_lvl1": "Ajax Bar",
    "hierarchy_lvl2": "Tips",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Each Ajax call makes a start() call when it is triggered. When it ends, it calls stop(). So yes, if you also manually trigger QAjaxBar you must call start() each time a new event is starting and stop() each time an event finished. QAjaxBar knows to handle multiple events simultaneously.",
    "anchor": "Tips",
    "url": "/vue-components/ajax-bar"
  },
  {
    "objectID": 793,
    "hierarchy_lvl0": "Avatar",
    "hierarchy_lvl1": "Avatar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QAvatar Vue component creates an element that can embed a letter, an icon or an image within its shape.",
    "anchor": "Introduction",
    "url": "/vue-components/avatar"
  },
  {
    "objectID": 794,
    "hierarchy_lvl0": "Avatar",
    "hierarchy_lvl1": "Avatar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The size property will determine the height and the width of the Avatar. The font-size property will set the size of the font used within the Avatar, which will have an effect on the size of letters and icons.",
    "anchor": "Introduction",
    "url": "/vue-components/avatar"
  },
  {
    "objectID": 795,
    "hierarchy_lvl0": "Badge",
    "hierarchy_lvl1": "Badge",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBadge Vue component allows you to display information like contextual data that needs to stand out and get noticed.",
    "anchor": "Introduction",
    "url": "/vue-components/badge"
  },
  {
    "objectID": 796,
    "hierarchy_lvl0": "Banner",
    "hierarchy_lvl1": "Banner",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBanner Vue component displays a prominent message and related optional actions.",
    "anchor": "Introduction",
    "url": "/vue-components/banner"
  },
  {
    "objectID": 797,
    "hierarchy_lvl0": "Bar",
    "hierarchy_lvl1": "Bar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBar Vue component is used to create the top bar on different platforms.",
    "anchor": "Introduction",
    "url": "/vue-components/bar"
  },
  {
    "objectID": 798,
    "hierarchy_lvl0": "Bar",
    "hierarchy_lvl1": "Bar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QBar is especially useful for frame-less Electron apps where you integrate it in the QHeader.",
    "anchor": "Introduction",
    "url": "/vue-components/bar"
  },
  {
    "objectID": 799,
    "hierarchy_lvl0": "Bar",
    "hierarchy_lvl1": "Bar",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For responsiveness, use Visibility Quasar CSS Classes. For finer tuning you can go write your own CSS media breakpoints or even go with QResizeObserver.",
    "anchor": "Usage",
    "url": "/vue-components/bar"
  },
  {
    "objectID": 800,
    "hierarchy_lvl0": "Bar",
    "hierarchy_lvl1": "Bar",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Styling",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Read more on Frameless Electron Window page.",
    "anchor": "Styling",
    "url": "/vue-components/bar"
  },
  {
    "objectID": 801,
    "hierarchy_lvl0": "Breadcrumbs",
    "hierarchy_lvl1": "Breadcrumbs",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBreadcrumbs Vue component is a navigational aid for your UI. It allows users to keep track of their location within programs, documents, or websites.",
    "anchor": "Introduction",
    "url": "/vue-components/breadcrumbs"
  },
  {
    "objectID": 802,
    "hierarchy_lvl0": "Breadcrumbs",
    "hierarchy_lvl1": "Breadcrumbs",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below won't work with UMD version (so in Codepen/jsFiddle too) because it depends on Vue Router.",
    "anchor": "Introduction",
    "url": "/vue-components/breadcrumbs"
  },
  {
    "objectID": 803,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button",
    "hierarchy_lvl2": "Button",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBtn Vue component is a button with features like shaping, loading state, ripple and more.",
    "anchor": "Introduction",
    "url": "/vue-components/button"
  },
  {
    "objectID": 804,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button",
    "hierarchy_lvl2": "Button",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When not disabled or spinning, QBtn emits a @click event, as soon as it is clicked or tapped.",
    "anchor": "Introduction",
    "url": "/vue-components/button"
  },
  {
    "objectID": 805,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The default padding is \"xs md\". However, you can use padding prop to customize it:",
    "anchor": "Usage",
    "url": "/vue-components/button"
  },
  {
    "objectID": 806,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Progress related",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Some button actions involve contacting a server, so an asynchronous response. It’s best that you inform the user about a background process taking place until the asynchronous response is ready. QBtn offers this possibility through the loading prop. This property will display a QSpinner (by default) instead of the icon and/or label of the button. Custom loading content can also be used (not only text or spinners). Should you wish, you can also display a deterministic progress within the button by using the additional percentage property along with what you’ve already learned about buttons with progress:",
    "anchor": "Progress-related",
    "url": "/vue-components/button"
  },
  {
    "objectID": 807,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Custom ripple",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The two examples below won't work with UMD version (so in Codepen/jsFiddle too) because it relies on the existence of Vue Router. For more convoluted use-cases, you can also directly use the native Vue <router-link> component to wrap a QBtn. This also gives the opportunity to control the state according to app's current route:",
    "anchor": "Custom-ripple",
    "url": "/vue-components/button"
  },
  {
    "objectID": 808,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Other options",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When placing a QBtn with type \"submit\" in one of the \"before\", \"after\", \"prepend\", or \"append\" slots of a QField, QInput or QSelect, you should also add a @click listener on the QBtn in question. This listener should call the method that submits your form. All \"click\" events in such slots are not propagated to their parent elements.",
    "anchor": "Other-options",
    "url": "/vue-components/button"
  },
  {
    "objectID": 809,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Group",
    "hierarchy_lvl2": "Button Group",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBtnGroup Vue component groups QBtn and QBtnDropdown into a single unit.",
    "anchor": "Introduction",
    "url": "/vue-components/button-group"
  },
  {
    "objectID": 810,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Group",
    "hierarchy_lvl2": "Button Group",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You must use same design props (flat, outline, push, ...) on both the parent QBtnGroup and the children QBtn/QBtnDropdown.",
    "anchor": "Introduction",
    "url": "/vue-components/button-group"
  },
  {
    "objectID": 811,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Dropdown",
    "hierarchy_lvl2": "Dropdown Button",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBtnDropdown Vue component is used to display dropdown content on a button.",
    "anchor": "Introduction",
    "url": "/vue-components/button-dropdown"
  },
  {
    "objectID": 812,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Dropdown",
    "hierarchy_lvl2": "Dropdown Button",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following example won't work with UMD version (so in Codepen/jsFiddle too) because it relies on the existence of Vue Router.",
    "anchor": "Introduction",
    "url": "/vue-components/button-dropdown"
  },
  {
    "objectID": 813,
    "hierarchy_lvl0": "Card",
    "hierarchy_lvl1": "Card",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QCard Vue component is a great way to display important pieces of grouped content. It assists the viewer by containing and organizing information, while also setting up predictable expectations.",
    "anchor": "Introduction",
    "url": "/vue-components/card"
  },
  {
    "objectID": 814,
    "hierarchy_lvl0": "Card",
    "hierarchy_lvl1": "Card",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "With so much content to display at once, and often so little screen real-estate, Cards have fast become the design pattern of choice for many companies, including the likes of Google and Twitter. The QCard component is intentionally lightweight and essentially a containing element that is capable of \"hosting\" any other component that is appropriate.",
    "anchor": "Introduction",
    "url": "/vue-components/card"
  },
  {
    "objectID": 815,
    "hierarchy_lvl0": "Card",
    "hierarchy_lvl1": "Card",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can play with the typography within your cards to create beautiful cards.",
    "anchor": "Usage",
    "url": "/vue-components/card"
  },
  {
    "objectID": 816,
    "hierarchy_lvl0": "Card",
    "hierarchy_lvl1": "Card",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below are some of the custom alignments that you can use for the actions through the align property:",
    "anchor": "Basic",
    "url": "/vue-components/card"
  },
  {
    "objectID": 817,
    "hierarchy_lvl0": "Card",
    "hierarchy_lvl1": "Card",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Media content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On the examples below, notice the QCardSection with horizontal prop on it that wraps other QCardSections. Also note that you can directly use col-* classes on children of horizontal QCardSection in order to control the size. It's recommended that you use QImg component instead of native <img> when dealing with horizontal QCardSections.",
    "anchor": "Media-content",
    "url": "/vue-components/card"
  },
  {
    "objectID": 818,
    "hierarchy_lvl0": "Card",
    "hierarchy_lvl1": "Card",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Various content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On the example below, click on the round button on the bottom right to see the expansion in action.",
    "anchor": "Various-content",
    "url": "/vue-components/card"
  },
  {
    "objectID": 819,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QCarousel Vue component allows you to display a series of slides, useful for wizards or an image gallery.",
    "anchor": "Introduction",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 820,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If the QCarouselSlide content also has images and you want to use swipe actions to navigate, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.   Please take notice of the Boolean keep-alive prop for QCarousel, if you need this behavior. Do NOT use Vue's native <keep-alive> component over QCarouselSlide.",
    "anchor": "Introduction",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 821,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is an almost stripped down basic Carousel (it is just animated and only has custom transitions specified) with no navigation embedded. For this reason, we are controlling the current slide through the model.",
    "anchor": "Basic",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 822,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Transitions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below: * There are just a few transitions demoed. For a complete list of transitions, head to the Transitions page. * You can also swipe with your finger (or swiping with the mouse -- clicking and quickly dragging to left/right then releasing).",
    "anchor": "Transitions",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 823,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Vertical",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The notion of \"control\" here refers to the arrows and navigation buttons. Since they are buttons, you can also pick their type to better match your design. You also benefit from the control-color and control-text-color props.",
    "anchor": "Vertical",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 824,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Navigation position",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For a full list of properties of the navigation-icon slot, please consult the API card.",
    "anchor": "Navigation-position",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 825,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Auto padding",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is an example with which you can play with different QCarousel settings so you can see the padding (or lack of) in action:",
    "anchor": "Auto-padding",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 826,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Media content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below there are thumbnails being generated automatically. Thumbnails only applies to image slides.  Don't use the property navigation along with thumbnails as the first supercedes the latter so the thumbnails will not be displayed.",
    "anchor": "Media-content",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 827,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Infinite and autoplay",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can pause autoplay when the pointer is over the carousel or over a region of interest.",
    "anchor": "Infinite-and-autoplay",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 828,
    "hierarchy_lvl0": "Carousel",
    "hierarchy_lvl1": "Carousel",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Controls",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note how QScrollArea is used in the two examples below. Also note the q-carousel--padding CSS helper class in the second example.",
    "anchor": "Controls",
    "url": "/vue-components/carousel"
  },
  {
    "objectID": 829,
    "hierarchy_lvl0": "Chat Message",
    "hierarchy_lvl1": "Chat Message",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QChatMessage Vue component displays a chat entry containing one or more user messages.",
    "anchor": "Introduction",
    "url": "/vue-components/chat"
  },
  {
    "objectID": 830,
    "hierarchy_lvl0": "Chat Message",
    "hierarchy_lvl1": "Chat Message",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To mix messages with avatar and without avatar in the same thread, use a placeholder avatar image.",
    "anchor": "Introduction",
    "url": "/vue-components/chat"
  },
  {
    "objectID": 831,
    "hierarchy_lvl0": "Chat Message",
    "hierarchy_lvl1": "Chat Message",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using the property sent is intended for the sender of the chat message. The other side is for received messages.",
    "anchor": "Usage",
    "url": "/vue-components/chat"
  },
  {
    "objectID": 832,
    "hierarchy_lvl0": "Chat Message",
    "hierarchy_lvl1": "Chat Message",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Customization",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Always sanitize values if you do not trust the origin (if the value comes from user input).",
    "anchor": "Customization",
    "url": "/vue-components/chat"
  },
  {
    "objectID": 833,
    "hierarchy_lvl0": "Chip",
    "hierarchy_lvl1": "Chip",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QChip Vue component is a simple UI block entity, representing for example more advanced underlying data, such as a contact, but in a compact way.",
    "anchor": "Introduction",
    "url": "/vue-components/chip"
  },
  {
    "objectID": 834,
    "hierarchy_lvl0": "Chip",
    "hierarchy_lvl1": "Chip",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Chips can contain entities such as an avatar, text or an icon, optionally having a pointer too. They can also be closed or removed if configured so.  Also check out QBadge.",
    "anchor": "Introduction",
    "url": "/vue-components/chip"
  },
  {
    "objectID": 835,
    "hierarchy_lvl0": "Circular Progress",
    "hierarchy_lvl1": "Circular Progress",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QCircularProgress Vue component displays a colored circular loading indicator. The bar can either have a determinate progress, or an indeterminate animation.",
    "anchor": "Introduction",
    "url": "/vue-components/circular-progress"
  },
  {
    "objectID": 836,
    "hierarchy_lvl0": "Circular Progress",
    "hierarchy_lvl1": "Circular Progress",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, show-value property also enables the default slot, so you can fill it with custom content, like even a QAvatar or a QTooltip. The font-size prop refers to the inner label font size.",
    "anchor": "Introduction",
    "url": "/vue-components/circular-progress"
  },
  {
    "objectID": 837,
    "hierarchy_lvl0": "Color Picker",
    "hierarchy_lvl1": "Color Picker",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QColorPicker Vue component provides a way for the user to input colors.",
    "anchor": "Introduction",
    "url": "/vue-components/color-picker"
  },
  {
    "objectID": 838,
    "hierarchy_lvl0": "Color Picker",
    "hierarchy_lvl1": "Color Picker",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For handling colors, also check out Quasar Color Utils.",
    "anchor": "Introduction",
    "url": "/vue-components/color-picker"
  },
  {
    "objectID": 839,
    "hierarchy_lvl0": "Color Picker",
    "hierarchy_lvl1": "Color Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are helpers for QInput rules prop: full list. You can use these for convenience or write the string specifying your custom needs. Examples: \"hexColor\", \"rgbOrRgbaColor\", \"anyColor\". More info: QInput.",
    "anchor": "Usage",
    "url": "/vue-components/color-picker"
  },
  {
    "objectID": 840,
    "hierarchy_lvl0": "Color Picker",
    "hierarchy_lvl1": "Color Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "No header or footer",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can choose if you don't want to render the header and/or footer, like in example below:",
    "anchor": "No-header-or-footer",
    "url": "/vue-components/color-picker"
  },
  {
    "objectID": 841,
    "hierarchy_lvl0": "Color Picker",
    "hierarchy_lvl1": "Color Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Custom default view",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also pick the default view, like in example below, where we also specify we don't want to render the header and footer. The end result generates a nice color palette that the user can pick from:",
    "anchor": "Custom-default-view",
    "url": "/vue-components/color-picker"
  },
  {
    "objectID": 842,
    "hierarchy_lvl0": "Color Picker",
    "hierarchy_lvl1": "Color Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Custom palette",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QColor, otherwise formData will not contain it (if it should):",
    "anchor": "Custom-palette",
    "url": "/vue-components/color-picker"
  },
  {
    "objectID": 843,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QDialog component provides a UI for modals with functionalities like positioning, styling, maximizing and more.",
    "anchor": "Introduction",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 844,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "From a UI perspective, you can think of Dialogs as a type of floating modal, which covers only a portion of the screen. This means Dialogs should only be used for quick user actions, like verifying a password, getting a short App notification or selecting an option or options quickly.  Dialogs can also be used as a globally available method for more basic use cases, like the native JS alert(), prompt(), etc. For the latter behaviour, go to Dialog Plugin page.   Masterclass TIP Rather than cluttering your .vue templates with QDialogs, it's best if you write a component for your dialog and use the Dialog Plugin to invoke it from anywhere in your app.",
    "anchor": "Introduction",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 845,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note It's best that your QDialog main content is a QCard. However, if you are planning on using any other component (like QForm) or tag, make sure that the direct child of QDialog is rendered with a <div> tag (or wrap it with one yourself).",
    "anchor": "Usage",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 846,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not mistake \"position\" prop with the show/hide animation. If you want a custom animation, you should use transition-show and transition-hide which can be applied regardless of \"position\" or \"maximized\".",
    "anchor": "Basic",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 847,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Various content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are going to use the containerized QLayout, you'll need to put a width on your QDialog, if using left/right position, or a height, if using top/bottom position. You can use vw and vh units.",
    "anchor": "Various-content",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 848,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling scroll",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Dialogs can also be a part of the page, without requiring immediate focus. It's where \"seamless\" mode comes into play:",
    "anchor": "Handling-scroll",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 849,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Dialog in dialog",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, should you wish to disable this behavior, edit your /quasar.conf.js file:",
    "anchor": "Dialog-in-dialog",
    "url": "/vue-components/dialog"
  },
  {
    "objectID": 850,
    "hierarchy_lvl0": "Editor - WYSIWYG",
    "hierarchy_lvl1": "Editor (WYSIWYG)",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QEditor Vue component is a WYSIWYG editor that enables writing and pasting HTML.",
    "anchor": "Introduction",
    "url": "/vue-components/editor"
  },
  {
    "objectID": 851,
    "hierarchy_lvl0": "Editor - WYSIWYG",
    "hierarchy_lvl1": "Editor (WYSIWYG)",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Making content editable Design Mode execCommand() reference contentEditable spec",
    "anchor": "Introduction",
    "url": "/vue-components/editor"
  },
  {
    "objectID": 852,
    "hierarchy_lvl0": "Editor - WYSIWYG",
    "hierarchy_lvl1": "Editor (WYSIWYG)",
    "hierarchy_lvl2": "Examples",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In this first example, there are two cards below the editor. The first shows the unparsed html using the double-moustache, whereas the second shows the rendered version using v-html=\"editor\". Using v-html this way renders your users vulnerable to Cross Site Scripting attacks. If the content is user generated, be sure to sanitize it either on render or server side (or both).  By default, QEditor offers most if not all the commands you’d need in a WYSIWYG editor: bold, italic, strike, underline, unordered (list), ordered (list), subscript, superscript, link, fullscreen, quote, left (align), center (align), right (align), justify (align), print, outdent, indent, removeFormat, hr, undo, redo, h1 to h6, p (paragraph), code (code paragraph), size-1 to size-7. Each of these commands is pre-configured with icons and their own internationalized tooltips. However, if you want to override some of their settings you can do so with the help of definitions Object property. The following is an example that adds custom definitions. In such cases, make sure you don’t overlap the default commands:",
    "anchor": "Examples",
    "url": "/vue-components/editor"
  },
  {
    "objectID": 853,
    "hierarchy_lvl0": "Editor - WYSIWYG",
    "hierarchy_lvl1": "Editor (WYSIWYG)",
    "hierarchy_lvl2": "Dropdowns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Dropdowns",
    "url": "/vue-components/editor"
  },
  {
    "objectID": 854,
    "hierarchy_lvl0": "Editor - WYSIWYG",
    "hierarchy_lvl1": "Editor (WYSIWYG)",
    "hierarchy_lvl2": "Caveats",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Caveats",
    "url": "/vue-components/editor"
  },
  {
    "objectID": 855,
    "hierarchy_lvl0": "Editor - WYSIWYG",
    "hierarchy_lvl1": "Editor (WYSIWYG)",
    "hierarchy_lvl2": "Caveats",
    "hierarchy_lvl3": "Images",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Images",
    "url": "/vue-components/editor"
  },
  {
    "objectID": 856,
    "hierarchy_lvl0": "Expansion Item",
    "hierarchy_lvl1": "Expansion Item",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QExpansionItem Vue component allows visibility toggling like an accordion.",
    "anchor": "Introduction",
    "url": "/vue-components/expansion-item"
  },
  {
    "objectID": 857,
    "hierarchy_lvl0": "Expansion Item",
    "hierarchy_lvl1": "Expansion Item",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "They are basically QItem components wrapped with additional functionality. So they can be included in QLists and inherit QItem component properties.",
    "anchor": "Introduction",
    "url": "/vue-components/expansion-item"
  },
  {
    "objectID": 858,
    "hierarchy_lvl0": "Expansion Item",
    "hierarchy_lvl1": "Expansion Item",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with inset levels, a general rule of thumb is that header-inset-level adds left padding to header while it doesn't do anything with the content, while content-inset-level adds left padding to the content.",
    "anchor": "Usage",
    "url": "/vue-components/expansion-item"
  },
  {
    "objectID": 859,
    "hierarchy_lvl0": "Expansion Item",
    "hierarchy_lvl1": "Expansion Item",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Behavior",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The behavior below of toggling by expand icon only is especially useful when having a route attached to the header of QExpansionItem. This way by clicking header it will activate the route and by clicking the expand icon it will, well, expand the content. You can't have both actions attached to the whole header, obviously.",
    "anchor": "Behavior",
    "url": "/vue-components/expansion-item"
  },
  {
    "objectID": 860,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QFab component. Floating Action Buttons for your Quasar app.",
    "anchor": "Introduction",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 861,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note that you don’t need a QLayout to use FABs.",
    "anchor": "Introduction",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 862,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "tip For an exhausting list of options, please read the API cards (at the bottom of this page).",
    "anchor": "Usage",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 863,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Non-Expandable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When the labels are internal and your QFab opens up vertically (up or down) then you also have the ability to choose how to vertically align the sub-actions:",
    "anchor": "Non-Expandable",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 864,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "External labels",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, when the label is external on the main QFab (not the sub-actions), it gets shown only when QFab is opened. However, you can override that by setting a Boolean value for hide-label prop.",
    "anchor": "External-labels",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 865,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Hide icons",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If we hide the icon (through specific prop), we should at least use an internal label:",
    "anchor": "Hide-icons",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 866,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Padding",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The default padding for QFab is \"md\" and for QFabAction is \"sm\". However, you can use padding prop to customize it (accepts CSS units too):",
    "anchor": "Padding",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 867,
    "hierarchy_lvl0": "Floating Action Button",
    "hierarchy_lvl1": "Floating Action Button",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Square style",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is a nice example of using TouchPan for making the QFab draggable across the screen.",
    "anchor": "Square-style",
    "url": "/vue-components/floating-action-button"
  },
  {
    "objectID": 868,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QInput Vue component is used to capture text input from the user.",
    "anchor": "Introduction",
    "url": "/vue-components/input"
  },
  {
    "objectID": 869,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For your QInput you can use only one of the main designs (filled, outlined, standout, borderless). You cannot use multiple as they are self-exclusive.",
    "anchor": "Introduction",
    "url": "/vue-components/input"
  },
  {
    "objectID": 870,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Coloring",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "One of the most appropriate use cases for Standout design is in a QToolbar:",
    "anchor": "Coloring",
    "url": "/vue-components/input"
  },
  {
    "objectID": 871,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Borderless",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The rounded prop only works along with Filled, Outlined and Standout designs, as showcased in the example below:",
    "anchor": "Borderless",
    "url": "/vue-components/input"
  },
  {
    "objectID": 872,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Square borders",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The square prop only makes sense along with Filled, Outlined and Standout designs, as showcased in the example below:",
    "anchor": "Square-borders",
    "url": "/vue-components/input"
  },
  {
    "objectID": 873,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Dark background",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All the attributes set on QInput that are not in the list of props in the API will be passed to the native field (input or textarea). Some examples: autocomplete, placeholder. Please check these resources for more information about native attributes (for input check also the specific attributes for each type): input textarea",
    "anchor": "Dark-background",
    "url": "/vue-components/input"
  },
  {
    "objectID": 874,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Clearable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "As a helper, you can use clearable prop so user can reset model to null through an appended icon. The second QInput in the example below is the equivalent of using clearable.",
    "anchor": "Clearable",
    "url": "/vue-components/input"
  },
  {
    "objectID": 875,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Input types",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following QInputs make use of the type prop in order to render native equivalent <input type=\"...\"> inside of them.  Support and behavior is the subject entirely of the browser rendering the page and not Quasar's core code.   Some input types (like date or time) always render some controls, so you if you're using a label then you might want to set it along with stack-label, otherwise the label will overlap native browser controls.",
    "anchor": "Input-types",
    "url": "/vue-components/input"
  },
  {
    "objectID": 876,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Input types",
    "hierarchy_lvl4": "Input of number type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You'll be using v-model.number (notice the number modifier) along with type=\"number\" prop:",
    "anchor": "Input-of-number-type",
    "url": "/vue-components/input"
  },
  {
    "objectID": 877,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Input types",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "ALTERNATIVES Instead of using a QInput with type=\"file\", you might want to use QFile picker instead or even QUploader. However, should you wish to use QInput, please read the warning below.   Do NOT use a v-model when QInput is of type=\"file\". Browser security policy does not allow a value to be set to such an input. As a result, you can only read it (attach an @update:modelValue event), but not write it.",
    "anchor": "Input-of-file-type",
    "url": "/vue-components/input"
  },
  {
    "objectID": 878,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Textarea",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you need QInput to grow along with its content, then use the autogrow prop like in the example below:",
    "anchor": "Textarea",
    "url": "/vue-components/input"
  },
  {
    "objectID": 879,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Prefix and suffix",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using the label slot you can customize the aspect of the label or add special features as QTooltip.  Do not forget to set the label-slot property. If you want to interact with the content of the label (QTooltip) add the all-pointer-events class on the element in the slot.",
    "anchor": "Prefix-and-suffix",
    "url": "/vue-components/input"
  },
  {
    "objectID": 880,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Shadow text",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When placing a QBtn with type \"submit\" in one of the \"before\", \"after\", \"prepend\", or \"append\" slots of a QField, QInput or QSelect, you should also add a @click listener on the QBtn in question. This listener should call the method that submits your form. All \"click\" events in such slots are not propagated to their parent elements.",
    "anchor": "Shadow-text",
    "url": "/vue-components/input"
  },
  {
    "objectID": 881,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Debouncing model",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The role of debouncing is for times when you watch the model and do expensive operations on it. So you want to first let user type out before triggering the model update, rather than updating the model on each keystroke.",
    "anchor": "Debouncing-model",
    "url": "/vue-components/input"
  },
  {
    "objectID": 882,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Loading state",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can force/help the user to input a specific format with help from mask prop.  Mask is only available if the type is one of 'text' (default), 'search', 'url', 'tel', or 'password'.  Below are mask tokens: There are helpers for QInput mask prop: full list. You can use these for convenience (examples: \"phone\", \"card\") or write the string specifying your custom needs. The unmasked-value is useful if for example you want to force the user type a certain format, but you want the model to contain the raw value: The reverse-fill-mask is useful if you want to force the user to fill the mask from the end and allow non-fixed length of input:",
    "anchor": "Loading-state",
    "url": "/vue-components/input"
  },
  {
    "objectID": 883,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Input",
    "hierarchy_lvl3": "Using third party mask processors",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can easily use any third party mask processor by doing a few small adjustments to your QInput. Starting from a QInput like this: You can use v-money directive: Or you can use money component:",
    "anchor": "Using-third-party-mask-processors",
    "url": "/vue-components/input"
  },
  {
    "objectID": 884,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Validation",
    "hierarchy_lvl3": "Using third party mask processors",
    "hierarchy_lvl4": "Input of file type",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can validate QInput components with :rules prop. Specify array of embedded rules or your own validators. Your custom validator will be a function which returns true if validator succeeds or String with error message if it doesn't succeed.  By default, for perf reasons, a change in the rules does not trigger a new validation until the model changes. In order to trigger the validation when rules change too, then use reactive-rules Boolean prop. The downside is a performance penalty (so use it when you really need this only!) and it can be slightly mitigated by using a computed prop as value for the rules (and not specify them inline in the vue template).  This is so you can write convenient rules of shape like: You can reset the validation by calling resetValidation() method on the QInput. There are helpers for QInput rules prop: full list. You can use these for convenience (examples: \"date\", \"time\", \"hexColor\", \"rgbOrRgbaColor\", \"anyColor\") or write the string specifying your custom needs. If you set lazy-rules, validation starts after first blur. If lazy-rules is set to ondemand String, then validation will be triggered only when component's validate() method is manually called or when the wrapper QForm submits itself.",
    "anchor": "Validation",
    "url": "/vue-components/input"
  },
  {
    "objectID": 885,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Validation",
    "hierarchy_lvl3": "Using third party mask processors",
    "hierarchy_lvl4": "Async rules",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Consider coupling async rules with debounce prop to avoid calling the async rules immediately on each keystroke, which might be detrimental to performance.",
    "anchor": "Async-rules",
    "url": "/vue-components/input"
  },
  {
    "objectID": 886,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Validation",
    "hierarchy_lvl3": "External validation",
    "hierarchy_lvl4": "Async rules",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use external validation and only pass error and error-message (enable bottom-slots to display this error message).  Depending on your needs, you might connect Vuelidate (our recommended approach) or some other validation library to QInput.  You can also customize the slot for error message:",
    "anchor": "External-validation",
    "url": "/vue-components/input"
  },
  {
    "objectID": 887,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Input Textfield",
    "hierarchy_lvl2": "Native form submit",
    "hierarchy_lvl3": "External validation",
    "hierarchy_lvl4": "Async rules",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QInput, otherwise formData will not contain it (if it should):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/input"
  },
  {
    "objectID": 888,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Select",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSelect Vue component has two types of selection - single or multiple. This component opens up a menu for the selection list and action. A filter can also be used for longer lists.",
    "anchor": "Introduction",
    "url": "/vue-components/select"
  },
  {
    "objectID": 889,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Select",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In case you are looking for a dropdown \"button\" instead of \"input\" use Button Dropdown instead.",
    "anchor": "Introduction",
    "url": "/vue-components/select"
  },
  {
    "objectID": 890,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For your QSelect you can use only one of the main designs (filled, outlined, standout, borderless). You cannot use multiple as they are self-exclusive.",
    "anchor": "Design",
    "url": "/vue-components/select"
  },
  {
    "objectID": 891,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Decorators",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When placing a QBtn with type \"submit\" in one of the \"before\", \"after\", \"prepend\", or \"append\" slots of a QField, QInput or QSelect, you should also add a @click listener on the QBtn in question. This listener should call the method that submits your form. All \"click\" events in such slots are not propagated to their parent elements.",
    "anchor": "Decorators",
    "url": "/vue-components/select"
  },
  {
    "objectID": 892,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Menu transitions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that transitions do not work when using options-cover prop.  In the example below there's a few transitions showcased. For a full list of transitions available, go to Transitions.",
    "anchor": "Menu-transitions",
    "url": "/vue-components/select"
  },
  {
    "objectID": 893,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Options list display mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that on iOS menu behavior might generate problems, especially when used in combination with use-input prop. You can use a conditional behavior prop like :behavior=\"$q.platform.is.ios === true ? 'dialog' : 'menu'\" to use dialog mode only on iOS.",
    "anchor": "Options-list-display-mode",
    "url": "/vue-components/select"
  },
  {
    "objectID": 894,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "The model",
    "hierarchy_lvl3": "Options list display mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The model for single selection can be anything (String, Object, ...) while the model for multiple selection must be an Array.  The model content can be influenced by emit-value prop as you'll learn in \"The options\" section below.",
    "anchor": "The-model",
    "url": "/vue-components/select"
  },
  {
    "objectID": 895,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "The options",
    "hierarchy_lvl3": "Options list display mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When emit-value is used, the model becomes the determined value from the specified selected option. Default is to emit the whole option. It makes sense to use it only when the options are of Object form. When map-options is used, the model can contain only the value, and it will be mapped against the options to determine its label. There is a performance penalty involved, so use it only if absolutely necessary. It's not needed, for example, if the model contains the whole Object (so contains the label prop).",
    "anchor": "The-options",
    "url": "/vue-components/select"
  },
  {
    "objectID": 896,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "The options",
    "hierarchy_lvl3": "Custom prop names",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, QSelect looks at label, value, disable and sanitize props of each option from the options array Objects. But you can override those:  If you use functions for custom props always check if the option is null. These functions are used both for options in the list and for the selected options.",
    "anchor": "Custom-prop-names",
    "url": "/vue-components/select"
  },
  {
    "objectID": 897,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "The options",
    "hierarchy_lvl3": "Customizing menu options",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The list of options is rendered using virtual scroll, so if you render more than one element for an option you must set a q-virtual-scroll--with-prev class on all elements except the first one.  Here is another example where we add a QToggle to each option. The possibilities are endless. By default, when there are no options, the menu won't appear. But you can customize this scenario and specify what the menu should display.",
    "anchor": "Customizing-menu-options",
    "url": "/vue-components/select"
  },
  {
    "objectID": 898,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "The options",
    "hierarchy_lvl3": "Lazy loading",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following example shows a glimpse of how you can play with lazy loading the options. This means, along with many other things, that options prop is not required on first render. You can dynamically load new options when scroll reaches the end:",
    "anchor": "Lazy-loading",
    "url": "/vue-components/select"
  },
  {
    "objectID": 899,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "The options",
    "hierarchy_lvl3": "Cover mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All the attributes set on QSelect that are not in the list of props in the API will be passed to the native input field used (please check use-input prop description first to understand what it does) for filtering / autocomplete / adding new value. Some examples: autocomplete, placeholder. More information: native input attributes.",
    "anchor": "Cover-mode",
    "url": "/vue-components/select"
  },
  {
    "objectID": 900,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Create new values",
    "hierarchy_lvl3": "Cover mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following are just a few examples to get you started into making your own QSelect behavior. This is not exhaustive list of possibilities that QSelect offers. It makes sense to use this feature along with use-input prop.  In order to enable the creation of new values, you need to either specify the new-value-mode prop and/or listen for @new-value event. If you use both, then the purpose of listening to @new-value would be only to override the new-value-mode in your custom scenarios.",
    "anchor": "Create-new-values",
    "url": "/vue-components/select"
  },
  {
    "objectID": 901,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Create new values",
    "hierarchy_lvl3": "The new-value-mode prop",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By using this prop you don't need to also listen for @new-value event, unless you have some specific scenarios for which you want to override the behavior.",
    "anchor": "The-new-value-mode-prop",
    "url": "/vue-components/select"
  },
  {
    "objectID": 902,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Create new values",
    "hierarchy_lvl3": "The @new-value event",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Calling done() with no parameters simply empties the input box value, without tampering with the model in any way.",
    "anchor": "The-%40new-value-event",
    "url": "/vue-components/select"
  },
  {
    "objectID": 903,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Create new values",
    "hierarchy_lvl3": "Using menu and filtering",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Filters new values (in the example below the value to be added requires at least 3 characters to pass), and does not add to menu: Generating multiple values from input:",
    "anchor": "Using-menu-and-filtering",
    "url": "/vue-components/select"
  },
  {
    "objectID": 904,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Sanitization",
    "hierarchy_lvl3": "Using menu and filtering",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, all options (included selected ones) are sanitized. This means that displaying them in HTML format is disabled. However, if you require HTML on your options and you trust their content, then there are a few ways to do this. You can force the HTML form of the menu options by: - setting html key of the trusted option to true (for specific trusted options) - or by setting options-html prop of QSelect (for all options) The displayed value of QSelect is displayed as HTML if: - the display-value-html prop of QSelect is set - or you are not using display-value and - the options-html prop of QSelect is set - any selected option has html key set to true  If you use selected or selected-item slots, then you are responsible for sanitization of the display value. The display-value-html prop will not apply.",
    "anchor": "Sanitization",
    "url": "/vue-components/select"
  },
  {
    "objectID": 905,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Render performance",
    "hierarchy_lvl3": "Using menu and filtering",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The render performance is NOT affected much by the number of options, unless map-options is used on a large set. Notice the infinite scroll in place which renders additional options as the user scrolls through the list.  * (Composition API) To get the best performance while using lots of options, do not wrap the array that you are passing in the options prop with ref()/computed()/reactive()/etc. This allows Vue to skip making the list \"responsive\" to changes. * (Options API) To get the best performance while using lots of options, freeze the array that you are passing in the options prop using Object.freeze(items). This allows Vue to skip making the list \"responsive\" to changes.",
    "anchor": "Render-performance",
    "url": "/vue-components/select"
  },
  {
    "objectID": 906,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Keyboard navigation",
    "hierarchy_lvl3": "Using menu and filtering",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When QSelect is focused: - pressing <kbd>ENTER</kbd>, <kbd>ARROW DOWN</kbd> (or <kbd>SPACE</kbd> if use-input is not set) will open the list of options - if use-chips is set: - pressing <kbd>SHIFT</kbd> + <kbd>TAB</kbd> will navigate backwards through the QChips (if a QChip is selected <kbd>TAB</kbd> will navigate forward through the QChips) - pressing <kbd>ENTER</kbd> when a QChip is selected will remove that option from the selection - pressing <kbd>BACKSPACE</kbd> will remove the last option from the selection (when use-input is set the input should be empty) - pressing <kbd>TAB</kbd> (or <kbd>SHIFT</kbd> + <kbd>TAB</kbd> if use-chips is not set or the first QChip is selected) will navigate to the next or previous focusable element on page - typing text (<kbd>0</kbd> - <kbd>9</kbd> or <kbd>A</kbd> - <kbd>Z</kbd>) if use-input is not set will: - create a search buffer (will be reset when a new key is not typed for 1.5 seconds) that will be used to search in the options labels - select the next option starting with that letter (after the current focused one) if the first key in buffer is typed multiple times - select the next option (starting with the current focused one) that matches the typed text (the match is fuzzy - the option label should start with the first letter and contain all the letters) When the list of options is opened: - pressing <kbd>ARROW UP</kbd> or <kbd>ARROW DOWN</kbd> will navigate up or down in the list of options - pressing <kbd>PAGE UP</kbd> or <kbd>PAGE DOWN</kbd> will navigate one page up or down in the list of options - pressing <kbd>HOME</kbd> or <kbd>END</kbd> will navigate to the start or end of the list of options (only if you are not using use-input, or the input is empty) - when navigating using arrow keys, navigation will wrap when reaching the start or end of the list - pressing <kbd>ENTER</kbd> (or <kbd>SPACE</kbd> when use-input is not set, or <kbd>TAB</kbd> when multiple is not set) when an option is selected in the list will: - select the option and close the list of options if multiple is not set - toggle the option if multiple is set",
    "anchor": "Keyboard-navigation",
    "url": "/vue-components/select"
  },
  {
    "objectID": 907,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Select",
    "hierarchy_lvl2": "Native form submit",
    "hierarchy_lvl3": "Using menu and filtering",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QSelect, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/select"
  },
  {
    "objectID": 908,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "File Picker",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QFile Vue component is used as a file picker.",
    "anchor": "Introduction",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 909,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "File Picker",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "tip If you also want a component to also handle the upload for you, please consider using QUploader instead.",
    "anchor": "Introduction",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 910,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For your QFile you can use only one of the main designs (filled, outlined, standout, borderless). You cannot use multiple as they are self-exclusive.",
    "anchor": "Design",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 911,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Decorators",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Under the covers, QFile uses a native input. Due to browser security policy, it is not allowed to programmatically fill such an input with a value. As a result, even if you set v-model from the beginning to a value, the component will show those file(s) but the input tag itself won't be filled in with that value. A user interaction (click/tap/<kbd>ENTER</kbd> key) is absolutely required in order for the native input to contain them. It's best to always have the initial value of model set to null or undefined/void 0.",
    "anchor": "Decorators",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 912,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, QFile replaces the model each time the user selects any files through the popup. However, when you are accepting multiple files (multiple prop) you can change this behavior and append the new selection to the model rather than replacing its old value. Below you can pick files multiple times and QFile will keep on appending them to the model:",
    "anchor": "Basic",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 913,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Counters",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below highlights how you can customize the display of each file and even incorporate a possible upload progress indicator:",
    "anchor": "Counters",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 914,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Restricting files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can even combine the restrictions above.  In the example above, we're using accept property. Its value must be a comma separated list of unique file type specifiers. Maps to 'accept' attribute of native input type=file element. More info.   Recommended format for the accept property is <mediatype>/<extension>. Examples: \"image/png\", \"image/png\". QFile uses an <input type=\"file\"> under the covers and it relies entirely on the host browser to trigger the file picker. If the accept property (that gets applied to the input) is not correct, no file picker will appear on screen or it will appear but it will accept all file types.  You can also apply custom filters (which are executed after user picks files):",
    "anchor": "Restricting-files",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 915,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "File picker",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Native form submit",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QFile, otherwise formData will not contain it (if it should):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/file-picker"
  },
  {
    "objectID": 916,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Form",
    "hierarchy_lvl2": "Form",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QForm Vue component renders a form and allows easy validation of child form components like QInput, QSelect or QField.",
    "anchor": "Introduction",
    "url": "/vue-components/form"
  },
  {
    "objectID": 917,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Form",
    "hierarchy_lvl2": "Form",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please be aware of the following: * QForm hooks into QInput, QSelect or QField wrapped components * QInput, QSelect or QField wrapped components must use the internal validation (NOT the external one). * If you want to take advantage of the reset functionality, then be sure to also capture the @reset event on QForm and make its handler reset all of the wrapped components models.  In order for the user to be able to activate the @submit or @reset events on the form, create a QBtn with type set to submit or reset: Alternatively, you can give the QForm a Vue ref name and call the validate and resetValidation functions directly:",
    "anchor": "Introduction",
    "url": "/vue-components/form"
  },
  {
    "objectID": 918,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Form",
    "hierarchy_lvl2": "Turning off Autocompletion",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Turning-off-Autocompletion",
    "url": "/vue-components/form"
  },
  {
    "objectID": 919,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Form",
    "hierarchy_lvl2": "Submitting to a URL (native form submit)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Control the way the form is submitted by setting action, method, enctype and target attributes of QForm If a listener on @submit IS NOT present on the QForm then the form will be submitted if the validation is successful If a listener on @submit IS present on the QForm then the listener will be called if the validation is successful. In order to do a native submit in this case:",
    "anchor": "Submitting-to-a-URL-(native-form-submit)",
    "url": "/vue-components/form"
  },
  {
    "objectID": 920,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Form",
    "hierarchy_lvl2": "Child communication",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, all the Quasar form components communicate with the parent QForm instance. If, for some reason, you are creating your own form component (that doesn't wraps a Quasar form component), then you can make QForm aware of it by using:",
    "anchor": "Child-communication",
    "url": "/vue-components/form"
  },
  {
    "objectID": 921,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Field",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QField Vue component is used to provide common functionality and aspect to form components.",
    "anchor": "Introduction",
    "url": "/vue-components/field"
  },
  {
    "objectID": 922,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Field",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QField allows you to display any form control (or almost anything as a matter of fact) inside it. Just place your desired content inside the control slot.  Do NOT wrap QInput, QFile or QSelect with QField as these components already inherit QField.",
    "anchor": "Introduction",
    "url": "/vue-components/field"
  },
  {
    "objectID": 923,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The examples below use dumb content (text) just to show you the design that QField can use. For checking out examples that wrap real components, see the \"Basic Features\" section.   QField does not (and should not) manage your control slot, so if you use label prop, it might be a good idea to also specify stack-label, otherwise it might overlap your control when QField is not focused.",
    "anchor": "Design",
    "url": "/vue-components/field"
  },
  {
    "objectID": 924,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Overview",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For your QField you can use only one of the main designs (filled, outlined, standout, borderless). You cannot use multiple as they are self-exclusive.",
    "anchor": "Overview",
    "url": "/vue-components/field"
  },
  {
    "objectID": 925,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Coloring",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "One of the most appropriate use cases for Standout design is in a QToolbar:",
    "anchor": "Coloring",
    "url": "/vue-components/field"
  },
  {
    "objectID": 926,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Borderless",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The rounded prop only works along with Filled, Outlined and Standout designs, as showcased in the example below:",
    "anchor": "Borderless",
    "url": "/vue-components/field"
  },
  {
    "objectID": 927,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Square borders",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The square prop only makes sense along with Filled, Outlined and Standout designs, as showcased in the example below:",
    "anchor": "Square-borders",
    "url": "/vue-components/field"
  },
  {
    "objectID": 928,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Dark background",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If using clearable you must use v-model or listen on @update:modelValue and update the value.",
    "anchor": "Dark-background",
    "url": "/vue-components/field"
  },
  {
    "objectID": 929,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Control types",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Anything you place inside the control slot will be used as content of the field. We provide a few examples of controls below.  Most of the form controls always render something visible, so you if you're using a label then you might want to set it along with stack-label, otherwise the label will overlap the enclosed control.",
    "anchor": "Control-types",
    "url": "/vue-components/field"
  },
  {
    "objectID": 930,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Prefix and suffix",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using the label slot you can customize the aspect of the label or add special features as QTooltip.  Do not forget to set the label-slot property. If you want to interact with the content of the label (QTooltip) add the all-pointer-events class on the element in the slot.",
    "anchor": "Prefix-and-suffix",
    "url": "/vue-components/field"
  },
  {
    "objectID": 931,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Slots with QBtn type \"submit\"",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When placing a QBtn with type \"submit\" in one of the \"before\", \"after\", \"prepend\", or \"append\" slots of a QField, QInput or QSelect, you should also add a @click listener on the QBtn in question. This listener should call the method that submits your form. All \"click\" events in such slots are not propagated to their parent elements.",
    "anchor": "Slots-with-QBtn-type-%22submit%22",
    "url": "/vue-components/field"
  },
  {
    "objectID": 932,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Loading state",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can validate QField components with :rules prop. Specify array of embedded rules or your own validators. Your custom validator will be a function which returns true if validator succeeds or String with error message if it doesn't succeed.  By default, for perf reasons, a change in the rules does not trigger a new validation until the model changes. In order to trigger the validation when rules change too, then use reactive-rules Boolean prop. The downside is a performance penalty (so use it when you really need this only!) and it can be slightly mitigated by using a computed prop as value for the rules (and not specify them inline in the vue template).  This is so you can write convenient rules of shape like: You can reset the validation by calling resetValidation() method on the QField. If you set lazy-rules, validation starts after first blur. If lazy-rules is set to ondemand String, then validation will be triggered only when component's validate() method is manually called or when the wrapper QForm submits itself.",
    "anchor": "Loading-state",
    "url": "/vue-components/field"
  },
  {
    "objectID": 933,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "Loading state",
    "hierarchy_lvl4": "Async rules",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Consider coupling async rules with debounce prop to avoid calling the async rules immediately on each keystroke, which might be detrimental to performance.",
    "anchor": "Async-rules",
    "url": "/vue-components/field"
  },
  {
    "objectID": 934,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Field (wrapper)",
    "hierarchy_lvl2": "Design",
    "hierarchy_lvl3": "External validation",
    "hierarchy_lvl4": "Async rules",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use external validation and only pass error and error-message (enable bottom-slots to display this error message).  Depending on your needs, you might connect Vuelidate (our recommended approach) or some other validation library to QField.  You can also customize the slot for error message:",
    "anchor": "External-validation",
    "url": "/vue-components/field"
  },
  {
    "objectID": 935,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Radio",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QRadio Vue component is a basic element for user input. It can be used to supply a way for the user to pick an option from multiple choices.",
    "anchor": "Introduction",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 936,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Radio",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please also refer to the QOptionGroup on other possibilities for creating groups of Radios.",
    "anchor": "Introduction",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 937,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the second row in the example below, the property keep-color is being used to retain the passed in color when the radio button is not in a toggled state.",
    "anchor": "Usage",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 938,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Dark and disable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apart from the standard sizes below, you can define your own through the size property (last one is a custom size).",
    "anchor": "Dark-and-disable",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 939,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With QOptionGroup",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use QOptionGroup, which simplifies the usage when you have groups of radios, like in example below.",
    "anchor": "With-QOptionGroup",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 940,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With QItem",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, we are rendering a <label> tag (notice tag=\"label\") so the QRadio will respond to clicks on QItems to change toggle state.",
    "anchor": "With-QItem",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 941,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Radio",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Native form submit",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QRadio, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/radio"
  },
  {
    "objectID": 942,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Checkbox",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QCheckbox Vue component is a checkbox with features like coloring, ripple and indeterminate state.",
    "anchor": "Introduction",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 943,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Checkbox",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please also refer to the QOptionGroup on other possibilities for creating groups of Checkboxes.",
    "anchor": "Introduction",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 944,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the second row in the example below, the property keep-color is being used to retain the passed in color when the checkbox is not in a toggled state.",
    "anchor": "Usage",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 945,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Dense and dark",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apart from the standard sizes below, you can define your own through the size property (last one is a custom size).",
    "anchor": "Dense-and-dark",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 946,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Indeterminate state",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, as soon as you click on the first checkbox it starts toggling between true/false. The second checkbox, on the other hand toggles between the three states (indeterminate/true/false) with help from toggle-indeterminate. You can optionally set the property indeterminate-value, otherwise the indeterminate value will be considered null.",
    "anchor": "Indeterminate-state",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 947,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Toggle order",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, QCheckbox follows this chain when toggling: indeterminate -> checked -> unchecked. However, you can change this behavior through the toggle-order prop. This property determines the order of the states and can be tf (default) or ft (t stands for state of true/checked while f for state of false/unchecked). Toggling order is: * if toggle-indeterminate is true, then: indet -> first state -> second state -> indet (and repeat) * otherwise (no toggle-indeterminate): indet -> first state -> second state -> first state -> second state -> ...",
    "anchor": "Toggle-order",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 948,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Array model",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use QOptionGroup, which simplifies the usage when you have groups of checkboxes, like in example below.",
    "anchor": "Array-model",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 949,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With QItem",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, we are rendering a <label> tag (notice tag=\"label\") so the QCheckbox will respond to clicks on QItems to change toggle state.",
    "anchor": "With-QItem",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 950,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Checkbox",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Disable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QCheckbox, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):",
    "anchor": "Disable",
    "url": "/vue-components/checkbox"
  },
  {
    "objectID": 951,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QToggle component is a basic element for user input. You can use it for turning settings, features or true/false inputs on and off.",
    "anchor": "Introduction",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 952,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Use the color prop to control the toggle’s color.",
    "anchor": "Introduction",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 953,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "With labels",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Instead of the default true/false values, you can use custom ones.",
    "anchor": "With-labels",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 954,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "Indeterminate state",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, as soon as you click on the first QToggle it starts toggling between true/false. The second QToggle, on the other hand toggles between the three states (indeterminate/true/false) with help from toggle-indeterminate. You can optionally set the property indeterminate-value, otherwise the indeterminate value will be considered null.",
    "anchor": "Indeterminate-state",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 955,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "Toggle order",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, QToggle follows this chain when toggling: indeterminate -> checked -> unchecked. However, you can change this behavior through the toggle-order prop. This property determines the order of the states and can be tf (default) or ft (t stands for state of true/checked while f for state of false/unchecked). Toggling order is: * if toggle-indeterminate is true, then: indet -> first state -> second state -> indet (and repeat) * otherwise (no toggle-indeterminate): indet -> first state -> second state -> first state -> second state -> ...",
    "anchor": "Toggle-order",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 956,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "Array model",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you have a number of toggles for a selection, use can use an Array as the model for all of them and specify val prop on each toggle. If the toggle is ticked, its val will be inserted into the array and vice versa.",
    "anchor": "Array-model",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 957,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "Dark and disable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apart from the standard sizes below, you can define your own through the size property (last one is a custom size).",
    "anchor": "Dark-and-disable",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 958,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "With QOptionGroup",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use QOptionGroup, which simplifies the usage when you have groups of toggles, like in example below.",
    "anchor": "With-QOptionGroup",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 959,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Toggle",
    "hierarchy_lvl2": "Toggle",
    "hierarchy_lvl3": "With QItem",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QToggle, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):",
    "anchor": "With-QItem",
    "url": "/vue-components/toggle"
  },
  {
    "objectID": 960,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Toggle",
    "hierarchy_lvl2": "Button Toggle",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QBtnToggle Vue component is a basic element for user input, similar to QRadio but with buttons.",
    "anchor": "Introduction",
    "url": "/vue-components/button-toggle"
  },
  {
    "objectID": 961,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Toggle",
    "hierarchy_lvl2": "Button Toggle",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Since QBtnToggle uses QBtn, you can use design related props of QBtn to style this component.",
    "anchor": "Introduction",
    "url": "/vue-components/button-toggle"
  },
  {
    "objectID": 962,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Toggle",
    "hierarchy_lvl2": "Button Toggle",
    "hierarchy_lvl3": "Custom content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "First QBtnToggle below has tooltips on each button. Second QBtnToggle has customized the content. Notice the slot prop in the options Object definition. When you use this slot prop, you don't necessary need the label/icon props in options.",
    "anchor": "Custom-content",
    "url": "/vue-components/button-toggle"
  },
  {
    "objectID": 963,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Button Toggle",
    "hierarchy_lvl2": "Button Toggle",
    "hierarchy_lvl3": "Disable and readonly",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QBtnToggle, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):",
    "anchor": "Disable-and-readonly",
    "url": "/vue-components/button-toggle"
  },
  {
    "objectID": 964,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Option Group",
    "hierarchy_lvl2": "Option Group",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QOptionGroup Vue component allows you better control for grouping binary form input components like checkboxes, radios or toggles.",
    "anchor": "Introduction",
    "url": "/vue-components/option-group"
  },
  {
    "objectID": 965,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Option Group",
    "hierarchy_lvl2": "Option Group",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The model for checkboxes/toggles must be an array.",
    "anchor": "Introduction",
    "url": "/vue-components/option-group"
  },
  {
    "objectID": 966,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Option Group",
    "hierarchy_lvl2": "Option Group",
    "hierarchy_lvl3": "With labels on left side",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The objects within the options array can hold any of the props found in QToggle, QCheckbox or QRadio for instance disable or leftLabel. See below for an example.",
    "anchor": "With-labels-on-left-side",
    "url": "/vue-components/option-group"
  },
  {
    "objectID": 967,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Option Group",
    "hierarchy_lvl2": "Option Group",
    "hierarchy_lvl3": "Disable Certain Options",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QOptionGroup, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):",
    "anchor": "Disable-Certain-Options",
    "url": "/vue-components/option-group"
  },
  {
    "objectID": 968,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Slider",
    "hierarchy_lvl2": "Slider",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSlider Vue component is a great way for the user to specify a number value between a minimum and maximum value, with optional steps between valid values.",
    "anchor": "Introduction",
    "url": "/vue-components/slider"
  },
  {
    "objectID": 969,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Slider",
    "hierarchy_lvl2": "Slider",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The step property can also be floating point number (or numeric 0 if you need infinite precision).",
    "anchor": "Introduction",
    "url": "/vue-components/slider"
  },
  {
    "objectID": 970,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Slider",
    "hierarchy_lvl2": "Slider",
    "hierarchy_lvl3": "With label",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, move the slider to see the label. The example below is better highlighting how QSlider handles label positioning so that it always stays inside the QSlider's box horizontally.",
    "anchor": "With-label",
    "url": "/vue-components/slider"
  },
  {
    "objectID": 971,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Slider",
    "hierarchy_lvl2": "Slider",
    "hierarchy_lvl3": "Markers",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QSlider, otherwise formData will not contain it (if it should):",
    "anchor": "Markers",
    "url": "/vue-components/slider"
  },
  {
    "objectID": 972,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QRange Vue component offers a way for the user to select from a sub-range of values between a maximum and maximum value, with optional steps.",
    "anchor": "Introduction",
    "url": "/vue-components/range"
  },
  {
    "objectID": 973,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice we are using an object for the selection, which holds values for both the lower value of the selected range - rangeValues.min and the higher value - rangeValues.max.",
    "anchor": "Introduction",
    "url": "/vue-components/range"
  },
  {
    "objectID": 974,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": "Standard",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The step property can also be a floating point number (or numeric 0 if you need infinite precision).",
    "anchor": "Standard",
    "url": "/vue-components/range"
  },
  {
    "objectID": 975,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": "With label",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, move the slider to see the label. The example below is better highlighting how QRange handles label positioning so that it always stays inside the QRange's box horizontally.",
    "anchor": "With-label",
    "url": "/vue-components/range"
  },
  {
    "objectID": 976,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": "Markers",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Use the drag-range or drag-only-range props to allow the user to move the selected range or only a predetermined range as a whole.",
    "anchor": "Markers",
    "url": "/vue-components/range"
  },
  {
    "objectID": 977,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": "Lazy input",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using simple CSS you can get nice effects.",
    "anchor": "Lazy-input",
    "url": "/vue-components/range"
  },
  {
    "objectID": 978,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Range",
    "hierarchy_lvl2": "Range",
    "hierarchy_lvl3": "Native form submit",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QRange, otherwise formData will not contain it (if it should):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/range"
  },
  {
    "objectID": 979,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "QTime",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTime component provides a method to input time.",
    "anchor": "Introduction",
    "url": "/vue-components/time"
  },
  {
    "objectID": 980,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "QTime",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For handling date and/or time, also check out Quasar Date Utils.",
    "anchor": "Introduction",
    "url": "/vue-components/time"
  },
  {
    "objectID": 981,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that the model is a String only.",
    "anchor": "Usage",
    "url": "/vue-components/time"
  },
  {
    "objectID": 982,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For landscape mode, you can use it along with $q.screen to make QTime responsive. Example: :landscape=\"$q.screen.gt.xs\". More info: Quasar Screen Plugin.",
    "anchor": "Basic",
    "url": "/vue-components/time"
  },
  {
    "objectID": 983,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Functionality",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The 24 hour format is applied depending on the Quasar Language Pack that you've set, but you can also force it, like in the example below. Clicking on the \"Now\" button sets time to current user time:",
    "anchor": "Functionality",
    "url": "/vue-components/time"
  },
  {
    "objectID": 984,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Model mask",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The default model mask is HH:mm (or HH:mm:ss when using with-seconds prop), however you can use custom masks too. The mask prop tokens can be found at Quasar Utils > Date utils.  Note on SSR Using x or X (timestamps) in the mask may cause hydration errors on the client, because decoding the model String must be done with new Date() which takes into account the local timezone. As a result, if the server is in a different timezone than the client, then the rendered output of the server will differ than the one on the client so hydration will fail.   Note on persian calendar When using the persian calendar, the mask for QTime is forced to HH:mm or HH:mm:ss (if with-seconds is specified).  If you want to insert strings into your mask, make sure you escape them by surrounding them with [ and ], otherwise the characters might be interpreted as format tokens. Using the mask to connect a QDate and QTime to the same model:",
    "anchor": "Model-mask",
    "url": "/vue-components/time"
  },
  {
    "objectID": 985,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Custom ad-hoc locale",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If, for some reason, you need to use a custom ad-hoc locale rather than the current Quasar Language Pack that has been set, you can use the locale prop:",
    "anchor": "Custom-ad-hoc-locale",
    "url": "/vue-components/time"
  },
  {
    "objectID": 986,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Coloring",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Connecting a QDate and QTime with same model on a QInput: The following are helpers for QInput mask and rules props. You can use these for convenience or write the string specifying your custom needs. Property mask helpers: full list. Property rules helpers: full list. Examples: \"date\", \"time\", \"fulltime\". More info: QInput.",
    "anchor": "Coloring",
    "url": "/vue-components/time"
  },
  {
    "objectID": 987,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With additional buttons",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use the default slot for adding buttons:",
    "anchor": "With-additional-buttons",
    "url": "/vue-components/time"
  },
  {
    "objectID": 988,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Time Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Native form submit",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QTime, otherwise formData will not contain it (if it should):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/time"
  },
  {
    "objectID": 989,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "QDate",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QDate Vue component provides a method to input dates from Gregorian or Persian calendars.",
    "anchor": "Introduction",
    "url": "/vue-components/date"
  },
  {
    "objectID": 990,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "QDate",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For handling date and/or time, also check out Quasar Date Utils.",
    "anchor": "Introduction",
    "url": "/vue-components/date"
  },
  {
    "objectID": 991,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that the actual date(s) of the model are all in String format.",
    "anchor": "Usage",
    "url": "/vue-components/date"
  },
  {
    "objectID": 992,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For landscape mode, you can use it along with $q.screen to make QDate responsive. Example: :landscape=\"$q.screen.gt.xs\". More info: Quasar Screen Plugin.",
    "anchor": "Basic",
    "url": "/vue-components/date"
  },
  {
    "objectID": 993,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Multiple selection",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice below that the model is an Array and we specify the \"multiple\" prop. Clicking on an already selected day will deselect it.",
    "anchor": "Multiple-selection",
    "url": "/vue-components/date"
  },
  {
    "objectID": 994,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Range selection",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice in the examples below that the model is an Object (single selection) or an Array of Objects (multiple selection).  TIPS * Clicking on an already selected day will deselect it. * The user's current editing range can also be set programmatic through the setEditingRange method (check the API card). * There are two useful events in regards to the current editing range: range-start and range-end (check the API card).   The range property is only partially compatible with the options prop: selected ranges might also include \"unselectable\" days.",
    "anchor": "Range-selection",
    "url": "/vue-components/date"
  },
  {
    "objectID": 995,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Custom title and subtitle",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When not in 'minimal' mode, QDate has a computed header title and subtitle. You can override it, like in the example below. When clicking on title then the QDate's view is changed to the calendar and when clicking on subtitle, the view will switch to year picking.",
    "anchor": "Custom-title-and-subtitle",
    "url": "/vue-components/date"
  },
  {
    "objectID": 996,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Functionality",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When model is unfilled (like null, void 0/undefined) QDate still has to show the calendar for a month of a year. You can use default-year-month prop for this, otherwise the current month of the year will be shown: The default view can be changed. The first day of the week is applied depending on the Quasar Language Pack that you've set, but you can also force it, like in the example below. Clicking on the \"Today\" button sets date to current user date. Requires the header, so you can't use it along with \"minimal\" mode:",
    "anchor": "Functionality",
    "url": "/vue-components/date"
  },
  {
    "objectID": 997,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Model mask",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The default model mask is YYYY/MM/DD, however you can use custom ones too. The mask prop tokens can be found at Quasar Utils > Date utils.  Note on SSR Using x or X (timestamps) in the mask may cause hydration errors on the client, because decoding the model String must be done with new Date() which takes into account the local timezone. As a result, if the server is in a different timezone than the client, then the rendered output of the server will differ than the one on the client so hydration will fail.   Note on persian calendar When using the persian calendar, the mask for QDate is forced to YYYY/MM/DD.  If you want to insert strings into your mask, make sure you escape them by surrounding them with [ and ], otherwise the characters might be interpreted as format tokens. Using the mask to connect a QDate and QTime to the same model:  If you want to programmatically set the value of QDate, you can do so by just re-assigning the value that you pass. However, the updated value needs to be a string in the same format as your mask. Eg. in the case your mask is 'dddd, MMM D, YYYY', passing '2019/04/28' as value won't work, you would need to pass 'Sunday, Apr 28, 2019' instead.",
    "anchor": "Model-mask",
    "url": "/vue-components/date"
  },
  {
    "objectID": 998,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Custom ad-hoc locale",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If, for some reason, you need to use a custom ad-hoc locale rather than the current Quasar Language Pack that has been set, you can use the locale prop:",
    "anchor": "Custom-ad-hoc-locale",
    "url": "/vue-components/date"
  },
  {
    "objectID": 999,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Coloring",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The first example is using an array and the second example is using a function.",
    "anchor": "Coloring",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1000,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Limiting options",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use the options prop to limit user selection to certain times. Alternatively, for a more in-depth way of limiting options, you can also supply a function (second and third example below) to options-fn prop.  The options property is only partially compatible with the range prop. Ranges might contain \"unselectable\" days.",
    "anchor": "Limiting-options",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1001,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Applying navigation boundaries",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below the navigation is restricted between 2020/07 and 2020/09.",
    "anchor": "Applying-navigation-boundaries",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1002,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With additional buttons",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use the default slot for adding buttons:",
    "anchor": "With-additional-buttons",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1003,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With QSplitter and QTabPanels",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More info: QSplitter, QTabPanels.",
    "anchor": "With-QSplitter-and-QTabPanels",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1004,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With QInput",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Connecting a QDate and QTime with same model on a QInput: The following are helpers for QInput mask and rules props. You can use these for convenience or write the string specifying your custom needs. Property mask helpers: full list. Property rules helpers: full list. Examples: \"date\", \"time\", \"fulltime\". More info: QInput.",
    "anchor": "With-QInput",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1005,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Persian calendar",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When using the persian calendar, the mask for QDate is forced to YYYY/MM/DD.",
    "anchor": "Persian-calendar",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1006,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Date Picker",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Native form submit",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QDate, otherwise formData will not contain it (if it should):",
    "anchor": "Native-form-submit",
    "url": "/vue-components/date"
  },
  {
    "objectID": 1007,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QIcon Vue component allows you to insert icons within other components or any other area of your pages.",
    "anchor": "Introduction",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1008,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Furthermore you can add support by yourself for any icon lib. There are multiple types of icons in Quasar: webfont-based, svg-based and image-based. You are not bound to using only one type in your website/app.  Related pages: Installing Icon Libraries and Quasar Icon Sets.",
    "anchor": "Introduction",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1009,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Size & colors",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For icon properties on different Quasar components you won't have the means to specify an icon for each platform, but you can achieve the same effect with:",
    "anchor": "Size-%26-colors",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1010,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you are using webfont-based icons, make sure that you installed the icon library that you are using, otherwise it won't show up!",
    "anchor": "Webfont-icons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1011,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Webfont usage",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Webfont-usage",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1012,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are always in snake_case. Go to Material Icons, look for your desired icon. Remember its name (eg. \"all_inbox\") and use it.",
    "anchor": "Naming-convention",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1013,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "MDI (Material Design Icons)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in hyphen-separated case and always begin with \"mdi-\" prefix. Go to MDI, look for your desired icon, click on it. A dialog box will appear. Get the title (eg. \"account-key\"), prefix it with \"mdi-\" and you get the result (eg. \"mdi-account-key\").",
    "anchor": "MDI-(Material-Design-Icons)",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1014,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "Fontawesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in hyphen-serapated case and always begin with \"fas fa-\", \"fab fa-\", \"fal fa-\" or \"far fa-\" prefixes. Go to FontAwesome, look for your desired icon, click on it. You'll get to its page. Below the icon name (as title), you will see something like <i class=\"fas fa-air-freshener\"></i>. The result is fas fa-air-freshener.",
    "anchor": "Fontawesome",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1015,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "Ionicons",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in hyphen-separated case and always begin with \"ion-\", \"ion-md-\", \"ion-ios-\" or \"ion-logo-\" prefixes. Go to Ionicons, look for your desired icon, click on it. At the bottom of the page there will appear a popup. Notice something like <ion-icon name=\"square-outline\"></ion-icon>. Remember the name (eg. \"square-outline\"). Based on the variant that you want (auto-detect platform, material or iOS), you'd get the result: ion-square-outline or ion-md-square-outline or ion-ios-square-outline.",
    "anchor": "Ionicons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1016,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "Eva Icons",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in hyphen-separated case and always begin with \"eva-\" prefix. Go to Eva Icons, look for your desired icon, click on it. A dialog box will appear. Get the name from there (eg. \"attach-outline\"), prefix it with \"eva\" and the result is \"eva-attach-outline\".",
    "anchor": "Eva-Icons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1017,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "Themify",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in hyphen-separated case and always begin with \"ti-\" prefix. Go to Themify, look for your desired icon. Remember its name (eg. \"ti-arrow-top-right\") and use it.",
    "anchor": "Themify",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1018,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Webfont icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in hyphen-separated case and always begin with \"la\" prefix. Go to Line Awesome, look for your desired icon, click on it. A dialog box will appear. You'll see something like <i class=\"lab la-behance-square\"></i>. Remember its name (eg. \"lab la-behance-square\") and use it.",
    "anchor": "Line-Awesome",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1019,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Naming convention",
    "hierarchy_lvl4": "Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are many advantages of using only svg icons in your website/app: * Better app footprint -- only used icons will be included in the final build (treeshaking in action) * Better quality icons * No need for including equivalent webfonts from @quasar/extras or CDN. The current disadvantage is that it is more tedious to use these icons than their webfont counterpart.",
    "anchor": "Svg-icons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1020,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Svg usage",
    "hierarchy_lvl4": "Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice in the example below that we want to avoid the Vue observable wrapping, so we inject icons on the instance through created() hook. It will work if declared in data() too, but... overhead.  If you are only using svg icons (and have configured a Quasar Icon Set) then you don't need the webfont equivalent in your app at all.",
    "anchor": "Svg-usage",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1021,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Svg icons are supplied by @quasar/extras (although you can supply your own svg icons too!). Here's the ins and outs of the import syntax:",
    "anchor": "Import-guide",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1022,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Material Icons (Google)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"mat\" prefix. Go to Material Icons, look for your desired icon and remember its name (eg. \"all_inbox\"), prefix it with \"mat\" and camel-case the result (eg. \"matAllInbox\"). Import statement example: import { matAllInbox } from '@quasar/extras/material-icons'.",
    "anchor": "SVG-Material-Icons-(Google)",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1023,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Material Icons Outlined (Google)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"outlined\" prefix. Go to Material Icons, look for your desired icon and remember its name (eg. \"all_inbox\"), prefix it with \"outlined\" and camel-case the result (eg. \"outlinedAllInbox\"). Import statement example: import { outlinedAllInbox } from '@quasar/extras/material-icons-outlined'.",
    "anchor": "SVG-Material-Icons-Outlined-(Google)",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1024,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Material Icons Sharp (Google)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"sharp\" prefix. Go to Material Icons, look for your desired icon and remember its name (eg. \"all_inbox\"), prefix it with \"sharp\" and camel-case the result (eg. \"sharpAllInbox\"). Import statement example: import { sharpAllInbox } from '@quasar/extras/material-icons-sharp'.",
    "anchor": "SVG-Material-Icons-Sharp-(Google)",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1025,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Material Icons Round (Google)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"round\" prefix. Go to Material Icons, look for your desired icon and remember its name (eg. \"all_inbox\"), prefix it with \"round\" and camel-case the result (eg. \"roundAllInbox\"). Import statement example: import { roundAllInbox } from '@quasar/extras/material-icons-round'.",
    "anchor": "SVG-Material-Icons-Round-(Google)",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1026,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG MDI (Material Design Icons)",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"mdi\" prefix. Go to MDI, look for your desired icon, click on it. A dialog box will appear. Get the title (eg. \"account-key\"), prefix it with \"mdi\" and camel-case the result (eg. \"mdiAccountKey\"). Import statement example: import { mdiAccountKey } from '@quasar/extras/mdi-v5'.",
    "anchor": "SVG-MDI-(Material-Design-Icons)",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1027,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Fontawesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"fas\", \"fab\", \"fal\" or \"far\" prefixes. Go to FontAwesome, look for your desired icon, click on it. You'll get to its page. Below the icon name (as title), you will see something like <i class=\"fas fa-air-freshener\"></i>. This would translate to fasAirFreshner. The prefix from the tag is important. Note that we cannot supply the \"Pro\" version of the icons in svg format because of the license. Import statement example: import { fasAirFreshener } from '@quasar/extras/fontawesome-v5'.",
    "anchor": "SVG-Fontawesome",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1028,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Ionicons",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"ionMd\" or \"ionIos\" prefixes. Go to Ionicons v5 or Ionicons v4, look for your desired icon, click on it. At the bottom of the page there will appear a popup. Notice something like <ion-icon name=\"square-outline\"></ion-icon>. Remember the name (eg. \"square-outline\"). Camel-case this name and prefix it with either \"ionMd\" (for material variant) or \"ionIos\" (for iOS variant). Import statement example: import { ionMdSquareOutline } from '@quasar/extras/ionicons-v5' (or -v4).",
    "anchor": "SVG-Ionicons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1029,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Eva Icons",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"eva\" prefix. Go to Eva Icons, look for your desired icon, click on it. A dialog box will appear. Get the name from there (eg. \"attach-outline\"), prefix it with \"eva\" and camel-case the result (eg. \"evaAttachOutline\"). Import statement example: import { evaAttachOutline } from '@quasar/extras/eva-icons'.",
    "anchor": "SVG-Eva-Icons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1030,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Themify",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"ti\" prefix. Go to Themify, look for your desired icon. Remember its name (eg. \"ti-arrow-top-right\"), prefix it with \"ti\" and camel-case the result (eg. \"tiArrowTopRight\"). Import statement example: import { tiArrowTopRight } from '@quasar/extras/themify'.",
    "anchor": "SVG-Themify",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1031,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Import guide",
    "hierarchy_lvl4": "SVG Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Icon names are in camel-case and always begin with \"la\" prefix. Go to Line Awesome, look for your desired icon, click on it. A dialog box will appear. You'll see something like <i class=\"lab la-behance-square\"></i>. This would translate to: laBehanceSquare. There is a special case though (only for solid icons!): if the prefix before \"la-\" is \"las\" (eg. <i class=\"las la-atom\"></i>), then you need to suffix \"la-atom\" with \"-solid\" and camel-case the result (eg. laAtomSolid). Import statement example: import { laBehanceSquare } from '@quasar/extras/line-awesome'.",
    "anchor": "SVG-Line-Awesome",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1032,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Svg icons",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "SVG Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also supply your own svg icons. An svg icon is essentially a String with the following syntax: Examples:",
    "anchor": "Svg-icon-format",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1033,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "SVG-use way",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "SVG Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This svg method allows you to store the SVG files as static assets and reference them. The standard HTML way is to include the file and specify the icon with the svg use tag. To use this with Quasar through QIcon (make sure that you are referencing the correct file from your public or statics folder): By default, the parent svg's viewBox is \"0 0 24 24\". However, you can also specify a custom one:",
    "anchor": "SVG-use-way",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1034,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Inlined svg",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "SVG Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you don't want to use the webfont or svg variants from above, note that QIcon also supports one inlined <svg> tag (the content of the svg can be anything, not only a path). Reasoning on why to use an <svg> in a QIcon is that the svg will respect the size and color as any QIcon through its props. Without these features, you're better off inlining the svg in your templates without wrapping with QIcon. Some limitations: * do not use \"height\"/\"width\" attributes on the <svg> tag (it will break QIcon's way of handling the size) * all <path>s will have \"fill: currentColor\" CSS applied by default; if you don't want that, then add fill=\"none\" to the <path> tag",
    "anchor": "Inlined-svg",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1035,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Image icons",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "SVG Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "All icon related props of Quasar components can make use of this.  Remember that you can place images in your /public folder too and point to them. You don't always need a full URL.  This is not restricted to SVG only. You can use whatever image type you want (png, jpg, ...): It is also possible to inline the image (svg, png, jpeg, gif...) and dynamically change its style (svg): You can also base64 encode an image and supply it. The example below is with a QBtn, but the same principle is involved when dealing with any icon prop or with QIcon:",
    "anchor": "Image-icons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1036,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Custom mapping",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "SVG Line Awesome",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Should you want, you can customize the mapping of icon names. This can be done by overriding $q.iconMapFn. The recommended place to do it is in the created() hook of your /src/App.vue component. The syntax for $q.iconMapFn is as follows: Let's take both cases now.",
    "anchor": "Custom-mapping",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1037,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Custom mapping",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "1. Support for custom icon library",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This is especially useful when you are using a custom icon library (that doesn't come with Quasar and its @quasar/extras package). Notice in the examples above that we are returning a my-app-icon class that gets applied to QIcon if our icon starts with app: prefix. We can use it to define how QIcon should react to it, from a CSS point of view. Let's assume we have our own webfont called \"My App Icon\". We should then edit our quasar.conf.js (if using Quasar CLI) to add the newly created CSS file into our app: And also add \"my-app-icon.woff2\" and \"my-app-icon.woff\" files into the same folder as \"my-app-icon.css\" (or somewhere else, but edit the relative paths (see \"src:\" above) to the woff/woff2 files).",
    "anchor": "1.-Support-for-custom-icon-library",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1038,
    "hierarchy_lvl0": "Icon",
    "hierarchy_lvl1": "Icon",
    "hierarchy_lvl2": "Custom mapping",
    "hierarchy_lvl3": "Svg icon format",
    "hierarchy_lvl4": "2. Simply mapping a few icons",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Now we can use <q-icon name=\"app:copy\" /> or <q-icon name=\"app:icon1\" /> and QIcon will treat \"app:copy\" and \"app:icon1\" as if they were written as \"fas fa-copy\" and \"img:/path/to/icon1.svg\".",
    "anchor": "2.-Simply-mapping-a-few-icons",
    "url": "/vue-components/icon"
  },
  {
    "objectID": 1039,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QImg Vue component makes working with responsive images easy and also adds a nice loading effect to them along with many other features like custom aspect ratio and captions.",
    "anchor": "Introduction",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1040,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, we add a blur and sepia effect. Furthermore, we make use of the rounded-borders CSS helper class.",
    "anchor": "Introduction",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1041,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Fit mode",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are multiple ways in which the image can be displayed through the fit property: 'cover', 'fill' (default), 'contain', 'none', 'scale-down'. It is basically the same thing as the CSS prop called object-fit. Some modes lead to empty space (horizontally or vertically) besides the image. You can also configure the position through position property, which is equivalent to the CSS object-position one. Its default value is \"50% 50%\".",
    "anchor": "Fit-mode",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1042,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Loading states",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you have big-sized images, you can use a placeholder image (recommended to be specified in base64 encoding) like in the example below. The placeholder will be displayed until the target image gets loaded. We're toggling the QImg tag so you can see the placeholder image in action.",
    "anchor": "Loading-states",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1043,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Responsive",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To grasp the sizes and srcset properties, please read about native support on responsive images because QImg relies on that entirely.   For sizes property, please read about Resolution Switching: Different Sizes.   For srcset property, please read about Resolution Switching: Same size, different resolutions.",
    "anchor": "Responsive",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1044,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Render on demand",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For browsers that natively support the loading=\"lazy\" DOM attribute you can take advantage of it. Quasar will use it and tell the browser to request the image and render it only if the image is currently being displayed on screen (or when it is scrolled into the screen). One alternative is to use the QIntersection component as a wrapper or Intersection directive.",
    "anchor": "Render-on-demand",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1045,
    "hierarchy_lvl0": "Img",
    "hierarchy_lvl1": "QImg",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "No native context menu",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below we disable the native context menu on the images.  When you are using this option always take care to have the content of the default or error slots wrapped in a div element, or add a all-pointer-events class on the element.",
    "anchor": "No-native-context-menu",
    "url": "/vue-components/img"
  },
  {
    "objectID": 1046,
    "hierarchy_lvl0": "Infinite Scroll",
    "hierarchy_lvl1": "Infinite Scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QInfiniteScroll Vue component allows you to load new content as the user scrolls the page.",
    "anchor": "Introduction",
    "url": "/vue-components/infinite-scroll"
  },
  {
    "objectID": 1047,
    "hierarchy_lvl0": "Infinite Scroll",
    "hierarchy_lvl1": "Infinite Scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Infinite Scroll loads items in advance when less than offset (default = 500) pixels is left to be seen. If the content you fetch has height less than the scroll target container’s height on screen then Infinite Scroll will continue loading more content. So make sure you load enough content.   In your @load function, don't forget to call the passed in done() function when you have finished loading more data.  Scroll to the bottom to see QInfiniteScroll in action.",
    "anchor": "Introduction",
    "url": "/vue-components/infinite-scroll"
  },
  {
    "objectID": 1048,
    "hierarchy_lvl0": "Infinite Scroll",
    "hierarchy_lvl1": "Infinite Scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Tips",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you pass a custom scroll target container with scroll-target prop you must make sure that the element exists and that it can be overflowed (it must have a maximum height and an overflow that allows scrolling). If the scroll target container cannot be overflowed you'll get a forever loading situation.",
    "anchor": "Tips",
    "url": "/vue-components/infinite-scroll"
  },
  {
    "objectID": 1049,
    "hierarchy_lvl0": "Inner Loading",
    "hierarchy_lvl1": "Inner Loading",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QInnerLoading Vue component allows you to add a loading indicator within a component in the form of a local overlay.",
    "anchor": "Introduction",
    "url": "/vue-components/inner-loading"
  },
  {
    "objectID": 1050,
    "hierarchy_lvl0": "Inner Loading",
    "hierarchy_lvl1": "Inner Loading",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for the spinner to be properly placed in the center of the element you want the loading display to show over, that element must have CSS position set to relative (or the relative-position CSS class declared).   QInnerLoading must be the last element inside its parent so it can appear on top of the other content.",
    "anchor": "Introduction",
    "url": "/vue-components/inner-loading"
  },
  {
    "objectID": 1051,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QIntersection vue component, a wrapper over Quasar's Intersection directive.",
    "anchor": "Introduction",
    "url": "/vue-components/intersection"
  },
  {
    "objectID": 1052,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The main benefit of using QIntersection is, however, that the DOM tree is freed up of hidden nodes thus using the minimum possible RAM memory and making the page feel very snappy. As well, you can specify the tag property for the wrapper element to match your own needs, thus eliminating yet another DOM node. Under the covers, it uses the Intersection Observer API.  Not all browsers support the Intersection Observer API. Most modern browsers do, but other browsers do not. If you need to support older browsers, you can install and import (into a boot file) the official W3C polyfill.",
    "anchor": "Introduction",
    "url": "/vue-components/intersection"
  },
  {
    "objectID": 1053,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In most cases, it is required that you apply CSS to the QIntersection element so that it acts as a necessary filler when the inner content is not rendered. This will allow for a smooth scrolling experience, because otherwise the scroll will jump erratically. An example of such needed CSS would be, for example, a fixed height or at least a min-height (and possibly even a fixed width, as in the examples below, where multiple QIntersections can be displayed on same row).   If using the transition prop, it is required that the content be wrapped in one and only one element.   There are edge cases where the default viewport won't work. For instance, when your code is hosted in an iframe (like Codepen). This is where you need to use the root property. It allows you define an alternative to the viewport as your root (through its DOM element). It is important to keep in mind that root needs to be an ancestor of the observed element.",
    "anchor": "Usage",
    "url": "/vue-components/intersection"
  },
  {
    "objectID": 1054,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below we used a Quasar transition. For a full list, please head to Transitions page.",
    "anchor": "Basic",
    "url": "/vue-components/intersection"
  },
  {
    "objectID": 1055,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Only once",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Triggering only once means, however, that you lose the benefit of freeing up the DOM tree. The content will remain in DOM regardless of visibility. The example below uses the root property and therefore can be seen in a Codepen (which hosts in an iframe).",
    "anchor": "Only-once",
    "url": "/vue-components/intersection"
  },
  {
    "objectID": 1056,
    "hierarchy_lvl0": "Knob",
    "hierarchy_lvl1": "Knob",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QKnob Vue component is used to take a number input through mouse or touch panning.",
    "anchor": "Introduction",
    "url": "/vue-components/knob"
  },
  {
    "objectID": 1057,
    "hierarchy_lvl0": "Knob",
    "hierarchy_lvl1": "Knob",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, QKnob inherits current text color (as arc progress color and inner label color) and current font size (as component size). For customization, you can use the size and color related props.",
    "anchor": "Introduction",
    "url": "/vue-components/knob"
  },
  {
    "objectID": 1058,
    "hierarchy_lvl0": "Knob",
    "hierarchy_lvl1": "Knob",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, show-value property also enables the default slot, so you can fill it with custom content, like even a QAvatar or a QTooltip. The font-size prop refers to the inner label font size.",
    "anchor": "Basic",
    "url": "/vue-components/knob"
  },
  {
    "objectID": 1059,
    "hierarchy_lvl0": "Knob",
    "hierarchy_lvl1": "Knob",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Min and max",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QKnob, otherwise formData will not contain it (if it should):",
    "anchor": "Min-and-max",
    "url": "/vue-components/knob"
  },
  {
    "objectID": 1060,
    "hierarchy_lvl0": "Linear Progress",
    "hierarchy_lvl1": "Linear Progress",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QLinearProgress Vue component displays a colored loading bar. The bar can either have a determinate progress or an indeterminate animation.",
    "anchor": "Introduction",
    "url": "/vue-components/linear-progress"
  },
  {
    "objectID": 1061,
    "hierarchy_lvl0": "Linear Progress",
    "hierarchy_lvl1": "Linear Progress",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For indeterminate state (above) or query state (below) you don't need to specify the value property.",
    "anchor": "Introduction",
    "url": "/vue-components/linear-progress"
  },
  {
    "objectID": 1062,
    "hierarchy_lvl0": "Linear Progress",
    "hierarchy_lvl1": "Linear Progress",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Reversed",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To add a label to the progress bar you can use the default slot. Take care to: - use a size big enough to allow showing the label - set a text color for the label so that it is visible both on the filled and unfilled areas, or use text-shadow CSS, or use a QBadge as in the example below",
    "anchor": "Reversed",
    "url": "/vue-components/linear-progress"
  },
  {
    "objectID": 1063,
    "hierarchy_lvl0": "List & List Items",
    "hierarchy_lvl1": "List and List Items",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to use the QList, QItem, QItemSection and QItemLabel Vue components.",
    "anchor": "Introduction",
    "url": "/vue-components/list-and-list-items"
  },
  {
    "objectID": 1064,
    "hierarchy_lvl0": "List & List Items",
    "hierarchy_lvl1": "List and List Items",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Lists can encapsulate Items or Item-like components, for example QExpansionItem or QSlideItem. Also QSeparator can be used to split up sections, where needed. List Items have the following pre-built child components: * QItemSection - An item section can have several uses for particular content. They are controlled via the avatar, thumbnail and side props. With no props, it will render the main section of your QItem (which spans to the fullest of available space). QItemLabel An item label is useful for predefined text content type within a QItemSection, or for header-like content of the QList itself.",
    "anchor": "Introduction",
    "url": "/vue-components/list-and-list-items"
  },
  {
    "objectID": 1065,
    "hierarchy_lvl0": "List & List Items",
    "hierarchy_lvl1": "List and List Items",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When you have multi-line items, you could use top property on QItemSection side/avatar to align the sections to top, overriding default middle alignment.",
    "anchor": "Usage",
    "url": "/vue-components/list-and-list-items"
  },
  {
    "objectID": 1066,
    "hierarchy_lvl0": "List & List Items",
    "hierarchy_lvl1": "List and List Items",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Active state",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice you can handle label overflow with lines prop, telling it how many lines it can span. However, this feature uses Webkit specific CSS so won't work in IE/Edge.",
    "anchor": "Active-state",
    "url": "/vue-components/list-and-list-items"
  },
  {
    "objectID": 1067,
    "hierarchy_lvl0": "List & List Items",
    "hierarchy_lvl1": "List and List Items",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "More involved examples",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For demoing purposes in the example below, we're using the active prop instead of QItem's router props (to, exact). UMD doesn't have Vue Router so you wouldn't be able to play with it in Codepen/jsFiddle.  For more complex menus, consider also using QExpansionItem.",
    "anchor": "More-involved-examples",
    "url": "/vue-components/list-and-list-items"
  },
  {
    "objectID": 1068,
    "hierarchy_lvl0": "List & List Items",
    "hierarchy_lvl1": "List and List Items",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Connecting to Vue Router",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Connecting-to-Vue-Router",
    "url": "/vue-components/list-and-list-items"
  },
  {
    "objectID": 1069,
    "hierarchy_lvl0": "Markup Table",
    "hierarchy_lvl1": "Markup Table",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QMarkupTable Vue component is a helper wrapper which styles a native table.",
    "anchor": "Introduction",
    "url": "/vue-components/markup-table"
  },
  {
    "objectID": 1070,
    "hierarchy_lvl0": "Markup Table",
    "hierarchy_lvl1": "Markup Table",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For advanced functionality like pagination, sorting, filtering, and many more, you may want to check out QTable component instead.",
    "anchor": "Introduction",
    "url": "/vue-components/markup-table"
  },
  {
    "objectID": 1071,
    "hierarchy_lvl0": "Markup Table",
    "hierarchy_lvl1": "Markup Table",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that the content of QMarkupTable reflects an accurate markup representation of a native HTML <table>, having a <thead> and <tbody> to wrap header and table body. This is required.   UMD developers This component will NOT work as-is within the UMD version of Quasar. Browsers parse the template HTML before Vue kicks in and renders it, so the markup needs to be correct. <q-markup-table> <thead> or <q-markup-table> <tbody> is not. The solution is to directly use the QMarkupTable Vue rendered tag (<table class=\"....).",
    "anchor": "Usage",
    "url": "/vue-components/markup-table"
  },
  {
    "objectID": 1072,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QMenu Vue component is a convenient way to show menus.",
    "anchor": "Introduction",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1073,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The idea with QMenu is to place it inside your DOM element / component that you want to be the trigger as direct child. Don’t worry about QMenu content inheriting CSS from the container as the QMenu will be injected as a direct child of <body> through a Quasar Portal.  Don't forget to use the directive v-close-popup in your clickable menu items if you want the menu to close automatically. Alternatively, you can use the QMenu's property auto-close or handle closing the menu yourself through its v-model.",
    "anchor": "Introduction",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1074,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also set QMenu to act as a context menu. On desktop, you need to right click the parent target to trigger it, and on mobile a long tap will do the job.",
    "anchor": "Basic",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1075,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Persistent",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want the QMenu to not close if app route changes or if hitting ESCAPE key or if clicking/tapping outside of the menu, then use persistent prop:",
    "anchor": "Persistent",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1076,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Transitions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below there's a few transitions showcased. For a full list of transitions available, go to Transitions.",
    "anchor": "Transitions",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1077,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Reusable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below shows how to create a re-usable menu that can be shared with different targets.",
    "anchor": "Reusable",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1078,
    "hierarchy_lvl0": "Menu",
    "hierarchy_lvl1": "QMenu",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Positioning",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The position of QMenu can be customized. It keeps account of the anchor and self optional props. The final position of QMenu popup is calculated so that it will be displayed on the available screen real estate, switching to the right-side and/or top-side when necessary. For horizontal positioning you can use start and end when you want to automatically take into account if on RTL or non-RTL. start and end mean \"left\" for non-RTL and \"right\" for RTL.",
    "anchor": "Positioning",
    "url": "/vue-components/menu"
  },
  {
    "objectID": 1079,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QNoSsr Vue component makes it easy to differentiate content between server-side and client-side.",
    "anchor": "Introduction",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1080,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Alternatively, you can also use it to render content only on server-side and it automatically removes it if it ends up running on a client browser.",
    "anchor": "Introduction",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1081,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Usage",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1082,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Multiple client nodes",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Multiple-client-nodes",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1083,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Multiple client nodes with tag prop",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Multiple-client-nodes-with-tag-prop",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1084,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Placeholder property",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Placeholder-property",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1085,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Placeholder slot",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Placeholder-slot",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1086,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Multiple content in placeholder slot",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Multiple-content-in-placeholder-slot",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1087,
    "hierarchy_lvl0": "No SSR",
    "hierarchy_lvl1": "QNoSsr",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Only placeholder slot",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Only-placeholder-slot",
    "url": "/vue-components/no-ssr"
  },
  {
    "objectID": 1088,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Resize Observer (for Element)",
    "hierarchy_lvl2": "Resize Observer (for Element)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QResizeObserver Vue component emits a 'resize' event whenever the wrapping DOM element changes its width or height.",
    "anchor": "Introduction",
    "url": "/vue-components/resize-observer"
  },
  {
    "objectID": 1089,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Resize Observer (for Element)",
    "hierarchy_lvl2": "Resize Observer (for Element)",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that QResizeObserver will issue an event as soon as it gets rendered and attached to DOM, so you can have the initial size of the container.",
    "anchor": "Introduction",
    "url": "/vue-components/resize-observer"
  },
  {
    "objectID": 1090,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Scroll Observer",
    "hierarchy_lvl2": "Scroll Observer",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QScrollObserver Vue component emits an event whenever the user scrolls the page or the parent scrollable container.",
    "anchor": "Introduction",
    "url": "/vue-components/scroll-observer"
  },
  {
    "objectID": 1091,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Scroll Observer",
    "hierarchy_lvl2": "Scroll Observer",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Components like QScrollArea, for example, respect this design and have the scroll class embedded into it, so that QScrollObservable (or any other scrolling component or directive) can successfully detect it and attach the necessary event handlers to it. Please note that simply attaching scroll CSS class to a DOM element or on a Vue component will have no effect if the respective element is not overflowed (example, with: CSS overflow: hidden and a height smaller than its inner content height). <!-- example with v-scroll directive --> <div v-scroll=\"scrollHandler\">...</div> </div> ``` One more example with QScrollArea: html <q-scroll-area style=\"width: 400px; height: 500px;\" class=\"bg-yellow\"> ...content expanding over the 500px height from container... <q-scroll-observer @scroll=\"scrollHandler\" /> </q-scroll-area>",
    "anchor": "Introduction",
    "url": "/vue-components/scroll-observer"
  },
  {
    "objectID": 1092,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Scroll Observer",
    "hierarchy_lvl2": "Horizontal",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Horizontal",
    "url": "/vue-components/scroll-observer"
  },
  {
    "objectID": 1093,
    "hierarchy_lvl0": "Vue Components",
    "hierarchy_lvl1": "Scroll Observer",
    "hierarchy_lvl2": "Layout Scrolling",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Layout-Scrolling",
    "url": "/vue-components/scroll-observer"
  },
  {
    "objectID": 1094,
    "hierarchy_lvl0": "Pagination",
    "hierarchy_lvl1": "Pagination",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QPagination Vue component allows you to easily display a pagination control on a page.",
    "anchor": "Introduction",
    "url": "/vue-components/pagination"
  },
  {
    "objectID": 1095,
    "hierarchy_lvl0": "Parallax",
    "hierarchy_lvl1": "QParallax",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QParallax Vue component makes it easy to embed a parallax scrolling effect into a page.",
    "anchor": "Introduction",
    "url": "/vue-components/parallax"
  },
  {
    "objectID": 1096,
    "hierarchy_lvl0": "Parallax",
    "hierarchy_lvl1": "QParallax",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QParallax takes care of a lot of quirks, including image/video size which can actually be smaller than the window width/height.",
    "anchor": "Introduction",
    "url": "/vue-components/parallax"
  },
  {
    "objectID": 1097,
    "hierarchy_lvl0": "Parallax",
    "hierarchy_lvl1": "QParallax",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On some iOS platforms there may be problems regarding the autoplay feature of the native <video> tag. Reference. QParallax and Quasar are not interfering in any way with the client browser's ability/restrictions on the <video> tag.   When using the video tag inside QParallax, you must provide the width and height attributes in order for QParallax to work properly because of the intrinsic resizing capabilities of this type of media. Also, be aware that the actual video width and height are not available until the video's metadata has been loaded.",
    "anchor": "Usage",
    "url": "/vue-components/parallax"
  },
  {
    "objectID": 1098,
    "hierarchy_lvl0": "Popup Edit",
    "hierarchy_lvl1": "Popup Edit",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QPopupEdit Vue component can be used to edit a value 'in place', like for example on a cell in QTable.",
    "anchor": "Introduction",
    "url": "/vue-components/popup-edit"
  },
  {
    "objectID": 1099,
    "hierarchy_lvl0": "Popup Edit",
    "hierarchy_lvl1": "Popup Edit",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This component injects a QMenu into its parent DOM element and enables the behavior described above, so it can be used anywhere, not only in QTable.",
    "anchor": "Introduction",
    "url": "/vue-components/popup-edit"
  },
  {
    "objectID": 1100,
    "hierarchy_lvl0": "Popup Edit",
    "hierarchy_lvl1": "Popup Edit",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If used on a QTable, QPopupEdit won't work with cell scoped slots.",
    "anchor": "Usage",
    "url": "/vue-components/popup-edit"
  },
  {
    "objectID": 1101,
    "hierarchy_lvl0": "Popup Edit",
    "hierarchy_lvl1": "Popup Edit",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Standalone",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not destructure the slot's parameters as it will generate linting errors when using the value prop directly with v-model.",
    "anchor": "Standalone",
    "url": "/vue-components/popup-edit"
  },
  {
    "objectID": 1102,
    "hierarchy_lvl0": "Popup Edit",
    "hierarchy_lvl1": "Popup Edit",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Textarea / QEditor",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When using a multi-line control (textarea, QEditor) for input, you'll need to also use @keyup.enter.stop on the component in order to stop the enter key from closing the popup. You'll also need to add buttons for controlling the popup too.",
    "anchor": "Textarea-%2F-QEditor",
    "url": "/vue-components/popup-edit"
  },
  {
    "objectID": 1103,
    "hierarchy_lvl0": "Popup Edit",
    "hierarchy_lvl1": "Popup Edit",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Validation",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tip 1 Notice we are using the hide event to also revalidate the input. If we don't, QInput's error prop will 'hang' in an invalid state.   Tip 2 With this example, we are using QInput's external error handling. We could also use QInput's validation prop and emit the value to QPopupEdit's validation prop. The same concept can be implemented, when using Vuelidate too. In other words, the value given to QPopupEdit's validate function can come from anywhere.",
    "anchor": "Validation",
    "url": "/vue-components/popup-edit"
  },
  {
    "objectID": 1104,
    "hierarchy_lvl0": "Popup Proxy",
    "hierarchy_lvl1": "Popup Proxy",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QPopupProxy is a Vue component that should be used when you need either a QMenu or a QDialog (on smaller screens) to be displayed.",
    "anchor": "Introduction",
    "url": "/vue-components/popup-proxy"
  },
  {
    "objectID": 1105,
    "hierarchy_lvl0": "Popup Proxy",
    "hierarchy_lvl1": "Popup Proxy",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On the example below, click on the icon in the input.",
    "anchor": "Introduction",
    "url": "/vue-components/popup-proxy"
  },
  {
    "objectID": 1106,
    "hierarchy_lvl0": "Popup Proxy",
    "hierarchy_lvl1": "Popup Proxy",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Pass-through props",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QPopupProxy treats some components (QDate, QTime, QCarousel and QColor) as special ones and forces cover: true and maxHeight: '99vh' on them. If you don't want this behavior just place a div as the first level child of QPopupProxy.",
    "anchor": "Pass-through-props",
    "url": "/vue-components/popup-proxy"
  },
  {
    "objectID": 1107,
    "hierarchy_lvl0": "Pull to refresh",
    "hierarchy_lvl1": "Pull to refresh",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QPullToRefresh Vue component allows the user to pull down in order to refresh or retrieve the newest content on a page.",
    "anchor": "Introduction",
    "url": "/vue-components/pull-to-refresh"
  },
  {
    "objectID": 1108,
    "hierarchy_lvl0": "Pull to refresh",
    "hierarchy_lvl1": "Pull to refresh",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In your @refresh function, don't forget to call the passed in done() function when you have finished loading more data.  To refresh, pull down (with mouse or through finger touch) on the content below when the inner scroll position is the top.",
    "anchor": "Introduction",
    "url": "/vue-components/pull-to-refresh"
  },
  {
    "objectID": 1109,
    "hierarchy_lvl0": "Rating",
    "hierarchy_lvl1": "Rating",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QRating Vue component allows the user to rate items. It's usually known as 'star rating'.",
    "anchor": "Introduction",
    "url": "/vue-components/rating"
  },
  {
    "objectID": 1110,
    "hierarchy_lvl0": "Rating",
    "hierarchy_lvl1": "Rating",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, when using the icon-selected prop, notice we can still use icon as well. The latter becomes the icon(s) when they are not selected.",
    "anchor": "Introduction",
    "url": "/vue-components/rating"
  },
  {
    "objectID": 1111,
    "hierarchy_lvl0": "Rating",
    "hierarchy_lvl1": "Rating",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Colors",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When using the color-selected prop, notice we can still use color as well. The latter becomes the color(s) of the icons when they are not selected.",
    "anchor": "Colors",
    "url": "/vue-components/rating"
  },
  {
    "objectID": 1112,
    "hierarchy_lvl0": "Rating",
    "hierarchy_lvl1": "Rating",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Floating number",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice how we can add tooltips to each icon in the example below.",
    "anchor": "Floating-number",
    "url": "/vue-components/rating"
  },
  {
    "objectID": 1113,
    "hierarchy_lvl0": "Rating",
    "hierarchy_lvl1": "Rating",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Sizes",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apart from the standard sizes below, you can define your own through the size property.",
    "anchor": "Sizes",
    "url": "/vue-components/rating"
  },
  {
    "objectID": 1114,
    "hierarchy_lvl0": "Rating",
    "hierarchy_lvl1": "Rating",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Readonly and disable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When dealing with a native form which has an action and a method (eg. when using Quasar with ASP.NET controllers), you need to specify the name property on QRating, otherwise formData will not contain it (if it should):",
    "anchor": "Readonly-and-disable",
    "url": "/vue-components/rating"
  },
  {
    "objectID": 1115,
    "hierarchy_lvl0": "Responsive",
    "hierarchy_lvl1": "Responsive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QResponsive Vue component forces the content to maintain an aspect ratio based on its width.",
    "anchor": "Introduction",
    "url": "/vue-components/responsive"
  },
  {
    "objectID": 1116,
    "hierarchy_lvl0": "Responsive",
    "hierarchy_lvl1": "Responsive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "TIPS * The component can be used with any content, as long you specify only one direct child. If you need multiple elements inside of it, wrap them in a <div>. * It is your responsibility to make sure that your content won't overflow the container.   Do not use it on Quasar components that already have a ratio property, like QImg or QVideo, or on components that have a forced height.",
    "anchor": "Introduction",
    "url": "/vue-components/responsive"
  },
  {
    "objectID": 1117,
    "hierarchy_lvl0": "Responsive",
    "hierarchy_lvl1": "Responsive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note below that we are using a vertical alignment (items-start) other than the default (stretch), so that flexbox won't force the height on each QResponsive component.",
    "anchor": "Basic",
    "url": "/vue-components/responsive"
  },
  {
    "objectID": 1118,
    "hierarchy_lvl0": "Responsive",
    "hierarchy_lvl1": "Responsive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "On some components",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below are just a few examples. QResponsive is not restricted to only QCard and QCarousel. Notice that we will not supply a height prop to QCarousel when we use QResponsive on it, since it's QResponsive who will take care of that.",
    "anchor": "On-some-components",
    "url": "/vue-components/responsive"
  },
  {
    "objectID": 1119,
    "hierarchy_lvl0": "Responsive",
    "hierarchy_lvl1": "Responsive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Maximum height",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Apply the max height (or max width, etc etc) directly on the QResponsive component through a CSS class or inline. Remember that it is still your responsibility to ensure that the content won't overflow the container.",
    "anchor": "Maximum-height",
    "url": "/vue-components/responsive"
  },
  {
    "objectID": 1120,
    "hierarchy_lvl0": "Scroll Area",
    "hierarchy_lvl1": "Scroll Area",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QScrollArea Vue component offers a way of customizing the scrollbars for all desktop browsers.",
    "anchor": "Introduction",
    "url": "/vue-components/scroll-area"
  },
  {
    "objectID": 1121,
    "hierarchy_lvl0": "Scroll Area",
    "hierarchy_lvl1": "Scroll Area",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following examples are best seen on desktop as they make too little sense on a mobile device.  You can also take a look at Layout Drawer to see some more examples of it in action.",
    "anchor": "Introduction",
    "url": "/vue-components/scroll-area"
  },
  {
    "objectID": 1122,
    "hierarchy_lvl0": "Scroll Area",
    "hierarchy_lvl1": "Scroll Area",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When using the visible Boolean prop, the default mouse over/leave behavior is disabled, leaving you in full control of the scrollbar visibility.",
    "anchor": "Basic",
    "url": "/vue-components/scroll-area"
  },
  {
    "objectID": 1123,
    "hierarchy_lvl0": "Scroll Area",
    "hierarchy_lvl1": "Scroll Area",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Delay",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When content changes, the scrollbar appears then disappears again. You can set a certain delay (amount of time in milliseconds) before scrollbar disappears again (if component is not hovered):",
    "anchor": "Delay",
    "url": "/vue-components/scroll-area"
  },
  {
    "objectID": 1124,
    "hierarchy_lvl0": "Scroll Area",
    "hierarchy_lvl1": "Scroll Area",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Scroll position",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is an example of using the @scroll event to synchronize the scrolling between two containers.",
    "anchor": "Scroll-position",
    "url": "/vue-components/scroll-area"
  },
  {
    "objectID": 1125,
    "hierarchy_lvl0": "Separator",
    "hierarchy_lvl1": "Separator",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSeparator Vue component is used to separate sections of text or other components or elements. It creates a colored line across the width of the parent. It can be horizontal or vertical.",
    "anchor": "Introduction",
    "url": "/vue-components/separator"
  },
  {
    "objectID": 1126,
    "hierarchy_lvl0": "Skeleton",
    "hierarchy_lvl1": "Skeleton",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSkeleton Vue component is used to display a placeholder preview of your content before you load the actual page data.",
    "anchor": "Introduction",
    "url": "/vue-components/skeleton"
  },
  {
    "objectID": 1127,
    "hierarchy_lvl0": "Skeleton",
    "hierarchy_lvl1": "Skeleton",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below you can see the predefined types. There are some basic types (text, rect, circle) and also some special convenience types that accurately respect Quasar components size and border radius.",
    "anchor": "Introduction",
    "url": "/vue-components/skeleton"
  },
  {
    "objectID": 1128,
    "hierarchy_lvl0": "Skeleton",
    "hierarchy_lvl1": "Skeleton",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Animations",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Enjoy some pre-made recipes. Your imagination is the only limit.",
    "anchor": "Animations",
    "url": "/vue-components/skeleton"
  },
  {
    "objectID": 1129,
    "hierarchy_lvl0": "Slide Item",
    "hierarchy_lvl1": "Slide Item",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSlideItem Vue component is essentially a QItem with two additional slots (left and right) which allows the user to drag it to one of the sides in order to apply a specific action.",
    "anchor": "Introduction",
    "url": "/vue-components/slide-item"
  },
  {
    "objectID": 1130,
    "hierarchy_lvl0": "Slide Item",
    "hierarchy_lvl1": "Slide Item",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If your content also has images, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.",
    "anchor": "Introduction",
    "url": "/vue-components/slide-item"
  },
  {
    "objectID": 1131,
    "hierarchy_lvl0": "Slide Transition",
    "hierarchy_lvl1": "Slide Transition",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSlideTransition Vue component slides the encapsulated element up or down, based on its visibility. Works alongside v-show and v-if.",
    "anchor": "Introduction",
    "url": "/vue-components/slide-transition"
  },
  {
    "objectID": 1132,
    "hierarchy_lvl0": "Space",
    "hierarchy_lvl1": "QSpace",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSpace Vue component fills all the available space inside of a flexbox DOM element.",
    "anchor": "Introduction",
    "url": "/vue-components/space"
  },
  {
    "objectID": 1133,
    "hierarchy_lvl0": "Spinners",
    "hierarchy_lvl1": "Spinners",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSpinner and its derived Vue components are used to show the user a timely process is currently taking place. It gives the user the feeling the system is continuing to work for longer term activities.",
    "anchor": "Introduction",
    "url": "/vue-components/spinners"
  },
  {
    "objectID": 1134,
    "hierarchy_lvl0": "Spinners",
    "hierarchy_lvl1": "Spinners",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, hover over the spinners to see their names. Please note that by default, QSpinner and all other spinners inherit the font-size of the parent and applies it as its size.",
    "anchor": "Introduction",
    "url": "/vue-components/spinners"
  },
  {
    "objectID": 1135,
    "hierarchy_lvl0": "Spinners",
    "hierarchy_lvl1": "Spinners",
    "hierarchy_lvl2": "QSpinner API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The API below applies to all spinners, except for QSpinner. Making an example with QSpinnerCube.",
    "anchor": "QSpinner-API",
    "url": "/vue-components/spinners"
  },
  {
    "objectID": 1136,
    "hierarchy_lvl0": "Splitter",
    "hierarchy_lvl1": "QSplitter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QSplitter Vue component allow containers to be split vertically and/or horizontally through a draggable separator bar.",
    "anchor": "Introduction",
    "url": "/vue-components/splitter"
  },
  {
    "objectID": 1137,
    "hierarchy_lvl0": "Splitter",
    "hierarchy_lvl1": "QSplitter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The use of the before and after slots is required.  Click and drag on the splitter separator bar to see results.",
    "anchor": "Introduction",
    "url": "/vue-components/splitter"
  },
  {
    "objectID": 1138,
    "hierarchy_lvl0": "Splitter",
    "hierarchy_lvl1": "QSplitter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, the CSS unit used is '%' (percentage). But you can also use 'px' (pixels), as in the example below.",
    "anchor": "Basic",
    "url": "/vue-components/splitter"
  },
  {
    "objectID": 1139,
    "hierarchy_lvl0": "Splitter",
    "hierarchy_lvl1": "QSplitter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Reverse model",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, the model is connected to the before slot size. But you can reverse that and make it connect to the after slot, as in the example below. This feature turns out especially useful if your unit is set to pixels and you want to control the after slot.",
    "anchor": "Reverse-model",
    "url": "/vue-components/splitter"
  },
  {
    "objectID": 1140,
    "hierarchy_lvl0": "Splitter",
    "hierarchy_lvl1": "QSplitter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Adding content to separator",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you use images as content for the separator slot, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.",
    "anchor": "Adding-content-to-separator",
    "url": "/vue-components/splitter"
  },
  {
    "objectID": 1141,
    "hierarchy_lvl0": "Splitter",
    "hierarchy_lvl1": "QSplitter",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Dark design",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A QSplitter can be embedded in another QSplitter's before and/or after slots, like shown in example below.",
    "anchor": "Dark-design",
    "url": "/vue-components/splitter"
  },
  {
    "objectID": 1142,
    "hierarchy_lvl0": "Stepper",
    "hierarchy_lvl1": "Stepper",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QStepper Vue component conveys progress through a sequence of numbered steps. It may also be used for navigation. It's usually useful when the user has to follow steps to complete a process, like in a wizard.",
    "anchor": "Introduction",
    "url": "/vue-components/stepper"
  },
  {
    "objectID": 1143,
    "hierarchy_lvl0": "Stepper",
    "hierarchy_lvl1": "Stepper",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If the QStep content also has images and you want to use swipe actions to navigate, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.   Please take notice of the Boolean keep-alive prop for QStepper, if you need this behavior. Do NOT use Vue's native <keep-alive> component over QStep.",
    "anchor": "Introduction",
    "url": "/vue-components/stepper"
  },
  {
    "objectID": 1144,
    "hierarchy_lvl0": "Stepper",
    "hierarchy_lvl1": "Stepper",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Horizontal",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also connect contracted prop to $q.screen to create a responsive behavior, like :contracted=\"$q.screen.lt.md\". More info: Quasar Screen Plugin.",
    "anchor": "Horizontal",
    "url": "/vue-components/stepper"
  },
  {
    "objectID": 1145,
    "hierarchy_lvl0": "Stepper",
    "hierarchy_lvl1": "Stepper",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Style",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Play with coloring using the *-icon and *-color props (on QStepper or override on specific QStep). You can also use prefix prop (max 2 characters) instead of an icon for each step's header. This will be displayed if the step is not currently being edited and it isn't marked with error or as \"done\". You can use the header-class prop to apply any CSS class(es) to the header. In the example below, we are applying bolded text:",
    "anchor": "Style",
    "url": "/vue-components/stepper"
  },
  {
    "objectID": 1146,
    "hierarchy_lvl0": "Stepper",
    "hierarchy_lvl1": "Stepper",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Message slot",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This component allows you to place buttons within QStepper or QStep to navigate through the steps. It is up to you to add whatever buttons you require.  To use global navigation, you must add it to the QStepper 'navigation' slot.",
    "anchor": "Message-slot",
    "url": "/vue-components/stepper"
  },
  {
    "objectID": 1147,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTable Vue component allows you to display data in a tabular manner and it's packed with a lot of related features. It's generally called a datatable.",
    "anchor": "Introduction",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1148,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you don't need pagination, sorting, filtering, and all other features of QTable, then you may want to check out QMarkupTable component instead.",
    "anchor": "Introduction",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1149,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Defining the columns",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Let’s take an example of configuring the columns property. We are going to tell QTable that row-key is ‘name’, which must be unique. If this was data fetched from a database we would likely use the row id.",
    "anchor": "Defining-the-columns",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1150,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Basic usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use the dense prop along with $q.screen to create a responsive behavior. Example: :dense=\"$q.screen.lt.md\". More info: Screen Plugin.",
    "anchor": "Basic-usage",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1151,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Omitting columns definition",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can omit specifying the columns. QTable will infer the columns from the properties of the first row of the data. Note that labels are uppercased and sorting is enabled:",
    "anchor": "Omitting-columns-definition",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1152,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Sticky header/column",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Sticky headers and columns are achieved through CSS with position: sticky. This is NOT supported on all browsers. Check caniuse.com before using this technique.",
    "anchor": "Sticky-header%2Fcolumn",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1153,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Separators",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that when enabling virtual scroll you will need to specify the table-style (with a max-height) prop. In the example below, we are also forcing QTable to display all rows at once (note the use of pagination and rows-per-page-options props). You can dynamically load new rows when scroll reaches the end: You can have both virtual scroll and pagination: The example below shows how virtual scroll can be used along with a sticky header. Notice the virtual-scroll-sticky-start prop which is set to the header height. There are 2 utility CSS classes that control VirtualScroll size calculation: * Use q-virtual-scroll--with-prev class on an element rendered by the VirtualScroll to indicate that the element should be grouped with the previous one (main use case is for multiple table rows generated from the same row of data). * Use q-virtual-scroll--skip class on an element rendered by the VirtualScroll to indicate that the element's size should be ignored in size calculations.",
    "anchor": "Separators",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1154,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Selection",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The property row-key must be set in order for selection to work properly.",
    "anchor": "Selection",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1155,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Visible columns, custom top, fullscreen",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please note that columns marked as required (in the column definition) cannot be toggled and are always visible.",
    "anchor": "Visible-columns%2C-custom-top%2C-fullscreen",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1156,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Popup editing",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is an example with the user being able to edit “in place” with the help of QPopupEdit component. Please note that we are using the body scoped slot. QPopupEdit won’t work with cell scoped slots.",
    "anchor": "Popup-editing",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1157,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Grid style",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use the grid prop along with $q.screen to create a responsive behavior. Example: :grid=\"$q.screen.lt.md\". More info: Screen Plugin.  In the example below, we let QTable deal with displaying the grid mode (not using the specific slot): However, if you want to fully customize the content, check the example below, where: * We are using a Vue scoped slot called item to define how each record (the equivalent of a row in non-grid mode) should look. This allows you total freedom. * We are using multiple selection.",
    "anchor": "Grid-style",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1158,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Expanding rows",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Add unique (distinct) key on QTr if you generate more than one QTr from a row in data.  An external expansion model can also be used: If you are using virtual scroll with QTable, you should know that there are 2 utility CSS classes that control VirtualScroll size calculation: * Use q-virtual-scroll--with-prev class on an element rendered by the VirtualScroll to indicate that the element should be grouped with the previous one (main use case is for multiple table rows generated from the same row of data). * Use q-virtual-scroll--skip class on an element rendered by the VirtualScroll to indicate that the element's size should be ignored in size calculations.",
    "anchor": "Expanding-rows",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1159,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Before/after slots",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When pagination has a property named rowsNumber, then this means that you’ll be configuring Table for server-side pagination (& sorting & filtering). See \"Server side pagination, filter and sorting\" section.  Below are two examples of handling the pagination (and sorting and rows per page). The first example highlights how to configure the initial pagination: The second example uses the \"v-model:pagination\" directive because we want to access its current value at any time. A use-case for the technique below can be to control the pagination from outside of QTable.",
    "anchor": "Before%2Fafter-slots",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1160,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Pagination slot",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For learning purposes, we will customize the pagination controls with the default controls in order to help you get started with your own.",
    "anchor": "Pagination-slot",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1161,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Loading state",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below shows how you can use a slot to customize the entire row: Below, we use a slot which gets applied to each body cell: We can also customize only one particular column only. The syntax for this slot is body-cell-[name], where [name] should be replaced by the property of each row which is used as the row-key.",
    "anchor": "Loading-state",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1162,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Header slots",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below shows how you can use a slot to customize the entire header row: Bellow, we use a slot which gets applied to each header cell: We can also customize only one particular header cell only. The syntax for this slot is header-cell-[name], where [name] should be replaced by the property of each row which is used as the row-key.",
    "anchor": "Header-slots",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1163,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "No data",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There is also a \"no-data\" scoped slot (see below) that you can also to customize the messages for both when a filter doesn't returns any results or the table has no data to display. Also type something into the \"Search\" input.",
    "anchor": "No-data",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1164,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Handling bottom layer",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are a few properties that you can use to hide the bottom layer or specific parts of it. You can play with it below:",
    "anchor": "Handling-bottom-layer",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1165,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Custom sorting",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order to create responsive tables, we have two tools at our disposal: dense and grid properties. We can connect these with $q.screen. More info: Screen Plugin. First example below uses $q.screen.lt.md (for enabling dense mode) and the second examples uses $q.screen.xs to enable grid mode, so play with browser width to see them in action.",
    "anchor": "Custom-sorting",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1166,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Server side pagination, filter and sorting",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When your database contains a big number of rows for a Table, obviously it’s not feasible to load them all for multiple reasons (memory, UI rendering performance, …). Instead, you can load only a Table page. Whenever the user wants to navigate to another Table page, or wants to sort by a column or wants to filter the Table, a request is sent to the server to fetch the partially paged data. First step to enable this behavior is to specify pagination prop, which MUST contain rowsNumber. QTable needs to know the total number of rows available in order to correctly render the pagination links. Should filtering cause the rowsNumber to change then it must be modified dynamically. Second step is to listen for @request event on QTable. This event is triggered when data needs to be fetched from the server because either page number or sorting or filtering changed. It’s best that you also specify the loading prop in order to notify the user that a background process is in progress.  In the example below, steps have been taken to emulate an ajax call to a server. While the concepts are similar, if you use this code you will need to make the appropriate changes to connect to your own data source.",
    "anchor": "Server-side-pagination%2C-filter-and-sorting",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1167,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Exporting data",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is an example of a naive csv encoding and then exporting table data by using the exportFile Quasar util. The browser should trigger a file download. For a more professional approach in regards to encoding we do recommend using csv-parse and csv-stringify packages.  You could also make use of the filteredSortedRows internal computed property of QTable should you want to export the user filtered + sorted data.",
    "anchor": "Exporting-data",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1168,
    "hierarchy_lvl0": "Table",
    "hierarchy_lvl1": "Table",
    "hierarchy_lvl2": "Keyboard navigation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is an example of keyboard navigation in the table using selected row. Use ArrowUp, ArrowDown, PageUp, PageDown, Home and End keys to navigate.",
    "anchor": "Keyboard-navigation",
    "url": "/vue-components/table"
  },
  {
    "objectID": 1169,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTabs, QTab and QRouteTab Vue components are a way of helping the user navigate between pages or tab panels.",
    "anchor": "Introduction",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1170,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Works great along with QTabPanels, a component which refers strictly to the panels (tab content) themselves.",
    "anchor": "Introduction",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1171,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "TIPS * QTabs can be scrolled horizontally when the width is longer than the container width. Adjust your browser accordingly to see this in action. * On a desktop you will see chevrons on either side that can be clicked. * On a mobile, you can pan the tabs with your finger. * If you want to force arrows to be visible on mobile use mobile-arrows prop.   QRouteTab won't and cannot work with the UMD version if you don't also install Vue Router.",
    "anchor": "Usage",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1172,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the examples below, please notice the last two QTabs: indicator at top and no indicator.",
    "anchor": "Basic",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1173,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Tab notifications",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are multiple ways to display tab notifications: with a QBadge, through an alert dot or an alert icon (can be any).",
    "anchor": "Tab-notifications",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1174,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Alignment",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QTabs are responsive and the align prop (see below) becomes active when the container width (not window width) is bigger than the configured breakpoint. For demoing purposes, the tabs below have breakpoint disabled. In the second QTabs from the example below, if window width is below 1024px then the \"Movies\" and \"Photos\" tabs will be replaced by a \"More...\" dropdown.",
    "anchor": "Alignment",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1175,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "With dropdown",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice we need to specify the shrink prop. By default, QTabs tries to expand to all the available horizontal space, but in this case we are using it as a child of QToolbar so we don't want that.",
    "anchor": "With-dropdown",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1176,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Dynamic update",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QTabPanels can be used as standalone too. They do not depend on the presence of a QTabs. Also, they can be placed anywhere within a page, not just near a QTabs.  More info: Tab Panels.",
    "anchor": "Dynamic-update",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1177,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Connecting to Vue Router",
    "hierarchy_lvl3": "Dynamic update",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QRouteTab becomes \"active\" depending on your app's route and not due to the v-model. So the initial value of v-model or changing the v-model directly will not also change the route of your app.",
    "anchor": "Connecting-to-Vue-Router",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1178,
    "hierarchy_lvl0": "Tabs",
    "hierarchy_lvl1": "Tabs",
    "hierarchy_lvl2": "Connecting to Vue Router",
    "hierarchy_lvl3": "Handling custom navigation",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-custom-navigation",
    "url": "/vue-components/tabs"
  },
  {
    "objectID": 1179,
    "hierarchy_lvl0": "Tab Panels",
    "hierarchy_lvl1": "Tab Panels",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTabPanel Vue component is a way of displaying more information using less window real estate.",
    "anchor": "Introduction",
    "url": "/vue-components/tab-panels"
  },
  {
    "objectID": 1180,
    "hierarchy_lvl0": "Tab Panels",
    "hierarchy_lvl1": "Tab Panels",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "* Works great along with QTabs, a component which offers a nice way to select the active tab panel to display. * If the QTabpanel content also has images and you want to use swipe actions to navigate, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.   IMPORTANT Do not be mistaken by the \"QTabPanels\" component name. Panels do not require QTabs. They can be used as standalone too.   Please take notice of the Boolean keep-alive prop for QTabPanels, if you need this behavior. Do NOT use Vue's native <keep-alive> component over QTabPanel.",
    "anchor": "Introduction",
    "url": "/vue-components/tab-panels"
  },
  {
    "objectID": 1181,
    "hierarchy_lvl0": "Tab Panels",
    "hierarchy_lvl1": "Tab Panels",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QTabPanels can be used as standalone too. They do not depend on the presence of a QTabs. Also, they can be placed anywhere within a page, not just near QTabs.",
    "anchor": "Basic",
    "url": "/vue-components/tab-panels"
  },
  {
    "objectID": 1182,
    "hierarchy_lvl0": "Tab Panels",
    "hierarchy_lvl1": "Tab Panels",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Coloring",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For a full list of transitions, please check out Transitions.",
    "anchor": "Coloring",
    "url": "/vue-components/tab-panels"
  },
  {
    "objectID": 1183,
    "hierarchy_lvl0": "Tab Panels",
    "hierarchy_lvl1": "Tab Panels",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Custom transitions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, use your mouse to swipe through the panels or, if on a touch capable device, swipe with your fingers.",
    "anchor": "Custom-transitions",
    "url": "/vue-components/tab-panels"
  },
  {
    "objectID": 1184,
    "hierarchy_lvl0": "Timeline",
    "hierarchy_lvl1": "Timeline",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTimeline Vue component displays a list of events in chronological order. It is typically a graphic design showing a long bar labelled with dates alongside itself and usually events.",
    "anchor": "Introduction",
    "url": "/vue-components/timeline"
  },
  {
    "objectID": 1185,
    "hierarchy_lvl0": "Timeline",
    "hierarchy_lvl1": "Timeline",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "dense (default) is showing headings, titles, subtitles and content on the timeline-specified side of the time line (default on right) comfortable is showing headings, titles and content on the timeline-specified side of the time line (default on right) and the subtitles on the other side loose is showing headings on center, titles and content on the entry-specified side of the time line (default on right) and the subtitles on the other side",
    "anchor": "Introduction",
    "url": "/vue-components/timeline"
  },
  {
    "objectID": 1186,
    "hierarchy_lvl0": "Timeline",
    "hierarchy_lvl1": "Timeline",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is the same example, but using QTimelineEntry properties only instead of the default slot:",
    "anchor": "Usage",
    "url": "/vue-components/timeline"
  },
  {
    "objectID": 1187,
    "hierarchy_lvl0": "Timeline",
    "hierarchy_lvl1": "Timeline",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Using slots only",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is again the same example, but using only QTimelineEntry slots:",
    "anchor": "Using-slots-only",
    "url": "/vue-components/timeline"
  },
  {
    "objectID": 1188,
    "hierarchy_lvl0": "Timeline",
    "hierarchy_lvl1": "Timeline",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "On dark background",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QTimelineEntry only takes into account its side prop if QTimeline has the loose layout.",
    "anchor": "On-dark-background",
    "url": "/vue-components/timeline"
  },
  {
    "objectID": 1189,
    "hierarchy_lvl0": "Timeline",
    "hierarchy_lvl1": "Timeline",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Responsive",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The examples below uses $q.screen to detect changes in window size to see all 3 layouts in action.",
    "anchor": "Responsive",
    "url": "/vue-components/timeline"
  },
  {
    "objectID": 1190,
    "hierarchy_lvl0": "Toolbar",
    "hierarchy_lvl1": "Toolbar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QToolbar and QToolbarTitle Vue components are usually part of QHeader or QFooter, but it can be used anywhere on the page.",
    "anchor": "Introduction",
    "url": "/vue-components/toolbar"
  },
  {
    "objectID": 1191,
    "hierarchy_lvl0": "Toolbar",
    "hierarchy_lvl1": "Toolbar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can use the glossy class to make the toolbar glossy.",
    "anchor": "Introduction",
    "url": "/vue-components/toolbar"
  },
  {
    "objectID": 1192,
    "hierarchy_lvl0": "Tooltip",
    "hierarchy_lvl1": "Tooltip",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTooltip Vue component is to be used when you want to offer the user more information about a certain area in your App. When hovering the mouse over the target element (or briefly touching and holding on mobile platforms), the tooltip will appear.",
    "anchor": "Introduction",
    "url": "/vue-components/tooltip"
  },
  {
    "objectID": 1193,
    "hierarchy_lvl0": "Tooltip",
    "hierarchy_lvl1": "Tooltip",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below there's a few transitions showcased. For a full list of transitions available, go to Transitions.",
    "anchor": "Introduction",
    "url": "/vue-components/tooltip"
  },
  {
    "objectID": 1194,
    "hierarchy_lvl0": "Tooltip",
    "hierarchy_lvl1": "Tooltip",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Reusable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below shows how to create a re-usable menu that can be shared with different targets.",
    "anchor": "Reusable",
    "url": "/vue-components/tooltip"
  },
  {
    "objectID": 1195,
    "hierarchy_lvl0": "Tooltip",
    "hierarchy_lvl1": "Tooltip",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Positioning",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For horizontal positioning you can use start and end when you want to automatically take into account if on RTL or non-RTL. start and end mean \"left\" for non-RTL and \"right\" for RTL.",
    "anchor": "Positioning",
    "url": "/vue-components/tooltip"
  },
  {
    "objectID": 1196,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QTree is a highly configurable Vue component which displays hierarchical data, such as a table of contents in a tree structure.",
    "anchor": "Introduction",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1197,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "More info: QSplitter, QTabPanels.",
    "anchor": "Introduction",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1198,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Customize content",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice (in the example below) the default header and body slot customization. Notice (in the example below) the custom header and body slots.  Clicking or pressing SPACE or ENTER on the custom header selects the tree item (and the custom header is blurred). If you don't want this to happen just wrap the content of the custom header in a <div @click.stop @keypress.stop> (or add the listeners to the respective component/element that is emitting them).",
    "anchor": "Customize-content",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1199,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Accordion, filtering and selectable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below, sibling nodes get contracted when one gets expanded.",
    "anchor": "Accordion%2C-filtering-and-selectable",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1200,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Lazy loading",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Selection (through QTree selected prop) refers to the currently selected node (gets highlighted with different background). Ticking (through QTree ticked prop) refers to the checkbox associated with each node. Expansion (through QTree expanded prop) refers to the nodes that are expanded. All properties above require to be dynamically bound using v-model:<prop_name> directive in order for them to work correctly (example: v-model:expanded).",
    "anchor": "Lazy-loading",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1201,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Tick strategy",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are three ticking strategy: 'leaf', 'leaf-filtered', 'strict' with an additional (and default) 'none' which disables ticking. You can apply a global tick strategy for a QTree and locally change the ticking strategy for a certain node by specifying the tickStrategy in the nodes model.",
    "anchor": "Tick-strategy",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1202,
    "hierarchy_lvl0": "Tree",
    "hierarchy_lvl1": "Tree",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Custom filter method",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Custom-filter-method",
    "url": "/vue-components/tree"
  },
  {
    "objectID": 1203,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QUploader Vue component is a way for the user to upload files to a backend server.",
    "anchor": "Introduction",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1204,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "tip If all you want is an input file, you might want to consider using QFile picker component instead.",
    "anchor": "Introduction",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1205,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QUploader requires a back-end server to receive the files. The examples below will not actually upload.   QUploader is drag and drop compliant.   When using vee-validate, you have to rename the \"fieldBagName\" configuration of vee-validate for the q-uploader to work.",
    "anchor": "Usage",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1206,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Design",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, multiple files will be uploaded individually (one thread per file). Should you want all files to be uploaded in a single thread, use the batch property (second QUploader in the example below).",
    "anchor": "Design",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1207,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Restricting upload",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example above, we're using accept property. Its value must be a comma separated list of unique file type specifiers. Maps to 'accept' attribute of native input type=file element. More info.   Recommended format for the accept property is <mediatype>/<extension>. Examples: \"image/png\", \"image/png\". QUploader uses an <input type=\"file\"> under the covers and it relies entirely on the host browser to trigger the file picker. If the accept property (that gets applied to the input) is not correct, no file picker will appear on screen or it will appear but it will accept all file types.  You can also apply custom filters (which are executed after user picks files):",
    "anchor": "Restricting-upload",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1208,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Adding headers",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Use headers for setting additional XHR headers to be sent along the upload request. Also check form-fields prop in the API, if you need additional fields to be embedded.  These two props (headers and form-fields) can be used as a function too ((files) => Array), allowing you to dynamically set them based on the files that are to be uploaded.  There is also the with-credentials property, which sets withCredentials to true on the XHR used by the upload process.",
    "anchor": "Adding-headers",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1209,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling upload",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also customize the HTTP headers and HTTP method through headers and method props. Check QUploader API section.",
    "anchor": "Handling-upload",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1210,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Factory function",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Object described above can override the following QUploader props: url, method, headers, formFields, fieldName, withCredentials, sendRaw). The props of this Object can be Functions as well (of form (file[s]) => value): You can also use the factory Function prop and return immediately the same Object. This is useful if you want to set multiple props (described above) simultaneously:",
    "anchor": "Factory-function",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1211,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Slots",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the example below we're showing the equivalent of the default header. Also notice some Boolean scope properties that you can use: scope.canAddFiles, scope.canUpload, scope.isUploading.  Notice that you must install and use one more component (QUploaderAddTrigger) in order to be able to add files to the queue. This component needs to be placed under a DOM node which has position: relative (hint: QBtn has it already) and will automatically inject the necessary events when user clicks on its parent (do NOT manually add @click=\"scope.pickFiles\"). If the trigger is not working, check if you have an element rendered above it and change the zIndex of QUploaderAddTrigger accordingly.",
    "anchor": "Slots",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1212,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Server endpoint examples",
    "hierarchy_lvl3": "Slots",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "QUploader works by default with the HTTP(S) protocol to upload files (but it's not limited to it as you'll see in the section following this one).  It is by no means required to use a Nodejs server or Spring or ASP.NET like below -- you can handle file upload however you want, as long as the method you are using fits the HTTP protocol. Example with PHP.",
    "anchor": "Server-endpoint-examples",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1213,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Server endpoint examples",
    "hierarchy_lvl3": "Nodejs",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is a basic server example written in Nodejs. It does nothing other than receiving the files, so consider it as a starting point.",
    "anchor": "Nodejs",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1214,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Server endpoint examples",
    "hierarchy_lvl3": "ASP.NET MVC/Core",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If your server requires authentication such as a JWT token, use QUploader's factory function to specify the xhr header that will be used by QUploader. For example: The file(s) payload of QUploader will be a properly formed IFormFileCollection object that you can read via your ASP.NET Web API controller's .Request property. ASP.NET Core 2.2 Controller:",
    "anchor": "ASP.NET-MVC%2FCore",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1215,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Server endpoint examples",
    "hierarchy_lvl3": "Spring",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is a Spring example. Attribute fieldName=\"file\" is mapping with @RequestPart(value = \"file\").",
    "anchor": "Spring",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1216,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Server endpoint examples",
    "hierarchy_lvl3": "Python/Flask",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Python%2FFlask",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1217,
    "hierarchy_lvl0": "Uploader",
    "hierarchy_lvl1": "Uploader",
    "hierarchy_lvl2": "Supporting other services",
    "hierarchy_lvl3": "Python/Flask",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Help appreciated We'd be more than happy to accept PRs on supporting other upload services as well, so others can benefit. Hit the Edit this page in browser link at bottom of this page or the pencil icon at the top of the page.  Below is an example with the API that you need to supply to the createUploaderComponent() Quasar util. This will create a Vue component that you can import in your app.  TIPS * For the default XHR implementation in the form of such a plugin, check out source code. * For the UMD version use Quasar.createUploaderComponent({ ... }).  Then you register this component globally with Vue or you import it and add it to the \"components: {}\" in your Vue components.",
    "anchor": "Supporting-other-services",
    "url": "/vue-components/uploader"
  },
  {
    "objectID": 1218,
    "hierarchy_lvl0": "Video",
    "hierarchy_lvl1": "Video",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QVideo Vue components makes embedding a video like Youtube easy. It also resizes to fit the container by default.",
    "anchor": "Introduction",
    "url": "/vue-components/video"
  },
  {
    "objectID": 1219,
    "hierarchy_lvl0": "Video",
    "hierarchy_lvl1": "Video",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You may also want to check our own HTML 5 video player component: QMediaPlayer, which is far more advanced than QVideo (which essentially is an iframe pointing to embedded Youtube videos).",
    "anchor": "Introduction",
    "url": "/vue-components/video"
  },
  {
    "objectID": 1220,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The QVirtualScroll component renders a big list of items as the user scrolls in the container, keeping DOM tree clean and eating the lowest amount of memory possible.",
    "anchor": "Introduction",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1221,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are currently two types of QVirtualScroll: \"list\" (using QItems) and \"table\" (using a tabular style to display rows of data).",
    "anchor": "Introduction",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1222,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "* (Composition API) To get the best performance while using large lists, do not wrap the array that you are passing in the items prop with ref()/computed()/reactive()/etc. This allows Vue to skip making the list \"responsive\" to changes. * (Options API) To get the best performance while using large lists, freeze the array that you are passing in the items prop using Object.freeze(items). This allows Vue to skip making the list \"responsive\" to changes. * The number of items that will be rendered will be calculated based on the virtual-scroll-item-size prop and the size of the scrollable area, but you can fit it to your needs using the virtual-scroll-slice-size prop. * Use the virtual-scroll-item-size to specify the size of elements (pixels of height, or width if horizontal). After an element is rendered on screen its size is updated automatically, but if you specify an element size close to the real size you'll get a better initial indication of the scroll position. Regardless if you will be using this property or not, QVirtualScroll will still work, but without it you may experience the scrollbar not following the mouse grab position while continuously scrolling (on desktop) or the actual scroll of the container getting slightly off by one or two elements when on mobile and continuously scrolling.   There is a maximum height of the scrolling container, imposed by each browser. In IE11 this is around 1,000,000px, while in the rest of the browsers it's much more, but still limited.  Scroll the examples below to see QVirtualScroll in action.",
    "anchor": "Usage",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1223,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice the type=\"table\" property. With header that scrolls along with content (doesn't stay in place). Notice (in the example below) the CSS required to make the table header and footer \"sticky\". Also note the additional scoped slots which define the header and footer content. A more involved example below, playing with sticky headers and footers.",
    "anchor": "Basic",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1224,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Scroll target",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you need to specify the scroll target (because the auto detected one is not the desired one) pass a CSS selector (as string) or the DOM element to the scroll-target prop. If you need to use the virtual list with the whole page as the scrolling element then please set scroll-target=\"body\".  * If you pass a custom scroll target container with scroll-target prop you must make sure that the element exists and that it can be overflowed (it must have a maximum height and an overflow that allows scrolling). * If the scroll target container cannot be overflowed you'll get the whole list rendered.   If you want to use a Vue reference for scroll-target, please take care to set it after mounting the component, like in the example below.",
    "anchor": "Scroll-target",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1225,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Scroll to position",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also generate the items to be displayed on the list by using the items-fn prop.  Make sure to use a synchronous function that returns the list of items to be displayed.  If you need async data use a component that retrieves and renders the data.",
    "anchor": "Scroll-to-position",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1226,
    "hierarchy_lvl0": "Virtual Scroll",
    "hierarchy_lvl1": "Virtual Scroll",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Utility classes",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are two CSS classes that you can use (should you need to) to control VirtualScroll size calculation: * Use q-virtual-scroll--with-prev class on an element rendered by the VirtualScroll to indicate the element should be grouped with the previous one (main use case is for multiple table rows generated from the same row of data). * Use q-virtual-scroll--skip class on an element rendered by the VirtualScroll to indicate the element size should be ignored in size calculations.",
    "anchor": "Utility-classes",
    "url": "/vue-components/virtual-scroll"
  },
  {
    "objectID": 1227,
    "hierarchy_lvl0": "Close Popup",
    "hierarchy_lvl1": "Close Popup Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Helper Vue directive when working with QDialog or QMenu.",
    "anchor": "Introduction",
    "url": "/vue-directives/close-popup"
  },
  {
    "objectID": 1228,
    "hierarchy_lvl0": "Close Popup",
    "hierarchy_lvl1": "Close Popup Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also close multiple levels of popups by supplying a level number to the directive: If value is 0 or boolean false then directive is disabled If value is < 0 then it closes all popups in the chain If value is 1 or boolean true or undefined then it closes only the parent popup If value is > 1 it closes the specified number of parent popups in the chain (note that chained QMenus are considered 1 popup only & QPopupProxy separates chained menus) Notice below that chained QMenus (one directly put under the other) do not require you to specify multiple levels. When v-close-popup is used in a chained QMenu, it considers all directly chained QMenus as one level only. In the example below, the menu uses 2 levels, which means it will also close the dialog, since the dialog is its parent: Notice below that the inner dialog is a child of the main dialog. This is the only way for which v-close-popup will be able to close both dialogs while using multiple levels. Otherwise, if dialogs are siblings (or any other similar scenario where one dialog is not child of the other), you will have to use v-models on dialogs and handle closing of both dialogs yourself.",
    "anchor": "Introduction",
    "url": "/vue-directives/close-popup"
  },
  {
    "objectID": 1229,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive that uses Intersection Observer API to call a method when user scrolls and brings a component into or out of view.",
    "anchor": "Introduction",
    "url": "/vue-directives/intersection"
  },
  {
    "objectID": 1230,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Under the covers, it uses the Intersection Observer API.  Not all browsers support the Intersection Observer API. Most modern browsers do, but other browsers do not. If you need to support older browsers, you can install and import (into a boot file) the official W3C polyfill.",
    "anchor": "Introduction",
    "url": "/vue-directives/intersection"
  },
  {
    "objectID": 1231,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Reading the Intersection Observer API first will be best in your understanding of how this directive works. Intersection directive takes either a handler function as an argument or an Object. The Object form looks like this: When using the Object form, only the handler key is mandatory. The handler Function takes one parameter, which is an IntersectionObserverEntry.  Scroll within the examples below until the observed element is in view. Then scroll it out of view.",
    "anchor": "Usage",
    "url": "/vue-directives/intersection"
  },
  {
    "objectID": 1232,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The directive can be used with the once modifier (ex: v-intersection.once). Once the observed element comes into view, the handler Function will be called and the observing will stop. This allows you to control the processing overhead if all you need is to be notified when the observed element starts to be visible on screen.",
    "anchor": "Basic",
    "url": "/vue-directives/intersection"
  },
  {
    "objectID": 1233,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Using an Object",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By passing in an Object as the directive's value (instead of a Function), you can control all the options (like threshold) of the Intersection Observer.",
    "anchor": "Using-an-Object",
    "url": "/vue-directives/intersection"
  },
  {
    "objectID": 1234,
    "hierarchy_lvl0": "Intersection",
    "hierarchy_lvl1": "Intersection Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Advanced",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is a more advanced example of what you can do. The code takes advantage of the HTML data attribute. Basically, by setting data-id with the index of the element in a loop, this can be retrieved via the passed in entry to the handler as entry.target.dataset.id. If you are unfamiliar with the data attribute you can read more here about using the data attribute. In the example below, we show multiple cards, but only the visible ones get rendered. The secret is in the wrapper which has v-intersection attached to it and a fixed height and width (which acts as a necessary filler when the inner content is not rendered -- so that scrolling won't erratically jump). The example below can also be written by using QIntersection component which makes everything even more easy.  In the example above we used a Quasar transition. For a full list, please head to Transitions page.",
    "anchor": "Advanced",
    "url": "/vue-directives/intersection"
  },
  {
    "objectID": 1235,
    "hierarchy_lvl0": "Material Ripples",
    "hierarchy_lvl1": "Material Ripples",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive for easily adding material ripples to your components and DOM elements.",
    "anchor": "Introduction",
    "url": "/vue-directives/material-ripple"
  },
  {
    "objectID": 1236,
    "hierarchy_lvl0": "Material Ripples",
    "hierarchy_lvl1": "Material Ripples",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Make sure that your DOM element or component has CSS position: relative or Quasar CSS helper class relative-position attached to it.",
    "anchor": "Introduction",
    "url": "/vue-directives/material-ripple"
  },
  {
    "objectID": 1237,
    "hierarchy_lvl0": "Material Ripples",
    "hierarchy_lvl1": "Material Ripples",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Basic",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Material Ripple takes the CSS color of text by default, but you can configure it:",
    "anchor": "Basic",
    "url": "/vue-directives/material-ripple"
  },
  {
    "objectID": 1238,
    "hierarchy_lvl0": "Material Ripples",
    "hierarchy_lvl1": "Material Ripples",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Positioning",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also configure if the ripple should always start from center or not, regardless of the touch point:",
    "anchor": "Positioning",
    "url": "/vue-directives/material-ripple"
  },
  {
    "objectID": 1239,
    "hierarchy_lvl0": "Material Ripples",
    "hierarchy_lvl1": "Material Ripples",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Triggering early",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By default, the Ripple directive is triggered on click or keyup. However, you can change that and make it trigger earlier, on the first user interaction (mousedown, touchstart, keydown). Please note that in most situations the event sets may overlap (small delay between first and last user interaction) and there is no difference in the user perception, but in certain conditions it may lead to misleading the user. This is especially noticeable on touchscreens where if a user accidentally moves their finger after the touchstart it can sometimes be interpreted as a very small scroll event instead of a click so the click event isn't triggered but there is still a ripple.",
    "anchor": "Triggering-early",
    "url": "/vue-directives/material-ripple"
  },
  {
    "objectID": 1240,
    "hierarchy_lvl0": "Material Ripples",
    "hierarchy_lvl1": "Material Ripples",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Disable",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If for some reason you have a scenario where the ripples need to be disabled, then you can assign a Boolean as value for the directive:",
    "anchor": "Disable",
    "url": "/vue-directives/material-ripple"
  },
  {
    "objectID": 1241,
    "hierarchy_lvl0": "Mutation",
    "hierarchy_lvl1": "Mutation Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive that uses Mutation Observer API to watch for changes being made to the DOM tree.",
    "anchor": "Introduction",
    "url": "/vue-directives/mutation"
  },
  {
    "objectID": 1242,
    "hierarchy_lvl0": "Mutation",
    "hierarchy_lvl1": "Mutation Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Under the covers, it uses the Mutation Observer API.",
    "anchor": "Introduction",
    "url": "/vue-directives/mutation"
  },
  {
    "objectID": 1243,
    "hierarchy_lvl0": "Mutation",
    "hierarchy_lvl1": "Mutation Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Reading the Mutation Observer API first will be best in your understanding of how this directive works. The handler Function takes one parameter, which is an Array of MutationRecord.",
    "anchor": "Usage",
    "url": "/vue-directives/mutation"
  },
  {
    "objectID": 1244,
    "hierarchy_lvl0": "Mutation",
    "hierarchy_lvl1": "Mutation Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Catch everything",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "By not specifying any modifiers (except for \"once\"), the Mutation directive will enable all of them.",
    "anchor": "Catch-everything",
    "url": "/vue-directives/mutation"
  },
  {
    "objectID": 1245,
    "hierarchy_lvl0": "Mutation",
    "hierarchy_lvl1": "Mutation Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Drag and drop example",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The example below will only work for desktops because of the Drag and drop browser API support. Drag the colored squares to the other location to see the Mutation Observers results.",
    "anchor": "Drag-and-drop-example",
    "url": "/vue-directives/mutation"
  },
  {
    "objectID": 1246,
    "hierarchy_lvl0": "Mutation",
    "hierarchy_lvl1": "Mutation Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Undo-redo example",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "One use-case for the Mutation Observer is implementing an Undo/Redo stack in your application. You can observe additions and removals of data, depending on your filtering requirements. You can capture the mutations in a stack and use the stack to implement an undo. Any mutation data during an undo, can go into a redo stack. Don't forget to clear the redo stack when normalized data is being put into the undo stack.",
    "anchor": "Undo-redo-example",
    "url": "/vue-directives/mutation"
  },
  {
    "objectID": 1247,
    "hierarchy_lvl0": "Morph",
    "hierarchy_lvl1": "Morph Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive that morphs between DOM elements or even between the two states of the same DOM element.",
    "anchor": "Introduction",
    "url": "/vue-directives/morph"
  },
  {
    "objectID": 1248,
    "hierarchy_lvl0": "Morph",
    "hierarchy_lvl1": "Morph Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Under the covers, it uses the Quasar Morph function util.",
    "anchor": "Introduction",
    "url": "/vue-directives/morph"
  },
  {
    "objectID": 1249,
    "hierarchy_lvl0": "Morph",
    "hierarchy_lvl1": "Morph Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Reading the Morph function util first will be best in your understanding of how this directive works. This directive morphs one element in a group into another. The morphing is activated by changing the value (model) of the directive to match the name of the morphing element. warning * The \"name\" and \"group\" (as directive arg or through the value of the directive) are mandatory. * If the value of the directive is in Object form, then \"model\" is also mandatory.",
    "anchor": "Usage",
    "url": "/vue-directives/morph"
  },
  {
    "objectID": 1250,
    "hierarchy_lvl0": "Scroll",
    "hierarchy_lvl1": "Directive v-scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive which triggers an event when user scrolls.",
    "anchor": "Introduction",
    "url": "/vue-directives/scroll"
  },
  {
    "objectID": 1251,
    "hierarchy_lvl0": "Scroll",
    "hierarchy_lvl1": "Directive v-scroll",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "TIPS * One alternative to using this directive is to place a QScrollObserver component on your page. * There is one more scrolling-related directive available called Scroll Fire.",
    "anchor": "Introduction",
    "url": "/vue-directives/scroll"
  },
  {
    "objectID": 1252,
    "hierarchy_lvl0": "Scroll",
    "hierarchy_lvl1": "Directive v-scroll",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Usage",
    "url": "/vue-directives/scroll"
  },
  {
    "objectID": 1253,
    "hierarchy_lvl0": "Scroll Fire",
    "hierarchy_lvl1": "Scroll Fire Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive that triggers an event when user scrolls and brings a component into view.",
    "anchor": "Introduction",
    "url": "/vue-directives/scroll-fire"
  },
  {
    "objectID": 1254,
    "hierarchy_lvl0": "Scroll Fire",
    "hierarchy_lvl1": "Scroll Fire Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There is also a Scroll directive which fires whenever user scrolls the page.",
    "anchor": "Introduction",
    "url": "/vue-directives/scroll-fire"
  },
  {
    "objectID": 1255,
    "hierarchy_lvl0": "Scroll Fire",
    "hierarchy_lvl1": "Scroll Fire Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "IMPORTANT For performance purposes, the scroll listener function injected is by default debounced by 50ms.",
    "anchor": "Usage",
    "url": "/vue-directives/scroll-fire"
  },
  {
    "objectID": 1256,
    "hierarchy_lvl0": "Touch Hold",
    "hierarchy_lvl1": "Touch Hold Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive which triggers an event when the user touches and holds on a component or element for a specified amount of time.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-hold"
  },
  {
    "objectID": 1257,
    "hierarchy_lvl0": "Touch Hold",
    "hierarchy_lvl1": "Touch Hold Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We will be describing v-touch-hold directive on the lines below.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-hold"
  },
  {
    "objectID": 1258,
    "hierarchy_lvl0": "Touch Hold",
    "hierarchy_lvl1": "Touch Hold Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The default wait time is 600ms, but you can change it:  TouchHold also has a default sensitivity of 5px for touch events and 7px for mouse events, which means that it allows a slight movement of the finger or mouse without aborting, improving the user experience.  However, you can change this sensitivity too (notice the directive argument below - 600:12:15 - 600ms wait time, 12px sensitivity for touch events, 15px sensitivity for mouse events):",
    "anchor": "Usage",
    "url": "/vue-directives/touch-hold"
  },
  {
    "objectID": 1259,
    "hierarchy_lvl0": "Touch Hold",
    "hierarchy_lvl1": "Touch Hold Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling Mouse Events",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-Mouse-Events",
    "url": "/vue-directives/touch-hold"
  },
  {
    "objectID": 1260,
    "hierarchy_lvl0": "Touch Hold",
    "hierarchy_lvl1": "Touch Hold Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Inhibiting TouchHold",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, if you are using capture or mouseCapture modifiers then events will first reach the TouchHold directive then the inner content, so TouchHold will still trigger.",
    "anchor": "Inhibiting-TouchHold",
    "url": "/vue-directives/touch-hold"
  },
  {
    "objectID": 1261,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive which triggers an event when the user drags the finger or mouse on a component or element.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1262,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We will be describing v-touch-pan on the lines below.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1263,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If your content also has images, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.  Panning works both with a mouse or a native touch action. You can also capture pan to certain directions (any) only as you'll see below. Example on capturing only horizontal panning. Notice that on touch capable devices the scrolling is automatically not blocked, since we are only capturing horizontally. Example on capturing only vertically panning. Page scrolling is prevented, but you can opt out if you wish. Example on capturing panning on custom directions. For this, use modifiers: up, down, left, right. Page scrolling is prevented, but you can opt out if you wish.",
    "anchor": "Usage",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1264,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling Mouse Events",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-Mouse-Events",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1265,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Preventing Scroll (on touch capable devices)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Preventing-Scroll-(on-touch-capable-devices)",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1266,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Inhibiting TouchPan",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, if you are using capture or mouseCapture modifiers then events will first reach the TouchPan directive then the inner content, so TouchPan will still trigger.",
    "anchor": "Inhibiting-TouchPan",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1267,
    "hierarchy_lvl0": "Touch Pan",
    "hierarchy_lvl1": "Touch Pan Directive",
    "hierarchy_lvl2": "Example with FAB",
    "hierarchy_lvl3": "Inhibiting TouchPan",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Below is a nice example on using TouchPan on a QFab. You can drag it across the screen.",
    "anchor": "Example-with-FAB",
    "url": "/vue-directives/touch-pan"
  },
  {
    "objectID": 1268,
    "hierarchy_lvl0": "Touch Repeat",
    "hierarchy_lvl1": "Touch Repeat Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive which triggers an event at specified intervals of time while the user touches and holds on a component or element.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-repeat"
  },
  {
    "objectID": 1269,
    "hierarchy_lvl0": "Touch Repeat",
    "hierarchy_lvl1": "Touch Repeat Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We will be describing v-touch-repeat on the lines below.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-repeat"
  },
  {
    "objectID": 1270,
    "hierarchy_lvl0": "Touch Repeat",
    "hierarchy_lvl1": "Touch Repeat Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The default repeat pattern is 0:600:300 (ms). Below is an example configured to also react to SPACE, ENTER and h keys (focus on it first), with 0:300:200 (ms) repeat pattern. Hit & hold keys, or click/tap and hold. Below is an example of applying TouchRepeat to QBtn. Notice how we play with the directive arguments in order to make the blue buttons increment slower than the red ones.",
    "anchor": "Usage",
    "url": "/vue-directives/touch-repeat"
  },
  {
    "objectID": 1271,
    "hierarchy_lvl0": "Touch Repeat",
    "hierarchy_lvl1": "Touch Repeat Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling Mouse Events",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-Mouse-Events",
    "url": "/vue-directives/touch-repeat"
  },
  {
    "objectID": 1272,
    "hierarchy_lvl0": "Touch Repeat",
    "hierarchy_lvl1": "Touch Repeat Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling Key Events",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are some special modifiers that you do not require to write the equivalent keycode: space, tab, enter.",
    "anchor": "Handling-Key-Events",
    "url": "/vue-directives/touch-repeat"
  },
  {
    "objectID": 1273,
    "hierarchy_lvl0": "Touch Repeat",
    "hierarchy_lvl1": "Touch Repeat Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Inhibiting TouchRepeat",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, if you are using capture, mouseCapture or keyCapture modifiers then events will first reach the TouchRepeat directive then the inner content, so TouchRepeat will still trigger.",
    "anchor": "Inhibiting-TouchRepeat",
    "url": "/vue-directives/touch-repeat"
  },
  {
    "objectID": 1274,
    "hierarchy_lvl0": "Touch Swipe",
    "hierarchy_lvl1": "Touch Swipe Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Vue directive which triggers an event when the user swipes with the finger or mouse on a component or element.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-swipe"
  },
  {
    "objectID": 1275,
    "hierarchy_lvl0": "Touch Swipe",
    "hierarchy_lvl1": "Touch Swipe Directive",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We will be describing v-touch-swipe on the lines below.",
    "anchor": "Introduction",
    "url": "/vue-directives/touch-swipe"
  },
  {
    "objectID": 1276,
    "hierarchy_lvl0": "Touch Swipe",
    "hierarchy_lvl1": "Touch Swipe Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If your content also has images, you might want to add draggable=\"false\" to them, otherwise the native browser behavior might interfere in a negative way.",
    "anchor": "Usage",
    "url": "/vue-directives/touch-swipe"
  },
  {
    "objectID": 1277,
    "hierarchy_lvl0": "Touch Swipe",
    "hierarchy_lvl1": "Touch Swipe Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Handling Mouse Events",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-Mouse-Events",
    "url": "/vue-directives/touch-swipe"
  },
  {
    "objectID": 1278,
    "hierarchy_lvl0": "Touch Swipe",
    "hierarchy_lvl1": "Touch Swipe Directive",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Inhibiting TouchSwipe",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "However, if you are using capture or mouseCapture modifiers then events will first reach the TouchHold directive then the inner content, so TouchSwipe will still trigger.",
    "anchor": "Inhibiting-TouchSwipe",
    "url": "/vue-directives/touch-swipe"
  },
  {
    "objectID": 1279,
    "hierarchy_lvl0": "Addressbar Color",
    "hierarchy_lvl1": "AddressbarColor Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin for changing the addressbar color on newer mobile browsers.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/addressbar-color"
  },
  {
    "objectID": 1280,
    "hierarchy_lvl0": "Addressbar Color",
    "hierarchy_lvl1": "AddressbarColor Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/quasar-plugins/addressbar-color"
  },
  {
    "objectID": 1281,
    "hierarchy_lvl0": "Addressbar Color",
    "hierarchy_lvl1": "AddressbarColor Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We create boot file to initialize its usage: $ quasar new boot addressbar-color. A file is created (/src/boot/addressbar-color.js). We edit it: We then have to tell quasar to use this boot file we just created. To do this we edit the boot section of the quasar config: js // file: /quasar.conf.js return { boot: [ 'addressbar-color' ] } What this does is that it injects some <meta> tags into your index.html at runtime. Because the meta tag doesn't get injected until run time you can dynamically change this color multiple times, based on the page the user is on (by calling the set method in the created() lifecycle hook on the respective pages):  Calling set() with no parameters will use the primary color.",
    "anchor": "Installation",
    "url": "/quasar-plugins/addressbar-color"
  },
  {
    "objectID": 1282,
    "hierarchy_lvl0": "App Fullscreen",
    "hierarchy_lvl1": "Fullscreen Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin to toggle the fullscreen state of your app through the Web Fullscreen API.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/app-fullscreen"
  },
  {
    "objectID": 1283,
    "hierarchy_lvl0": "App Fullscreen",
    "hierarchy_lvl1": "Fullscreen Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On some phones this will have little effect: * For example, on Samsung S4, when App goes into fullscreen, the top bar will slide up but still remain on screen. * On Nexus phones, on the other hand, like Nexus 5, Android navigation buttons and top bar disappear completely. It all depends on the Web Fullscreen API support of the platform the code is running on.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/app-fullscreen"
  },
  {
    "objectID": 1284,
    "hierarchy_lvl0": "App Fullscreen",
    "hierarchy_lvl1": "Fullscreen Plugin",
    "hierarchy_lvl2": "Watching for fullscreen changes",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Watching-for-fullscreen-changes",
    "url": "/quasar-plugins/app-fullscreen"
  },
  {
    "objectID": 1285,
    "hierarchy_lvl0": "App Visibility",
    "hierarchy_lvl1": "App Visibility",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin that wraps the Page Visibility API, letting you know when your app is visible or in focus.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/app-visibility"
  },
  {
    "objectID": 1286,
    "hierarchy_lvl0": "App Visibility",
    "hierarchy_lvl1": "App Visibility",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// inside of a Vue file import { useQuasar } from 'quasar' setup () { const $q = useQuasar() // now use $q.appVisible (Boolean) } ```",
    "anchor": "Introduction",
    "url": "/quasar-plugins/app-visibility"
  },
  {
    "objectID": 1287,
    "hierarchy_lvl0": "App Visibility",
    "hierarchy_lvl1": "App Visibility",
    "hierarchy_lvl2": "Watching for status change",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Watching-for-status-change",
    "url": "/quasar-plugins/app-visibility"
  },
  {
    "objectID": 1288,
    "hierarchy_lvl0": "Bottom Sheet",
    "hierarchy_lvl1": "Bottom Sheet Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin for displaying a list of user actions that slides up from the bottom edge of the app window.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/bottom-sheet"
  },
  {
    "objectID": 1289,
    "hierarchy_lvl0": "Bottom Sheet",
    "hierarchy_lvl1": "Bottom Sheet Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The Bottom Sheet always appears above any other components on the page, and must be dismissed in order to interact with the underlying content. When it is triggered, the rest of the page darkens to give more focus to the Bottom Sheet options. Bottom Sheets can be displayed as a list or as a grid, with icons or with avatars. They can be used either as a component in your Vue file templates, or as a globally available method.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/bottom-sheet"
  },
  {
    "objectID": 1290,
    "hierarchy_lvl0": "Bottom Sheet",
    "hierarchy_lvl1": "Bottom Sheet Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When user hits the phone/tablet back button (only for Cordova apps), the Action Sheet will get closed automatically. Also, when on a desktop browser, hitting the ESCAPE key also closes the Action Sheet.   For an exhaustive list of options, please check API section.",
    "anchor": "Installation",
    "url": "/quasar-plugins/bottom-sheet"
  },
  {
    "objectID": 1291,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin which manages browser cookies over the standardized 'document.cookie', making it easy to read and write cookies even with SSR apps.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1292,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The ssrContext is available in boot files or preFetch feature where it is supplied as parameter. The reason for this is that in a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same: each request should have a fresh, isolated app instance so that there is no cross-request state pollution. So Cookies needs to be bound to each request separately.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1293,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Read a Cookie",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When cookie is not set, the return value is null.",
    "anchor": "Read-a-Cookie",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1294,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Read All Cookies",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "cookies variable will be an object with key-value pairs (cookie_name : cookie_value).",
    "anchor": "Read-All-Cookies",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1295,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Verify if Cookie is Set",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Verify-if-Cookie-is-Set",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1296,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The (optional) options parameter is an Object which is explained below, property by property.",
    "anchor": "Write-a-Cookie",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1297,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: expires",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Define lifetime of the cookie. Value can be a Number which will be interpreted as days from time of creation or a Date object or a raw stringified Date (\"Mon, 06 Jan 2020 12:52:55 GMT\") or a special string format (\"1d\", \"15m\", \"13d\", \"1d 15m\", \"1d 3h 5m 3s\"). If omitted, the cookie becomes a session cookie.",
    "anchor": "Option%3A-expires",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1298,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: path",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Define the path where the cookie is valid. By default the path of the cookie is the path of the page where the cookie was created (standard browser behavior). If you want to make it available for instance across the entire domain use path: '/'. Default: path of page where the cookie was created.",
    "anchor": "Option%3A-path",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1299,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: domain",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Define the domain where the cookie is valid. Default: domain of page where the cookie was created.",
    "anchor": "Option%3A-domain",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1300,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: sameSite",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "SameSite cookies let servers require that a cookie shouldn't be sent with cross-site (where Site is defined by the registrable domain) requests, which provides some protection against cross-site request forgery attacks (CSRF). Strict - If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the Strict attribute will be included. Lax - If the attribute is set to Lax, same-site cookies are withheld on cross-site subrequests, such as calls to load images or frames, but will be sent when a user navigates to the URL from an external site, for example, by following a link. For more information on the same-site setting, go here.",
    "anchor": "Option%3A-sameSite",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1301,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: httpOnly",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To help mitigate cross-site scripting (XSS) attacks, HttpOnly cookies are inaccessible to JavaScript's Document.cookie API; they are only sent to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and the HttpOnly flag should be set.",
    "anchor": "Option%3A-httpOnly",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1302,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: secure",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If true, the cookie transmission requires a secure protocol (HTTPS) and will NOT be sent over HTTP. Default value is false.  If using Quasar CLI and on dev mode, you can enable HTTPS through quasar.conf.js > devServer > https: true.",
    "anchor": "Option%3A-secure",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1303,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Write a Cookie",
    "hierarchy_lvl3": "Option: other",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Raw string for other cookie options. To be used as a last resort for possible newer props that are currently not yet implemented in Quasar.",
    "anchor": "Option%3A-other",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1304,
    "hierarchy_lvl0": "Cookies",
    "hierarchy_lvl1": "Cookies",
    "hierarchy_lvl2": "Remove a Cookie",
    "hierarchy_lvl3": "Option: other",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Cookies.remove('cookie_name') // if cookie was set with specific options like path and/or domain // then you need to also supply them when removing: Cookies.remove('cookie_name', options) ```  When a cookie was previously set with specific path and/or domain then it can be successfully removed only if the same attributes are passed in to remove() through the options parameter. This is in accordance to RFC6265.",
    "anchor": "Remove-a-Cookie",
    "url": "/quasar-plugins/cookies"
  },
  {
    "objectID": 1305,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin to toggle or configure the Dark Mode state of your app.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1306,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Do not manually assign a value to isActive or mode from below. Instead, use the set(val) method.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1307,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Inside of a Vue file",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "On a SSR build, you may want to set this from your /src/App.vue:",
    "anchor": "Inside-of-a-Vue-file",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1308,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Outside of a Vue file",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Outside-of-a-Vue-file",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1309,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Through quasar.conf.js",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also use /quasar.conf.js to set the Dark mode status:",
    "anchor": "Through-quasar.conf.js",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1310,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": "Note about SSR",
    "hierarchy_lvl3": "Through quasar.conf.js",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When on a SSR build: * import { Dark } from 'quasar' method of using Dark mode will not error out but it will not work (won't do anything). But you can use the other two ways (see previous section). We recommend through quasar.conf.js. * It's preferred to avoid setting Dark mode to 'auto' for SSR builds. It's because the client dark mode preference cannot be inferred, so SSR will always render in light mode then when the client takes over, it will switch to Dark (if it will be the case). As a result, a quick flicker of the screen will occur.",
    "anchor": "Note-about-SSR",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1311,
    "hierarchy_lvl0": "Dark",
    "hierarchy_lvl1": "Dark Plugin",
    "hierarchy_lvl2": "Watching for status change",
    "hierarchy_lvl3": "Through quasar.conf.js",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Watching-for-status-change",
    "url": "/quasar-plugins/dark"
  },
  {
    "objectID": 1312,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin that provides an easy way to display a prompt, choice, confirmation or alert in the form of a dialog.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1313,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "From a UI perspective, you can think of Dialogs as a type of floating modal, which covers only a portion of the screen. This means Dialogs should only be used for quick user actions only.  Dialogs can also be used as a component in your Vue file templates (for complex use-cases, like specific form components, selectable options, etc.). For this, go to QDialog page.  The advantage of using Dialogs as Quasar Plugins as opposed to QDialog component is that the plugin can also be called from outside of Vue space and doesn't require you to manage their templates. But as a result, their customization cannot be compared to their component counterpart. However, you can also supply a component for the Dialog Plugin to render (see the \"Invoking custom component\" section) which is a great way to avoid cluttering your Vue templates with inline dialogs (and it will also help you better organize your project files and also reuse dialogs). With the QDialog plugin, you can programmatically build three types of dialogs with the following form content: 1. A prompt dialog - asking the user to fill in some sort of data in an input field. 2. A set of options for the user to select from using either radio buttons or toggles (singular selection only) or check boxes (for multiple selections). 3. A simple confirmation dialog, where the user can cancel or give her \"ok\" for a particular action or input. In order to create #1, the prompting input form, you have the prompt property within the opts object. In order to create #2, the options selection form, you have the options property within the opts object.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1314,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Please check the API card to see what the returned Object is.",
    "anchor": "Installation",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1315,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": "Predefined",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For all the examples below, also see the browser console while you check them out.   This is not an exhaustive list of what you can do with Dialogs as Quasar Plugins. For further exploration check out the API section.",
    "anchor": "Predefined",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1316,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": "Basic validation",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There is a basic validation system that you can use so that the user won't be able to submit the dialog (click/tap on \"OK\" or press <kbd>ENTER</kbd>) until the expected values are filled in.",
    "anchor": "Basic-validation",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1317,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": "Progress",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can also invoke your own custom component rather than relying on the default one that the Dialog plugin comes with out of the box. But in this case you will be responsible for handling everything (including your own component props). This feature is actually the \"bread and butter\" of the Dialog plugin. It helps you keep your other vue components html templates clean by separating and reusing your dialog's functionality with ease. The equivalent of the above with Options API is by directly using this.$q.dialog({ ... }).  Your custom component however must follow the interface described below in order to perfectly hook into the Dialog plugin. Notice the \"REQUIRED\" comments and take it as is -- just a bare-bone example, nothing more.",
    "anchor": "Progress",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1318,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": "Progress",
    "hierarchy_lvl4": "Composition API variant",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We will be using the useDialogPluginComponent composable.",
    "anchor": "Composition-API-variant",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1319,
    "hierarchy_lvl0": "Dialog",
    "hierarchy_lvl1": "Dialog Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": "Progress",
    "hierarchy_lvl4": "Options API variant",
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Options-API-variant",
    "url": "/quasar-plugins/dialog"
  },
  {
    "objectID": 1320,
    "hierarchy_lvl0": "Loading",
    "hierarchy_lvl1": "Loading Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin which can display a loading state for your app through an overlay with a spinner and a message.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/loading"
  },
  {
    "objectID": 1321,
    "hierarchy_lvl0": "Loading",
    "hierarchy_lvl1": "Loading Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Inside a Vue component: Outside of a Vue component:",
    "anchor": "Introduction",
    "url": "/quasar-plugins/loading"
  },
  {
    "objectID": 1322,
    "hierarchy_lvl0": "Loading Bar",
    "hierarchy_lvl1": "LoadingBar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin that wraps the QAjaxBar component for the easiest way of showing such a loading indicator in an app.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/loading-bar"
  },
  {
    "objectID": 1323,
    "hierarchy_lvl0": "Loading Bar",
    "hierarchy_lvl1": "LoadingBar",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "LoadingBar options are same as when configuring a QAjaxBar.  When using the UMD version of Quasar, all components, directives and plugins are installed by default. This includes LoadingBar. Should you wish to disable it, specify loadingBar: { skipHijack: true } (which turns off listening to Ajax traffic).",
    "anchor": "Introduction",
    "url": "/quasar-plugins/loading-bar"
  },
  {
    "objectID": 1324,
    "hierarchy_lvl0": "Loading Bar",
    "hierarchy_lvl1": "LoadingBar",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Inside Vue components: Outside of Vue components:",
    "anchor": "Usage",
    "url": "/quasar-plugins/loading-bar"
  },
  {
    "objectID": 1325,
    "hierarchy_lvl0": "Loading Bar",
    "hierarchy_lvl1": "LoadingBar",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": "Setting Up Defaults",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Should you wish to set up some defaults, rather than specifying them each time, you can do so by using quasar.conf.js > framework > config > loadingBar: {...} or by calling LoadingBar.setDefaults({...}) or $q.loadingBar.setDefaults({...}). Supports all QAjaxBar properties. Inside Vue components: Outside of Vue components:",
    "anchor": "Setting-Up-Defaults",
    "url": "/quasar-plugins/loading-bar"
  },
  {
    "objectID": 1326,
    "hierarchy_lvl0": "Local/Session Storage",
    "hierarchy_lvl1": "Local/Session Storage Plugins",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin that wraps the Local/Session Storage, retrieving data with its original JS type.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/web-storage"
  },
  {
    "objectID": 1327,
    "hierarchy_lvl0": "Local/Session Storage",
    "hierarchy_lvl1": "Local/Session Storage Plugins",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Web Storage API only retrieves strings. Quasar retrieves data with its original data type. You tell it to store a Number then to retrieve it and it will still be a Number, not a string representation of the number as with Web Storage API. Same for JSON, Regular Expressions, Dates, Booleans and so on.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/web-storage"
  },
  {
    "objectID": 1328,
    "hierarchy_lvl0": "Local/Session Storage",
    "hierarchy_lvl1": "Local/Session Storage Plugins",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note about SSR When running the code server-side on SSR builds, this feature can't work. Web Storage is a browser API only. You can however make use of it on the client-side with SSR.",
    "anchor": "Installation",
    "url": "/quasar-plugins/web-storage"
  },
  {
    "objectID": 1329,
    "hierarchy_lvl0": "Local/Session Storage",
    "hierarchy_lvl1": "Local/Session Storage Plugins",
    "hierarchy_lvl2": "Usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For a bulletproof approach when setting a value, it's best to also catch any potential errors raised by the underlying Local/Session Storage Web API, like when exceeding quota:  For an exhaustive list of methods, please check the API section.",
    "anchor": "Usage",
    "url": "/quasar-plugins/web-storage"
  },
  {
    "objectID": 1330,
    "hierarchy_lvl0": "Local/Session Storage",
    "hierarchy_lvl1": "Local/Session Storage Plugins",
    "hierarchy_lvl2": "Data Types",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Quasar Storage supports (but not limited to) the following data types out of the box. If you store one of these types, the retrieved data will have the same data type. Dates Regular Expressions Numbers Booleans Strings Plain Javascript Objects If you store any other data type, the returned value will be a String. So you can even store functions, but be careful that you need to eval() the returned value (which is a String representation of the function).",
    "anchor": "Data-Types",
    "url": "/quasar-plugins/web-storage"
  },
  {
    "objectID": 1331,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin to easily handle the meta tags of an app, helping you to add SEO. It manages meta, style and script tags, html and body attributes and page titles.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1332,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Take full advantage of this feature by using it with Quasar CLI, especially for the SSR (Server-Side Rendering) builds. It also makes sense to use it for SPA (Single Page Applications). Although the meta information in this case will be added at run-time and not supplied directly by the webserver (as on SSR builds), modern web-crawlers like the Googlebot will render dynamic pages and extract out the dynamically set meta information.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1333,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We will be using the useMeta composable.",
    "anchor": "Installation",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1334,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": "Installation",
    "hierarchy_lvl3": "Options API",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Options-API",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1335,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": "How It Works",
    "hierarchy_lvl3": "Options API",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When a component that uses Meta plugin gets rendered or destroyed, it is added/removed to/from the chain and metas are updated accordingly.",
    "anchor": "How-It-Works",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1336,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": "How It Works",
    "hierarchy_lvl3": "Non-reactive",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice that all properties (except for title and titleTemplate) are Objects; you can override meta props defined in previous Vue components in the chain by using the same keys again. Example:  Just make sure not to duplicate content that already exists in /src/index.template.html. If you want to use the Meta plugin, the recommended way is to remove the same tags from the html template. But on use-cases where you know a tag will never change and you always want it rendered, then it's better to have it only on the html template instead.",
    "anchor": "Non-reactive",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1337,
    "hierarchy_lvl0": "Meta",
    "hierarchy_lvl1": "Quasar Meta Plugin",
    "hierarchy_lvl2": "How It Works",
    "hierarchy_lvl3": "Reactive",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the section above, you noticed all of the meta props are \"static\". But they can be dynamic (reactive) instead, should you wish. This is how you can manage them just as with a Vue computed property:",
    "anchor": "Reactive",
    "url": "/quasar-plugins/meta"
  },
  {
    "objectID": 1338,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A Quasar plugin to display animated messages to users like notifications, toasts and snackbars.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1339,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you define any actions, the notification will automatically be dismissed when the user picks it.",
    "anchor": "Introduction",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1340,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "With caption",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For a full list of options, check the API section.",
    "anchor": "With-caption",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1341,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Grouping",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Each notification has an underlying unique group which is computed out of the message + caption + multiLine + actions labels + position. When multiple notifications get triggered with the same group, instead of showing all of them and flooding the view, only the first one remains on screen along with a badge. The badge content represents the number of times that the same notification has been triggered (and with same position) since the first one appeared on screen. However, if you wish to disable this behavior, specify group: false. In the example below, the first button triggers the same notification twice each time is clicked. The second button has grouping disabled. The third button, however, has a custom group name so each subsequent notification replaces the old one and increments the badge number.",
    "anchor": "Grouping",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1342,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Timeout progress",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Should you wish, there is a way to tell the user when the notification will disappear from the screen. That's for the cases when timeout is not set to 0.",
    "anchor": "Timeout-progress",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1343,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Updatable notifications",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Should you have an ongoing process and you want to inform the user of its progress without blocking what he is currently doing, then you can generate an updatable notification. It's useful to also show a spinner while at it. Please note in the example below that we are explicitly setting \"group: false\" (because only non-grouped notifications can be updated) and \"timeout: 0\" (because we want to be in full control when the notification will be dismissed).",
    "anchor": "Updatable-notifications",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1344,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Predefined types",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are four predefined types out of the box that you can use: \"positive\", \"negative\", \"warning\" and \"info\": Furthermore, you can register your own types or even override the predefined ones. The best place to do this would be in a boot file.",
    "anchor": "Predefined-types",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1345,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Using HTML",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Using-HTML",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1346,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Programmatically closing",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Programmatically-closing",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1347,
    "hierarchy_lvl0": "Notify",
    "hierarchy_lvl1": "Notify",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": "Setting defaults",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We'll describe setting the defaults through a boot file (works the same anywhere in your code, but a boot file ensures this is run before your app starts): First we create the boot file. Let's name it \"notify-defaults.js\". Add the created notify-defaults.js file to the boot array in quasar.conf.js: We then edit the newly created /src/boot/notify-defaults.js:  You can only set default actions through this method. Specifying actions with handlers in quasar.conf.js cannot and will NOT work.  We could also set the defaults in some Vue file:",
    "anchor": "Setting-defaults",
    "url": "/quasar-plugins/notify"
  },
  {
    "objectID": 1348,
    "hierarchy_lvl0": "useQuasar",
    "hierarchy_lvl1": "useQuasar composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What is useQuasar() composable and how you can use it",
    "anchor": "Introduction",
    "url": "/vue-composables/use-quasar"
  },
  {
    "objectID": 1349,
    "hierarchy_lvl0": "useQuasar",
    "hierarchy_lvl1": "useQuasar composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/vue-composables/use-quasar"
  },
  {
    "objectID": 1350,
    "hierarchy_lvl0": "useQuasar",
    "hierarchy_lvl1": "useQuasar composable",
    "hierarchy_lvl2": "Example",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Example",
    "url": "/vue-composables/use-quasar"
  },
  {
    "objectID": 1351,
    "hierarchy_lvl0": "useDialogPluginComponent",
    "hierarchy_lvl1": "useDialogPluginComponent composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What is Quasar's useDialogPluginComponent() composable and how you can use it",
    "anchor": "Introduction",
    "url": "/vue-composables/use-dialog-plugin-component"
  },
  {
    "objectID": 1352,
    "hierarchy_lvl0": "useDialogPluginComponent",
    "hierarchy_lvl1": "useDialogPluginComponent composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This composable is to be used on the custom components which a Dialog plugin is invoked with. It will bootstrap all the necessary communication of the component with the plugin.",
    "anchor": "Introduction",
    "url": "/vue-composables/use-dialog-plugin-component"
  },
  {
    "objectID": 1353,
    "hierarchy_lvl0": "useDialogPluginComponent",
    "hierarchy_lvl1": "useDialogPluginComponent composable",
    "hierarchy_lvl2": "Syntax",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Syntax",
    "url": "/vue-composables/use-dialog-plugin-component"
  },
  {
    "objectID": 1354,
    "hierarchy_lvl0": "useDialogPluginComponent",
    "hierarchy_lvl1": "useDialogPluginComponent composable",
    "hierarchy_lvl2": "Full example",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Full-example",
    "url": "/vue-composables/use-dialog-plugin-component"
  },
  {
    "objectID": 1355,
    "hierarchy_lvl0": "useFormChild",
    "hierarchy_lvl1": "useFormChild composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What is Quasar's useFormChild() composable and how you can use it",
    "anchor": "Introduction",
    "url": "/vue-composables/use-form-child"
  },
  {
    "objectID": 1356,
    "hierarchy_lvl0": "useFormChild",
    "hierarchy_lvl1": "useFormChild composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Introduction",
    "url": "/vue-composables/use-form-child"
  },
  {
    "objectID": 1357,
    "hierarchy_lvl0": "useMeta",
    "hierarchy_lvl1": "useMeta composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What is Quasar's useMeta() composable and how you can use it",
    "anchor": "Introduction",
    "url": "/vue-composables/use-meta"
  },
  {
    "objectID": 1358,
    "hierarchy_lvl0": "useMeta",
    "hierarchy_lvl1": "useMeta composable",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For static meta configuration (non-reactive): For dynamic meta configuration (reactive):",
    "anchor": "Introduction",
    "url": "/vue-composables/use-meta"
  },
  {
    "objectID": 1359,
    "hierarchy_lvl0": "useMeta",
    "hierarchy_lvl1": "useMeta composable",
    "hierarchy_lvl2": "Example",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Example",
    "url": "/vue-composables/use-meta"
  },
  {
    "objectID": 1360,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "What Quasar App Extensions are and how they can help both you and the community.",
    "anchor": "Introduction",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1361,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The patterns for development literally open the floodgates to making Quasar one of the most extensible and powerful frameworks out there - now limited only by your imagination and innovation. This page will introduce you to the usage of App Extensions.  App Extensions are designed specifically for Quasar CLI only. This means that you will not be able to install them or run them in Vue CLI or UMD environments.",
    "anchor": "Introduction",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1362,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "What can an App Extension do?",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Enhance CLI behavior with new commands Make a Quasar UI plug-in Install an accompanying application Create and share a custom component Create and share added features to the framework or other applications Build, launch and control an API server Hook, combine and extend Quasar core components Modify code based on dynamically changing values that sit outside of the Quasar environment Create and manage abstractions of platform specific interfaces ... and a whole lot more App Extensions replace the need to create custom starter kits. Anything you add on top of the official starter kit can come in the form of an App Extension. This also eliminates maintenance overhead of keeping unofficial starter kits up to date with the official one and so we can ensure that every developer will always get the latest and greatest Quasar specs out of the box.",
    "anchor": "What-can-an-App-Extension-do%3F",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1363,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "App Extension ext-id",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example: * ext-id for quasar-app-extension-awesomeness is awesomeness * ext-id for @some-npm-org/quasar-app-extension-awesomeness is @some-npm-org/awesomeness One of the benefits of this naming scheme is that it makes Quasar App Extensions discoverability easy while searching for their npm packages: App Extension - Discover.",
    "anchor": "App-Extension-ext-id",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1364,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "Anatomy of App Extensions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This command will find and install the extension's module. After installation is complete, there may be one or more prompts asking you to make choices or add information needed by the extension. When the installation is concluded, you will be returned to the command line.",
    "anchor": "Anatomy-of-App-Extensions",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1365,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "Anatomy of App Extensions",
    "hierarchy_lvl3": "List Installed App Extensions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "There are several ways to \"discover\" what App Extensions have been installed:",
    "anchor": "List-Installed-App-Extensions",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1366,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "Anatomy of App Extensions",
    "hierarchy_lvl3": "\"Running\" App Extensions",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Nevertheless, each and every App Extension will be initialized during quasar dev and quasar build.",
    "anchor": "%22Running%22-App-Extensions",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1367,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "Anatomy of App Extensions",
    "hierarchy_lvl3": "Updating an App Extension",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Reinstalling the extension MIGHT overwrite files that you have changed. You will be presented with the option to overwrite the files detected.",
    "anchor": "Updating-an-App-Extension",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1368,
    "hierarchy_lvl0": "Introduction",
    "hierarchy_lvl1": "App Extensions",
    "hierarchy_lvl2": "Anatomy of App Extensions",
    "hierarchy_lvl3": "Removing an App Extension",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Removing-an-App-Extension",
    "url": "/app-extensions/introduction"
  },
  {
    "objectID": 1369,
    "hierarchy_lvl0": "Discover App Extensions",
    "hierarchy_lvl1": "Discover App Extensions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Look up official and community Quasar App Extensions.",
    "anchor": "Introduction",
    "url": "/app-extensions/discover"
  },
  {
    "objectID": 1370,
    "hierarchy_lvl0": "Discover App Extensions",
    "hierarchy_lvl1": "Discover App Extensions",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Review submitted Community App Extensions. And please don't forget to submit your own! Learn what Quasar App Extensions are and how to create one.",
    "anchor": "Introduction",
    "url": "/app-extensions/discover"
  },
  {
    "objectID": 1371,
    "hierarchy_lvl0": "Discover App Extensions",
    "hierarchy_lvl1": "Discover App Extensions",
    "hierarchy_lvl2": "Official App Extensions",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Official-App-Extensions",
    "url": "/app-extensions/discover"
  },
  {
    "objectID": 1372,
    "hierarchy_lvl0": "Discover App Extensions",
    "hierarchy_lvl1": "Discover App Extensions",
    "hierarchy_lvl2": "Official App Extensions",
    "hierarchy_lvl3": "Project Rigging",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Project-Rigging",
    "url": "/app-extensions/discover"
  },
  {
    "objectID": 1373,
    "hierarchy_lvl0": "Discover App Extensions",
    "hierarchy_lvl1": "Discover App Extensions",
    "hierarchy_lvl2": "Official App Extensions",
    "hierarchy_lvl3": "Components",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Components",
    "url": "/app-extensions/discover"
  },
  {
    "objectID": 1374,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "App Extension Development",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "How to setup your machine for a Quasar App Extension development and getting started quickly.",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1375,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "App Extension Development",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It is assumed you have already installed one of the official App Extensions. Having this experience at your disposal is going to be very valuable when you start building your own App Extensions. If you run into problems, please visit our Discord server's channel #app-extensions.",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1376,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Getting started",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It will prompt you about your specific needs. Do you need an install script, an uninstall script, will you be prompting the user with some questions? Pick only what you will be using. You can manually add these later if you decide otherwise. For the sake of this documentation page, let's assume we answered with my-ext to the App Extension ext-id question (regarding the prompts above). Remember that the folder name for the App Extension source folder can be different from the actual ext-id. At the end, we will publish our new npm package (quasar-app-extension-my-ext). Based on your response, Quasar CLI will create a folder for your App Extension’s source code that will have the following structure: Except for src/index.js (from the app-extension kit) or app-extension/src/index.js (from the ui kit) , all the other files are optional. You can manually add or remove them at any point in time. When using the UI kit, you will have two npm packages; one for the App Extension and one for the UI module. For testing with the dev app, from the ui folder type yarn dev. Create pages in the dev folder for testing and they will automatically be injected into the test app. Also, check out the scripts section in the package.json to see what you have available. When you yarn build, a dist folder will be created and populated with various types of packages (common, esm, and umd).",
    "anchor": "Getting-started",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1377,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "App Extension Scripts description",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "App-Extension-Scripts-description",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1378,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Handling package dependencies",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If your App Extension has its own dependencies over some packages in order for it to be able to run (except for packages supplied by Quasar CLI, like \"quasar\", \"@quasar/extras\", \"@quasar/app\" -- you should use \"api.compatibleWith()\" for those in your /install.js and /index.js scripts -- check Install API and Index API), then yarn/npm installing them into your App Extension folder will supply them into the hosting app. Example: You are creating a UI component that depends on \"my-table\" npm package (name is bogus, just for making a point here), then you should yarn/npm install \"my-table\" in your App Extension folder.  Never yarn/npm install packages that are supplied by the Quasar CLI, because App Extensions should not be so intrusive and force the user to use a certain Quasar version. Instead, make use of \"api.compatibleWith()\" for those, which is equivalent to softly saying \"Sorry, you need to install this version of Quasar if you want to take advantage of my App Extension\".",
    "anchor": "Handling-package-dependencies",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1379,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Manually testing",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We need to create a Quasar project folder to be able to test it while we develop the extension:",
    "anchor": "Manually-testing",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1380,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Manually testing",
    "hierarchy_lvl3": "Install and prompts scripts",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Learn more about what you can do with the Prompts API and the Install API.  Inside the testing Quasar project folder, we manually add our App Extension. Notice that we are not specifying the npm package name (it's not published yet!) but a path to our App Extension folder where we develop it, since we want to test unpublished work: This will trigger the installation of our new App Extension. You need to redo these two steps each time you make changes and you want to test them. Additionally, if you would like to have HMR (hot module reload) capabilities in your test app while developing your App Extension, then your quasar.conf.js > devServer > watchOptions would look like this:",
    "anchor": "Install-and-prompts-scripts",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1381,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Manually testing",
    "hierarchy_lvl3": "Uninstall script",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Learn more about what you can do with the Uninstall API.  Assuming you've installed your App Extension following the section above, we can now test the uninstall script (if you have any): The command above similarly does not modify or remove the npm package from package.json and node_modules. It simply calls the uninstall script and removes it from the registered/installed App Extensions list in your testing Quasar app project folder. Your end-user will however call $ quasar ext remove my-ext to uninstall it, which also uninstalls the npm package. You need to redo these install steps and issue the uninvoke command each time you make changes to the uninstall script and you want to test them.",
    "anchor": "Uninstall-script",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1382,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Manually testing",
    "hierarchy_lvl3": "Index script",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In the sections above we described how to test the prompts, install and uninstall scripts. Now it's time for the index script, which is the heart of your App Extension. This is where you can tamper with all quasar.config.js options, extend the Webpack configuration, register Quasar CLI commands, start up external services required for developing your app and many more. As a result, the index script is run each time $ quasar dev and $ quasar build are executed. In order to test the index script, you can repeat the uninstall and install procedures described above each time you change something in the App Extension script code. But it becomes very tedious. If you are developing on a Unix OS (MacOS, Linux), you can take advantage of the yarn link command which creates a symbolic link from the Quasar testing app's node_modules folder to the folder of your extension: Remember that if you need to yarn/npm install any dependencies into your App Extension, then you must also uninstall your App Extension and re-install it in your test app: You really only need to quasar ext invoke my-ext (install) the App Extension to re-install it. The above information is for completeness.  There have been many reports of problems with yarn link on Windows. This is outside of Quasar's reach, but is likely to do with your development environment, aka your mileage with Windows will vary.   Learn more about what you can do with the Index API.",
    "anchor": "Index-script",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1383,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "Publishing",
    "hierarchy_lvl3": "Index script",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Inside of your App Extension folder, run yarn publish or npm publish. Both do the same thing.  It's important to remember to NOT strip out the quasar-app-extension- prefix from the name property of your extension's package.json, otherwise Quasar CLI will not recognize it.",
    "anchor": "Publishing",
    "url": "/app-extensions/development-guide/introduction"
  },
  {
    "objectID": 1384,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Prompts API",
    "hierarchy_lvl2": "App Extension Prompts API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Syntax of the questions that the user is going to be asked in order to configure the Quasar App Extension.",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/prompts-api"
  },
  {
    "objectID": 1385,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Prompts API",
    "hierarchy_lvl2": "App Extension Prompts API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The user's answers are stored into /quasar.extensions.json (root of project folder), which should not be tampered with unless you really know what you are doing. Example of basic structure of the file: You will have access to api.prompts (which holds your App Extension's answers) in Install, Index and Uninstall. Let's now focus on the structure of the returned Array which defines the questions. The sections below offer examples for the most used types of questions.  The following is not an exhaustive list of possible types of questions and by no means it describes the full API available. Check out Inquirer.js for that (which is used by Quasar CLI under the covers).",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/prompts-api"
  },
  {
    "objectID": 1386,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Prompts API",
    "hierarchy_lvl2": "String",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "String",
    "url": "/app-extensions/development-guide/prompts-api"
  },
  {
    "objectID": 1387,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "App Extension Install API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The API for the install script of a Quasar App Extension. Initializes the app space by rendering or changing files and more.",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1388,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "App Extension Install API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example of basic structure of the file:",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1389,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.extId",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extId",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1390,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.appDir",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Ensure the App Extension is compatible with a package installed in the host app through a semver condition. If the semver condition is not met, then @quasar/app errors out and halts execution. Example of semver condition: '1.x || >=2.5.0 || 5.0.0 - 7.2.3'.",
    "anchor": "api.appDir",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1391,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.hasPackage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Determine if some package is installed in the host app through a semver condition. Example of semver condition: '1.x || >=2.5.0 || 5.0.0 - 7.2.3'.",
    "anchor": "api.hasPackage",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1392,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.hasExtension",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.hasExtension",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1393,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.getPackageVersion",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the version of a host app package.",
    "anchor": "api.getPackageVersion",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1394,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.extendPackageJson",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The above example adds an npm script to the app's package.json, so you can then execute yarn electron (or the equivalent npm run electron).",
    "anchor": "api.extendPackageJson",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1395,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.extendJsonFile",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extendJsonFile",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1396,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.render",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If some of the files already exist in the app then it will ask the user if they should be overwritten or not. Needs a relative path to the folder of the file calling render().",
    "anchor": "api.render",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1397,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.render",
    "hierarchy_lvl3": "Filename edge cases",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "If you want to render a file whose name actually begins with an underscore, then the filename must begin with __ (two underscore characters instead of only one):",
    "anchor": "Filename-edge-cases",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1398,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.render",
    "hierarchy_lvl3": "Using scope",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example: Let's imagine we use a Prompts API file too. It asks the user if he/she wants \"Feature X\" and stores the answer in a variable called \"featureX\". We can take some decisions on what the files that we render look like, during rendering them. This removes the need of creating two folders and deciding which to render, based on some decision. Possibilities are limited only by your imagination.",
    "anchor": "Using-scope",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1399,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.renderFile",
    "hierarchy_lvl3": "Using scope",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Similar with api.render() with the difference that this method renders a single file.",
    "anchor": "api.renderFile",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1400,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.getPersistentConf",
    "hierarchy_lvl3": "Using scope",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the internal persistent config of this extension. Returns empty object if it has none.",
    "anchor": "api.getPersistentConf",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1401,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.setPersistentConf",
    "hierarchy_lvl3": "Using scope",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Set the internal persistent config of this extension. If it already exists, it is overwritten.",
    "anchor": "api.setPersistentConf",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1402,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.mergePersistentConf",
    "hierarchy_lvl3": "Using scope",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Deep merge into the internal persistent config of this extension. If extension does not have any config already set, this is essentially equivalent to setting it for the first time.",
    "anchor": "api.mergePersistentConf",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1403,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Install API",
    "hierarchy_lvl2": "api.onExitLog",
    "hierarchy_lvl3": "Using scope",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.onExitLog",
    "url": "/app-extensions/development-guide/install-api"
  },
  {
    "objectID": 1404,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "App Extension Index API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The API for the index script of a Quasar App Extension. Provides access to Quasar context, registers new CLI commands, extends Webpack config and more.",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1405,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "App Extension Index API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example of basic structure of the file:",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1406,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.ctx",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example: You might want to use one of the api methods if running for electron mode only.",
    "anchor": "api.ctx",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1407,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extId",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extId",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1408,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.appDir",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Ensure the App Extension is compatible with a package installed in the host app through a semver condition. If the semver condition is not met, then @quasar/app errors out and halts execution. Example of semver condition: '1.x || >=2.5.0 || 5.0.0 - 7.2.3'.",
    "anchor": "api.appDir",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1409,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.hasPackage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Determine if some package is installed in the host app through a semver condition. Example of semver condition: '1.x || >=2.5.0 || 5.0.0 - 7.2.3'.",
    "anchor": "api.hasPackage",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1410,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.hasExtension",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.hasExtension",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1411,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.getPackageVersion",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the version of a host app package.",
    "anchor": "api.getPackageVersion",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1412,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extendQuasarConf",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extendQuasarConf",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1413,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extendQuasarConf",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Notice the tidle (~) in front of the paths. This tells Quasar CLI that the path is a dependency from node_modules instead of a relative path to App Extension index script file.",
    "anchor": "Registering-boot-and-css-files",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1414,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.chainWebpack",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The configuration is a Webpack chain Object. The API for it is described on webpack-chain docs.",
    "anchor": "api.chainWebpack",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1415,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extendWebpack",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extendWebpack",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1416,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.chainWebpackMainElectronProcess",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.chainWebpackMainElectronProcess",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1417,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extendWebpackMainElectronProcess",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extendWebpackMainElectronProcess",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1418,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.chainWebpackPreloadElectronProcess",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.chainWebpackPreloadElectronProcess",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1419,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extendWebpackPreloadElectronProcess",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extendWebpackPreloadElectronProcess",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1420,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.chainWebpackWebserver",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Chain webpack config of SSR webserver (content of /src-ssr)",
    "anchor": "api.chainWebpackWebserver",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1421,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.extendWebpackWebserver",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Extend webpack config Object of SSR webserver (content of /src-ssr)",
    "anchor": "api.extendWebpackWebserver",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1422,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.registerCommand",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.registerCommand",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1423,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.registerDescribeApi",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The above will then respond to $ quasar describe MyComponent. For syntax of such a JSON file, look into /node_modules/quasar/dist/api (in your project folder). Be aware that your JSON must contain a type property (\"component\", \"directive\", \"plugin\"). For instance:  Always test with the quasar describe command to ensure you got the syntax right and there are no errors.",
    "anchor": "api.registerDescribeApi",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1424,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.getPersistentConf",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the internal persistent config of this extension. Returns empty object if it has none.",
    "anchor": "api.getPersistentConf",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1425,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.setPersistentConf",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Set the internal persistent config of this extension. If it already exists, it is overwritten.",
    "anchor": "api.setPersistentConf",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1426,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.mergePersistentConf",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Deep merge into the internal persistent config of this extension. If extension does not have any config already set, this is essentially equivalent to setting it for the first time.",
    "anchor": "api.mergePersistentConf",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1427,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.beforeDev",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Prepare external services before $ quasar dev command runs, like starting some backend or any other service that the app relies on. Can use async/await or directly return a Promise.",
    "anchor": "api.beforeDev",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1428,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.afterDev",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Run hook after Quasar dev server is started ($ quasar build). At this point, the dev server has been started and is available should you wish to do something with it. Can use async/await or directly return a Promise.",
    "anchor": "api.afterDev",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1429,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.beforeBuild",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Run hook before Quasar builds app for production ($ quasar build). At this point, the distributables folder hasn't been created yet. Can use async/await or directly return a Promise.",
    "anchor": "api.beforeBuild",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1430,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.afterBuild",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Run hook after Quasar built app for production ($ quasar build). At this point, the distributables folder has been created and is available should you wish to do something with it. Can use async/await or directly return a Promise.",
    "anchor": "api.afterBuild",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1431,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Index API",
    "hierarchy_lvl2": "api.onPublish",
    "hierarchy_lvl3": "Registering boot and css files",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Run hook if publishing was requested ($ quasar build -P), after Quasar built app for production and the afterBuild hook (if specified) was executed. Can use async/await or directly return a Promise.",
    "anchor": "api.onPublish",
    "url": "/app-extensions/development-guide/index-api"
  },
  {
    "objectID": 1432,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "App Extension Uninstall API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The API for the uninstall script of a Quasar App Extension.",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1433,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "App Extension Uninstall API",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example of basic structure of the file:",
    "anchor": "Introduction",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1434,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.extId",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.extId",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1435,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.appDir",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Determine if some package is installed in the host app through a semver condition. Example of semver condition: '1.x || >=2.5.0 || 5.0.0 - 7.2.3'.",
    "anchor": "api.appDir",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1436,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.hasExtension",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.hasExtension",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1437,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.getPackageVersion",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the version of a host app package.",
    "anchor": "api.getPackageVersion",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1438,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.removePath",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Be mindful about it and do not delete the files that would break developer's app. The path to file or folder needs to be relative to project's root folder. The above example deletes \"my-folder\" from the root of the app.",
    "anchor": "api.removePath",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1439,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.getPersistentConf",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the internal persistent config of this extension. Returns empty object if it has none.",
    "anchor": "api.getPersistentConf",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1440,
    "hierarchy_lvl0": "Development Guide",
    "hierarchy_lvl1": "Uninstall API",
    "hierarchy_lvl2": "api.onExitLog",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "api.onExitLog",
    "url": "/app-extensions/development-guide/uninstall-api"
  },
  {
    "objectID": 1441,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "App Extension tips & tricks introduction",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Introduction to the list of Quasar App Extension tips & tricks documentation.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/introduction"
  },
  {
    "objectID": 1442,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Introduction",
    "hierarchy_lvl2": "App Extension tips & tricks introduction",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Enjoy!",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/introduction"
  },
  {
    "objectID": 1443,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Provide a UI component",
    "hierarchy_lvl2": "Provide a UI component",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks on how to provide a Vue component to the host app of a Quasar App Extension.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/provide-a-ui-component"
  },
  {
    "objectID": 1444,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Provide a UI component",
    "hierarchy_lvl2": "Provide a UI component",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for creating an App Extension project folder, please first read the Development Guide > Introduction.   Full Example To see an example of what we will build, head over to MyComponent full example, which is a github repo with this App Extension.  Create a folder structure to keep your code modularized and organized. For instance, for a UI component, create a structure that looks like this: Now, you need to handle registering your component. You do this with the /index.js file (described in the Index API) that was created when you set up your new App Extension. Let's break it down. The first group does a compatibility check with Quasar (which is optional, but recommended). If your component is using features of Quasar that were available after a certain version, you can make sure that the version of Quasar installed is the correct one.  Not only can you do a api.compatibleWith() to check against Quasar packages, but with any other available packages (that you do not supply yourself through your App Extension) as well. Please read Handling package dependencies section from the App Extension Development Guide > Introduction page for more information.  The second group tells Quasar to call our custom function when the extendQuasarConf CLI life-cycle hook is called. It would look something like this: Finally, let's see how the boot file would look like. Make sure that you read the Boot files documentation and understand what a Boot file is first.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/provide-a-ui-component"
  },
  {
    "objectID": 1445,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Provide a directive",
    "hierarchy_lvl2": "Providing a directive",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks on how to provide a Vue directive to the host app of a Quasar App Extension.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/provide-a-directive"
  },
  {
    "objectID": 1446,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Provide a directive",
    "hierarchy_lvl2": "Providing a directive",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To create an App Extension project folder, please first read the Development Guide > Introduction.   Full Example To see an example of what we will build, head over to MyDirective full example, which is a github repo with this App Extension.  Create a folder structure to keep your code modularized and organized. For instance, for a directive, create a structure that looks like this: Now, you need to handle registering your Vue directive. You do this with the /index.js file (described in the Index API) that was created when you set up your new App Extension. Let's break it down. The first group does a compatibility check with Quasar (which is optional, but recommended). If your component is using features of Quasar that were available after a certain version, you can make sure that the version of Quasar installed is the correct one.  Not only can you do a api.compatibleWith() to check against Quasar packages, but with any other available packages (that you do not supply yourself through your App Extension) as well. Please read Handling package dependencies section from the App Extension Development Guide > Introduction page for more information.  The second group tells Quasar to call our custom function when the extendQuasarConf CLI life-cycle hook is called. It would look something like this: Finally, let's see how the boot file would look like. Make sure that you read the Boot files documentation and understand what a Boot file is first.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/provide-a-directive"
  },
  {
    "objectID": 1447,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Inject Quasar Plugin",
    "hierarchy_lvl2": "Injecting Quasar Plugin",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks on how to use a Quasar App Extension to configure the host app to use a Quasar Plugin.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/inject-quasar-plugin"
  },
  {
    "objectID": 1448,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Inject Quasar Plugin",
    "hierarchy_lvl2": "Injecting Quasar Plugin",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for creating an App Extension project folder, please first read the Development Guide > Introduction.   Full Example To see an example of what we will build, head over to full example, which is a github repo with this App Extension.  We will only need the /index.js script for this, because we can use the Index API to configure quasar.conf.js from the host app to include our required Quasar Plugin. And /index.js would look like this: Our \"extendConf\" method, in the same file as above:",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/inject-quasar-plugin"
  },
  {
    "objectID": 1449,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Starter kit equivalent",
    "hierarchy_lvl2": "Starter kit equivalent",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks on how to use a Quasar App Extension to create the equivalent of a starter kit.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/starter-kit-equivalent"
  },
  {
    "objectID": 1450,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Starter kit equivalent",
    "hierarchy_lvl2": "Starter kit equivalent",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for creating an App Extension project folder, please first read the Development Guide > Introduction.   Full Example To see an example of what we will build, head over to MyStarterKit full example, which is a github repo with this App Extension.  We'll be creating an example App Extension which does the following: * it prompts the user what features it wants this App Extension to install * renders (copies) files into the hosting folder, according to the answers he gave * it extends /quasar.conf.js * it extends the Webpack configuration * it uses an App Extension hook (onPublish) * it removes the added files when the App Extension gets uninstalled * it uses the prompts to define what the App Extension does",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/starter-kit-equivalent"
  },
  {
    "objectID": 1451,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Starter kit equivalent",
    "hierarchy_lvl2": "The structure",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For the intents of this example, we'll be creating the following folder structure:",
    "anchor": "The-structure",
    "url": "/app-extensions/tips-and-tricks/starter-kit-equivalent"
  },
  {
    "objectID": 1452,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Starter kit equivalent",
    "hierarchy_lvl2": "The install script",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The install script below is only rendering files into the hosted app. Notice the src/templates folder above, where we decided to keep these templates. Notice that we use the prompts to decide what to render into the hosting project. Furthermore, if the user has selected \"service B\", then we'll also have a \"productName\" that we can use when we render the service B's file.",
    "anchor": "The-install-script",
    "url": "/app-extensions/tips-and-tricks/starter-kit-equivalent"
  },
  {
    "objectID": 1453,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Starter kit equivalent",
    "hierarchy_lvl2": "The index script",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "We do a few things in the index script, like extending /quasar.conf.js, hooking into one of the many Index API hooks (onPublish in this case), and chaining the Webpack configuration: Here's an example of extendQuasarConf definition: The onPublish function: The chainWebpack function:",
    "anchor": "The-index-script",
    "url": "/app-extensions/tips-and-tricks/starter-kit-equivalent"
  },
  {
    "objectID": 1454,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Starter kit equivalent",
    "hierarchy_lvl2": "The uninstall script",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "When the App Extension gets uninstall, we need to do some cleanup. But beware what you delete from the app-space! Some files might still be needed. Proceed with extreme care, if you decide to have an uninstall script. Notice that we are requesting rimraf npm package. This means that we yarn/npm added it into our App Extension project.",
    "anchor": "The-uninstall-script",
    "url": "/app-extensions/tips-and-tricks/starter-kit-equivalent"
  },
  {
    "objectID": 1455,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Chain Webpack",
    "hierarchy_lvl2": "Chain Webpack",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Tips and tricks on how to use a Quasar App Extension to configure the host app to use a Webpack loader.",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/chain-webpack"
  },
  {
    "objectID": 1456,
    "hierarchy_lvl0": "Tips and Tricks",
    "hierarchy_lvl1": "Chain Webpack",
    "hierarchy_lvl2": "Chain Webpack",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "In order for creating an App Extension project folder, please first read the Development Guide > Introduction.   Full Example To see an example of what we will build, head over to full example, which is a github repo with this App Extension.  We will only need the /index.js script for this, because we can use the Index API to configure quasar.conf.js from the host app to include our Webpack chaining. And /index.js would look like this: Our \"chainWebpack\" method, in the same file as above:",
    "anchor": "Introduction",
    "url": "/app-extensions/tips-and-tricks/chain-webpack"
  },
  {
    "objectID": 1457,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A set of Quasar methods for manipulating JS Date objects without the high additional cost of dedicated libraries.",
    "anchor": "Introduction",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1458,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Most Quasar date functions take as parameter either a Unix timestamp or a String representing a date which needs to be parsable by the native JS Date constructor. Some examples: 1497159857411, Sun Jun 11 2017 08:44:42 GMT+0300, 2017-06-16. Returned values are all JS Dates. Get familiar with JS native Date class, which is very powerful, and remember that you don't need solutions like Momentjs which add hundreds of minified KB to your bundle.  Quasar date utils includes tree shaking, except for the UMD version.  You will notice all examples import date Object from Quasar. However, if you need only one method from it, then you can use ES6 destructuring to help Tree Shaking embed only that method and not all of date. Example with addToDate():  For usage with the UMD build see here.",
    "anchor": "Introduction",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1459,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Format for display",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It takes a string of tokens and replaces them with their corresponding date values: For i18n, you can use a third parameter: Available format tokens:",
    "anchor": "Format-for-display",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1460,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Manipulate dates",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following method is just a wrapper to help you in cases where you just need current time but with a different year, or month, or second etc. You can pass a second argument (a boolean) for setting UTC time (true) instead of local time. The object literal provided can contain the following keys (all are optional):",
    "anchor": "Manipulate-dates",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1461,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Manipulate dates",
    "hierarchy_lvl3": "Validate",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Validate",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1462,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Manipulate dates",
    "hierarchy_lvl3": "Add/Subtract",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The object literal provided can contain the following keys (all are optional):",
    "anchor": "Add%2FSubtract",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1463,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Manipulate dates",
    "hierarchy_lvl3": "Set date/time",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can pass a third argument (a Boolean) for setting UTC time (true) instead of local time. The object literal provided can contain the following keys (all are optional):",
    "anchor": "Set-date%2Ftime",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1464,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Query dates",
    "hierarchy_lvl3": "Set date/time",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Note that the returning value is a timestamp.",
    "anchor": "Query-dates",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1465,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Query dates",
    "hierarchy_lvl3": "Time range",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To normalize a date in a given date/time range use:",
    "anchor": "Time-range",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1466,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Query dates",
    "hierarchy_lvl3": "Equality",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Unit parameter can be omitted, in which case a full date/time comparison will occur, otherwise it allows to perform partial comparison:",
    "anchor": "Equality",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1467,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Query dates",
    "hierarchy_lvl3": "Difference",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The unit parameter indicates the unit of measurement, if not specified then it is days by default:",
    "anchor": "Difference",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1468,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Query dates",
    "hierarchy_lvl3": "Calendar",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "To get the day number in year for a given date object use: To get the day number in week for a given date object use: To get the number of days in the month for the specified date:",
    "anchor": "Calendar",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1469,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Query dates",
    "hierarchy_lvl3": "Start/End of time",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The second parameter indicates a unit to reset to (beginning of it or end of it):",
    "anchor": "Start%2FEnd-of-time",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1470,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Other",
    "hierarchy_lvl3": "Start/End of time",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Other",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1471,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Other",
    "hierarchy_lvl3": "Cloning Date",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Cloning-Date",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1472,
    "hierarchy_lvl0": "Date Utils",
    "hierarchy_lvl1": "Date Utils",
    "hierarchy_lvl2": "Other",
    "hierarchy_lvl3": "Extract Date",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Using locale set by current Quasar language pack, this allows you to parse any string into a date object based on the format passed: With optional custom locale:",
    "anchor": "Extract-Date",
    "url": "/quasar-utils/date-utils"
  },
  {
    "objectID": 1473,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A set of Quasar methods for changing app brand colors and manipulating color strings.",
    "anchor": "Introduction",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1474,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "For usage with the UMD build see here.",
    "anchor": "Introduction",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1475,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Color Conversion",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Color-Conversion",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1476,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Color Processing",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Accepts a HEX/A String or a RGB/A String as color and a percent (0 to 100 or -100 to 0) of lighten/darken to be applied to the color. Returns a HEX String representation of the calculated color.",
    "anchor": "Color-Processing",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1477,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Color Processing",
    "hierarchy_lvl3": "luminosity (color)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Accepts a HEX/A String, a RGB/A String or a RGB/A Object as color. Returns a value between 0 and 1.",
    "anchor": "luminosity-(color)",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1478,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Color Processing",
    "hierarchy_lvl3": "brightness (color)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Accepts a HEX/A String, a RGB/A String or a RGB/A Object as color. Returns a value between 0 and 255. A value of < 128 would be considered a dark color.",
    "anchor": "brightness-(color)",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1479,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Color Processing",
    "hierarchy_lvl3": "blend (fgColor, bgColor)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Calculates the blend of two colors. Accepts a HEX/A String or a RGB/A Object as fgColor/bgColor. If the alpha channel of the fgColor is completely opaque, then the result will be the fgColor. If the alpha channel of the bgColor is completely opaque, then the resulting blended color will also be opaque. Returns the same type as input for fgColor.",
    "anchor": "blend-(fgColor%2C-bgColor)",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1480,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Color Processing",
    "hierarchy_lvl3": "changeAlpha (color, offset)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Increments or decrements the alpha of a string color. Accepts a HEX/A String as color and a number between -1 and 1 (including edges) as offset. Use a negative value to decrement and a positive number to increment (ex: changeAlpha('#ff0000', -0.1) to decrement alpha by 10%). Returns HEX/A String.",
    "anchor": "changeAlpha-(color%2C-offset)",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1481,
    "hierarchy_lvl0": "Color Utils",
    "hierarchy_lvl1": "Color Utils",
    "hierarchy_lvl2": "Helper - getPaletteColor",
    "hierarchy_lvl3": "changeAlpha (color, offset)",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "You can query any brand color, palette color or custom color in JS context to get its hex string value. Note that the method below is not cheap to run, so use it with care: Assuming you've created a custom color and named it \"my-color\", then you can extract its value in JS:",
    "anchor": "Helper---getPaletteColor",
    "url": "/quasar-utils/color-utils"
  },
  {
    "objectID": 1482,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A set of Quasar methods for DOM elements which helps you in retrieving the offset on screen viewport, getting and setting styles, waiting for the DOM to be ready and morphing DOM elements.",
    "anchor": "Introduction",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1483,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example with dom utils: ```js import { dom } from 'quasar' const { offset } = dom // Offset on screen console.log(offset(DomElement)) // { top: 10, left: 100 } ``` You can also import all of dom utils and use whatever you need like this (but note that your bundle will contain unused methods too): ```js import { dom } from 'quasar' // Offset on screen console.log(dom.offset(DomElement)) // { top: 10, left: 100 } ```  For usage with the UMD build see here.",
    "anchor": "Introduction",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1484,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": "Offset on screen viewport",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// Offset on screen console.log(offset(DomElement)) // { top: 10, left: 100 } ```",
    "anchor": "Offset-on-screen-viewport",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1485,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": "Get Computed Style",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Get-Computed-Style",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1486,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": "Get Height / Width",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// Some aliases of the previous method for \"width\" and \"height\" which // returns Numbers instead of Strings: console.log( height(DomElement), width(DomElement) ) // 10 100 ```",
    "anchor": "Get-Height-%2F-Width",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1487,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": "Apply CSS Properties in Batch",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// Apply a list of CSS properties to a DomNode css(DomElement, { height: '10px', display: 'flex' }) ```",
    "anchor": "Apply-CSS-Properties-in-Batch",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1488,
    "hierarchy_lvl0": "DOM Utils",
    "hierarchy_lvl1": "DOM Utils",
    "hierarchy_lvl2": "Execute when DOM is ready",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// Execute a Function when DOM is ready: ready(function () { // .... }) ```",
    "anchor": "Execute-when-DOM-is-ready",
    "url": "/quasar-utils/dom-utils"
  },
  {
    "objectID": 1489,
    "hierarchy_lvl0": "Morph Utils",
    "hierarchy_lvl1": "Morph Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Morph one DOM element into another (with animation) or between two states of the same element using Quasar's morph util.",
    "anchor": "Introduction",
    "url": "/quasar-utils/morph-utils"
  },
  {
    "objectID": 1490,
    "hierarchy_lvl0": "Morph Utils",
    "hierarchy_lvl1": "Morph Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Might also be worth to look at the Morph directive which uses this util but it's simpler to use.",
    "anchor": "Introduction",
    "url": "/quasar-utils/morph-utils"
  },
  {
    "objectID": 1491,
    "hierarchy_lvl0": "Morph Utils",
    "hierarchy_lvl1": "Morph Utils",
    "hierarchy_lvl2": "Basic usage",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The function expects one mandatory Object parameter with the following keys:",
    "anchor": "Basic-usage",
    "url": "/quasar-utils/morph-utils"
  },
  {
    "objectID": 1492,
    "hierarchy_lvl0": "Morph Utils",
    "hierarchy_lvl1": "Morph Utils",
    "hierarchy_lvl2": "Morphing lifecycle",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Get the aspect and position of the initial element (if a function is provided for getting the initial element it will be called) Calculate the size and position of the container of the initial element If another morphing was using the same element that morphing will be aborted Execute the onToggle() function (if present) Recalculate the size and position of the container of the initial element to check if they are changed In the next tick (to allow Vue to process the state changes) the final element will be identified (if a function is provided for getting the final element it will be called) If another morphing was using the same element that morphing will be aborted Calculate the size and position of the container of the final element If a waitFor is provided, wait that number of milliseconds, for a 'transitionend' event or until the promise is resolved (if the promise is rejected then the morphing is aborted) Recalculate the size and position of the container of the final element to check if they are changed Get the aspect and position of the final element Start the animation Regarding the cancel() function (the return value of a call to morph()): * If the cancel function that was returned is called during steps 1 to 11 then the morphing will be aborted (the toggle function will still be called if the cancel comes after step 4) and the returned value will be false. * If the cancel function is called between the start and end of the animation then the animation will be reversed and the returned value will be true. * If the cancel function is called after the end of the animation nothing will happen and the returned value will be false.",
    "anchor": "Morphing-lifecycle",
    "url": "/quasar-utils/morph-utils"
  },
  {
    "objectID": 1493,
    "hierarchy_lvl0": "Formatter Utils",
    "hierarchy_lvl1": "Formatter Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A set of Quasar methods for formatting values. Capitalizing, padding, normalizing and more.",
    "anchor": "Introduction",
    "url": "/quasar-utils/formatter-utils"
  },
  {
    "objectID": 1494,
    "hierarchy_lvl0": "Formatter Utils",
    "hierarchy_lvl1": "Formatter Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Example: ``js // we import all of format` import { format } from 'quasar' // destructuring to keep only what is needed const { capitalize, humanStorageSize } = format console.log( capitalize('some text') ) // Some text console.log( humanStorageSize(13087) ) // 12.78 kB ``` You can also import all formatters and use whatever you need like this (but note that your bundle will probably contain unused methods too): ```js import { format } from 'quasar' console.log( format.capitalize('some text') ) console.log( format.humanStorageSize(13087) ) ```  For usage with the UMD build see here.",
    "anchor": "Introduction",
    "url": "/quasar-utils/formatter-utils"
  },
  {
    "objectID": 1495,
    "hierarchy_lvl0": "Formatter Utils",
    "hierarchy_lvl1": "Formatter Utils",
    "hierarchy_lvl2": "Capitalize",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "console.log( capitalize('some text') ) // Some text ```",
    "anchor": "Capitalize",
    "url": "/quasar-utils/formatter-utils"
  },
  {
    "objectID": 1496,
    "hierarchy_lvl0": "Formatter Utils",
    "hierarchy_lvl1": "Formatter Utils",
    "hierarchy_lvl2": "Format to Human Readable Size",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "console.log( humanStorageSize(13087) ) // 12.78 kB ```",
    "anchor": "Format-to-Human-Readable-Size",
    "url": "/quasar-utils/formatter-utils"
  },
  {
    "objectID": 1497,
    "hierarchy_lvl0": "Formatter Utils",
    "hierarchy_lvl1": "Formatter Utils",
    "hierarchy_lvl2": "Normalize Number to Interval",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Normalize-Number-to-Interval",
    "url": "/quasar-utils/formatter-utils"
  },
  {
    "objectID": 1498,
    "hierarchy_lvl0": "Formatter Utils",
    "hierarchy_lvl1": "Formatter Utils",
    "hierarchy_lvl2": "Pad String",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "// (String) pad(String toPad, Number length, String paddingCharacter) // length is default 2 // paddingCharacter is default '0' console.log( pad('2', 4) ) // '0002' ```",
    "anchor": "Pad-String",
    "url": "/quasar-utils/formatter-utils"
  },
  {
    "objectID": 1499,
    "hierarchy_lvl0": "Scrolling Utils",
    "hierarchy_lvl1": "Scrolling Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A set of Quasar methods related to scrolling, like getting scroll target or changing the scroll position of a page.",
    "anchor": "Introduction",
    "url": "/quasar-utils/scrolling-utils"
  },
  {
    "objectID": 1500,
    "hierarchy_lvl0": "Scrolling Utils",
    "hierarchy_lvl1": "Scrolling Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "This method searches for a parent DOM element which has one of the scroll or overflow-auto Quasar CSS Helper class attached to it. If none is found, then it considers that the scrolling takes place on the document itself. Please note that simply attaching scroll CSS class to a DOM element or on a Vue component will have no effect if the respective element is not overflowed (example, with: CSS overflow: hidden and a height smaller than its inner content height). Example of good container:",
    "anchor": "Introduction",
    "url": "/quasar-utils/scrolling-utils"
  },
  {
    "objectID": 1501,
    "hierarchy_lvl0": "Scrolling Utils",
    "hierarchy_lvl1": "Scrolling Utils",
    "hierarchy_lvl2": "Get/set scroll position",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Horizontally:",
    "anchor": "Get%2Fset-scroll-position",
    "url": "/quasar-utils/scrolling-utils"
  },
  {
    "objectID": 1502,
    "hierarchy_lvl0": "Scrolling Utils",
    "hierarchy_lvl1": "Scrolling Utils",
    "hierarchy_lvl2": "Get/set scroll position",
    "hierarchy_lvl3": "Scrolling to an element",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Scrolling-to-an-element",
    "url": "/quasar-utils/scrolling-utils"
  },
  {
    "objectID": 1503,
    "hierarchy_lvl0": "Scrolling Utils",
    "hierarchy_lvl1": "Scrolling Utils",
    "hierarchy_lvl2": "Determine scroll size",
    "hierarchy_lvl3": "Scrolling to an element",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Horizontally:",
    "anchor": "Determine-scroll-size",
    "url": "/quasar-utils/scrolling-utils"
  },
  {
    "objectID": 1504,
    "hierarchy_lvl0": "Scrolling Utils",
    "hierarchy_lvl1": "Scrolling Utils",
    "hierarchy_lvl2": "Determining scrollbar width",
    "hierarchy_lvl3": "Scrolling to an element",
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Determining-scrollbar-width",
    "url": "/quasar-utils/scrolling-utils"
  },
  {
    "objectID": 1505,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "A set of miscellaneous Quasar methods for debouncing or throttling functions, deep copying objects, cross-platform URL opening or handling DOM events.",
    "anchor": "Introduction",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1506,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": null,
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "It will take care of the quirks involved when running under Cordova, Electron or on a browser, including notifying the user he/she has to acknowledge opening popups. When wrapping with Cordova (or Capacitor), it's best (but not \"a must do\") if InAppBrowser Cordova plugin is also installed, so that openURL can hook into that. If running on iOS and cordova-plugin-safariviewcontroller is installed, then openURL will first try to hook into it. The optional windowFeatures parameter should be an Object with keys from window.open() windowFeatures and Boolean values (as described in the example below). Please note that these features will not be taken into account when openURL does not defers to using window.open().  If you want to open the telephone dialer in a Cordova app, don't use openURL(). Instead you should directly use <a href=\"tel:123456789\"> tags or <QBtn type=\"a\" href=\"tel:123456789\">",
    "anchor": "Introduction",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1507,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "Copy to Clipboard",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following is a helper to copy some text to Clipboard. The method returns a Promise.",
    "anchor": "Copy-to-Clipboard",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1508,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "Export file",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "The following is a helper to trigger a file download. The simplest example:",
    "anchor": "Export-file",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1509,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "Debounce Function",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Debouncing enforces that a function not be called again until a certain amount of time has passed without it being called. As in \"execute this function only if 100 milliseconds have passed without it being called.\" A quick example: you have a resize listener on the window which does some element dimension calculations and (possibly) repositions a few elements. That isn't a heavy task in itself but being repeatedly fired after numerous resizes will really slow your App down. So why not limit the rate at which the function can fire? Or calling as a method in a .vue file:  Debouncing your functions using a method declaration like myMethod: debounce(function () { // Code }, 500) will mean that the debounced method will be shared between all rendered instances of this component, so debouncing is also shared. Moreover, this.myMethod.cancel() won't work, because Vue wraps each method with another function to ensure proper this binding. This should be avoided by following the code snippet above.  There's also a frameDebounce available which delays calling your function until next browser frame is scheduled to run (read about requestAnimationFrame).",
    "anchor": "Debounce-Function",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1510,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "Throttle Function",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Or calling as a method in a .vue file:  Throttling your functions using a method declaration like myMethod: throttle(function () { // Code }, 500) will mean that the throttled method will be shared between all rendered instances of this component, so throttling is also shared. This should be avoided by following the code snippet above.",
    "anchor": "Throttle-Function",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1511,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "(Deep) Copy Objects",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "Watch out for methods within objects.",
    "anchor": "(Deep)-Copy-Objects",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1512,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "Generate UID",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Generate-UID",
    "url": "/quasar-utils/other-utils"
  },
  {
    "objectID": 1513,
    "hierarchy_lvl0": "Other Utils",
    "hierarchy_lvl1": "Other Utils",
    "hierarchy_lvl2": "Handling event on a DOM event handler",
    "hierarchy_lvl3": null,
    "hierarchy_lvl4": null,
    "hierarchy_lvl5": null,
    "hierarchy_lvl6": null,
    "content": "",
    "anchor": "Handling-event-on-a-DOM-event-handler",
    "url": "/quasar-utils/other-utils"
  }
]